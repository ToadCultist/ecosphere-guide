/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/bson-objectid/objectid.js
var require_objectid = __commonJS({
  "node_modules/bson-objectid/objectid.js"(exports, module2) {
    var MACHINE_ID = Math.floor(Math.random() * 16777215);
    var index = ObjectID3.index = parseInt(Math.random() * 16777215, 10);
    var pid = (typeof process === "undefined" || typeof process.pid !== "number" ? Math.floor(Math.random() * 1e5) : process.pid) % 65535;
    var BufferCtr = (() => {
      try {
        return _Buffer;
      } catch (_) {
        try {
          return Buffer;
        } catch (_2) {
          return null;
        }
      }
    })();
    var isBuffer = function(obj) {
      return !!(obj != null && obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj));
    };
    var hexTable = [];
    for (i = 0; i < 256; i++) {
      hexTable[i] = (i <= 15 ? "0" : "") + i.toString(16);
    }
    var i;
    var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
    var decodeLookup = [];
    i = 0;
    while (i < 10)
      decodeLookup[48 + i] = i++;
    while (i < 16)
      decodeLookup[65 - 10 + i] = decodeLookup[97 - 10 + i] = i++;
    function ObjectID3(id) {
      if (!(this instanceof ObjectID3))
        return new ObjectID3(id);
      if (id && (id instanceof ObjectID3 || id._bsontype === "ObjectID"))
        return id;
      this._bsontype = "ObjectID";
      if (id == null || typeof id === "number") {
        this.id = this.generate(id);
        return;
      }
      var valid = ObjectID3.isValid(id);
      if (!valid && id != null) {
        throw new Error(
          "Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"
        );
      } else if (valid && typeof id === "string" && id.length === 24) {
        return ObjectID3.createFromHexString(id);
      } else if (id != null && id.length === 12) {
        this.id = id;
      } else if (id != null && typeof id.toHexString === "function") {
        return id;
      } else {
        throw new Error(
          "Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"
        );
      }
    }
    module2.exports = ObjectID3;
    ObjectID3.default = ObjectID3;
    ObjectID3.createFromTime = function(time) {
      time = parseInt(time, 10) % 4294967295;
      return new ObjectID3(hex(8, time) + "0000000000000000");
    };
    ObjectID3.createFromHexString = function(hexString) {
      if (typeof hexString === "undefined" || hexString != null && hexString.length !== 24) {
        throw new Error(
          "Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"
        );
      }
      var data = "";
      var i2 = 0;
      while (i2 < 24) {
        data += String.fromCharCode(decodeLookup[hexString.charCodeAt(i2++)] << 4 | decodeLookup[hexString.charCodeAt(i2++)]);
      }
      return new ObjectID3(data);
    };
    ObjectID3.isValid = function(id) {
      if (id == null)
        return false;
      if (typeof id === "number") {
        return true;
      }
      if (typeof id === "string") {
        return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);
      }
      if (id instanceof ObjectID3) {
        return true;
      }
      if (isBuffer(id)) {
        return ObjectID3.isValid(id.toString("hex"));
      }
      if (typeof id.toHexString === "function") {
        if (BufferCtr && (id.id instanceof BufferCtr || typeof id.id === "string")) {
          return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);
        }
      }
      return false;
    };
    ObjectID3.prototype = {
      constructor: ObjectID3,
      /**
       * Return the ObjectID id as a 24 byte hex string representation
       *
       * @return {String} return the 24 byte hex string representation.
       * @api public
       */
      toHexString: function() {
        if (!this.id || !this.id.length) {
          throw new Error(
            "invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [" + JSON.stringify(this.id) + "]"
          );
        }
        if (this.id.length === 24) {
          return this.id;
        }
        if (isBuffer(this.id)) {
          return this.id.toString("hex");
        }
        var hexString = "";
        for (var i2 = 0; i2 < this.id.length; i2++) {
          hexString += hexTable[this.id.charCodeAt(i2)];
        }
        return hexString;
      },
      /**
       * Compares the equality of this ObjectID with `otherID`.
       *
       * @param {Object} otherId ObjectID instance to compare against.
       * @return {Boolean} the result of comparing two ObjectID's
       * @api public
       */
      equals: function(otherId) {
        if (otherId instanceof ObjectID3) {
          return this.toString() === otherId.toString();
        } else if (typeof otherId === "string" && ObjectID3.isValid(otherId) && otherId.length === 12 && isBuffer(this.id)) {
          return otherId === this.id.toString("binary");
        } else if (typeof otherId === "string" && ObjectID3.isValid(otherId) && otherId.length === 24) {
          return otherId.toLowerCase() === this.toHexString();
        } else if (typeof otherId === "string" && ObjectID3.isValid(otherId) && otherId.length === 12) {
          return otherId === this.id;
        } else if (otherId != null && (otherId instanceof ObjectID3 || otherId.toHexString)) {
          return otherId.toHexString() === this.toHexString();
        } else {
          return false;
        }
      },
      /**
       * Returns the generation date (accurate up to the second) that this ID was generated.
       *
       * @return {Date} the generation date
       * @api public
       */
      getTimestamp: function() {
        var timestamp = new Date();
        var time;
        if (isBuffer(this.id)) {
          time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
        } else {
          time = this.id.charCodeAt(3) | this.id.charCodeAt(2) << 8 | this.id.charCodeAt(1) << 16 | this.id.charCodeAt(0) << 24;
        }
        timestamp.setTime(Math.floor(time) * 1e3);
        return timestamp;
      },
      /**
      * Generate a 12 byte id buffer used in ObjectID's
      *
      * @method
      * @param {number} [time] optional parameter allowing to pass in a second based timestamp.
      * @return {string} return the 12 byte id buffer string.
      */
      generate: function(time) {
        if ("number" !== typeof time) {
          time = ~~(Date.now() / 1e3);
        }
        time = parseInt(time, 10) % 4294967295;
        var inc = next();
        return String.fromCharCode(
          time >> 24 & 255,
          time >> 16 & 255,
          time >> 8 & 255,
          time & 255,
          MACHINE_ID >> 16 & 255,
          MACHINE_ID >> 8 & 255,
          MACHINE_ID & 255,
          pid >> 8 & 255,
          pid & 255,
          inc >> 16 & 255,
          inc >> 8 & 255,
          inc & 255
        );
      }
    };
    function next() {
      return index = (index + 1) % 16777215;
    }
    function hex(length, n) {
      n = n.toString(16);
      return n.length === length ? n : "00000000".substring(n.length, length) + n;
    }
    var inspect = Symbol && Symbol.for && Symbol.for("nodejs.util.inspect.custom") || "inspect";
    ObjectID3.prototype[inspect] = function() {
      return "ObjectID(" + this + ")";
    };
    ObjectID3.prototype.toJSON = ObjectID3.prototype.toHexString;
    ObjectID3.prototype.toString = ObjectID3.prototype.toHexString;
  }
});

// node_modules/chrono-node/dist/utils/pattern.js
var require_pattern = __commonJS({
  "node_modules/chrono-node/dist/utils/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.matchAnyPattern = exports.extractTerms = exports.repeatedTimeunitPattern = void 0;
    function repeatedTimeunitPattern(prefix, singleTimeunitPattern) {
      const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\((?!\?)/g, "(?:");
      return `${prefix}${singleTimeunitPatternNoCapture}\\s{0,5}(?:,?\\s{0,5}${singleTimeunitPatternNoCapture}){0,10}`;
    }
    exports.repeatedTimeunitPattern = repeatedTimeunitPattern;
    function extractTerms(dictionary) {
      let keys;
      if (dictionary instanceof Array) {
        keys = [...dictionary];
      } else if (dictionary instanceof Map) {
        keys = Array.from(dictionary.keys());
      } else {
        keys = Object.keys(dictionary);
      }
      return keys;
    }
    exports.extractTerms = extractTerms;
    function matchAnyPattern(dictionary) {
      const joinedTerms = extractTerms(dictionary).sort((a, b) => b.length - a.length).join("|").replace(/\./g, "\\.");
      return `(?:${joinedTerms})`;
    }
    exports.matchAnyPattern = matchAnyPattern;
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2)
          return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1)
            return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function(t2, e2) {
        if (S(t2))
          return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t2, e2) {
        return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2)
              return new Date(NaN);
            if (b.u(e2))
              return new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f2), y2 = function(t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c)
            return this.set(c, this.$M + r2);
          if ($2 === h)
            return this.set(h, this.$y + r2);
          if ($2 === a)
            return y2(1);
          if ($2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f2 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, function(t3, r3) {
            return r3 || function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t3) || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), O.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  }
});

// node_modules/chrono-node/dist/calculation/years.js
var require_years = __commonJS({
  "node_modules/chrono-node/dist/calculation/years.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findYearClosestToRef = exports.findMostLikelyADYear = void 0;
    var dayjs_1 = __importDefault(require_dayjs_min());
    function findMostLikelyADYear(yearNumber) {
      if (yearNumber < 100) {
        if (yearNumber > 50) {
          yearNumber = yearNumber + 1900;
        } else {
          yearNumber = yearNumber + 2e3;
        }
      }
      return yearNumber;
    }
    exports.findMostLikelyADYear = findMostLikelyADYear;
    function findYearClosestToRef(refDate, day, month) {
      const refMoment = dayjs_1.default(refDate);
      let dateMoment = refMoment;
      dateMoment = dateMoment.month(month - 1);
      dateMoment = dateMoment.date(day);
      dateMoment = dateMoment.year(refMoment.year());
      const nextYear = dateMoment.add(1, "y");
      const lastYear = dateMoment.add(-1, "y");
      if (Math.abs(nextYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
        dateMoment = nextYear;
      } else if (Math.abs(lastYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
        dateMoment = lastYear;
      }
      return dateMoment.year();
    }
    exports.findYearClosestToRef = findYearClosestToRef;
  }
});

// node_modules/chrono-node/dist/locales/en/constants.js
var require_constants = __commonJS({
  "node_modules/chrono-node/dist/locales/en/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.FULL_MONTH_NAME_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      sunday: 0,
      sun: 0,
      "sun.": 0,
      monday: 1,
      mon: 1,
      "mon.": 1,
      tuesday: 2,
      tue: 2,
      "tue.": 2,
      wednesday: 3,
      wed: 3,
      "wed.": 3,
      thursday: 4,
      thurs: 4,
      "thurs.": 4,
      thur: 4,
      "thur.": 4,
      thu: 4,
      "thu.": 4,
      friday: 5,
      fri: 5,
      "fri.": 5,
      saturday: 6,
      sat: 6,
      "sat.": 6
    };
    exports.FULL_MONTH_NAME_DICTIONARY = {
      january: 1,
      february: 2,
      march: 3,
      april: 4,
      may: 5,
      june: 6,
      july: 7,
      august: 8,
      september: 9,
      october: 10,
      november: 11,
      december: 12
    };
    exports.MONTH_DICTIONARY = Object.assign(Object.assign({}, exports.FULL_MONTH_NAME_DICTIONARY), { jan: 1, "jan.": 1, feb: 2, "feb.": 2, mar: 3, "mar.": 3, apr: 4, "apr.": 4, jun: 6, "jun.": 6, jul: 7, "jul.": 7, aug: 8, "aug.": 8, sep: 9, "sep.": 9, sept: 9, "sept.": 9, oct: 10, "oct.": 10, nov: 11, "nov.": 11, dec: 12, "dec.": 12 });
    exports.INTEGER_WORD_DICTIONARY = {
      one: 1,
      two: 2,
      three: 3,
      four: 4,
      five: 5,
      six: 6,
      seven: 7,
      eight: 8,
      nine: 9,
      ten: 10,
      eleven: 11,
      twelve: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      first: 1,
      second: 2,
      third: 3,
      fourth: 4,
      fifth: 5,
      sixth: 6,
      seventh: 7,
      eighth: 8,
      ninth: 9,
      tenth: 10,
      eleventh: 11,
      twelfth: 12,
      thirteenth: 13,
      fourteenth: 14,
      fifteenth: 15,
      sixteenth: 16,
      seventeenth: 17,
      eighteenth: 18,
      nineteenth: 19,
      twentieth: 20,
      "twenty first": 21,
      "twenty-first": 21,
      "twenty second": 22,
      "twenty-second": 22,
      "twenty third": 23,
      "twenty-third": 23,
      "twenty fourth": 24,
      "twenty-fourth": 24,
      "twenty fifth": 25,
      "twenty-fifth": 25,
      "twenty sixth": 26,
      "twenty-sixth": 26,
      "twenty seventh": 27,
      "twenty-seventh": 27,
      "twenty eighth": 28,
      "twenty-eighth": 28,
      "twenty ninth": 29,
      "twenty-ninth": 29,
      "thirtieth": 30,
      "thirty first": 31,
      "thirty-first": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      sec: "second",
      second: "second",
      seconds: "second",
      min: "minute",
      mins: "minute",
      minute: "minute",
      minutes: "minute",
      h: "hour",
      hr: "hour",
      hrs: "hour",
      hour: "hour",
      hours: "hour",
      day: "d",
      days: "d",
      week: "week",
      weeks: "week",
      month: "month",
      months: "month",
      qtr: "quarter",
      quarter: "quarter",
      quarters: "quarter",
      y: "year",
      yr: "year",
      year: "year",
      years: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s{0,2}an?)?|an?\\b(?:\\s{0,2}few)?|few|several|a?\\s{0,2}couple\\s{0,2}(?:of)?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "a" || num === "an") {
        return 1;
      } else if (num.match(/few/)) {
        return 3;
      } else if (num.match(/half/)) {
        return 0.5;
      } else if (num.match(/couple/)) {
        return 2;
      } else if (num.match(/several/)) {
        return 7;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:st|nd|rd|th)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:st|nd|rd|th)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/BE/i.test(match)) {
        match = match.replace(/BE/i, "");
        return parseInt(match) - 543;
      }
      if (/BCE?/i.test(match)) {
        match = match.replace(/BCE?/i, "");
        return -parseInt(match);
      }
      if (/(AD|CE)/i.test(match)) {
        match = match.replace(/(AD|CE)/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,3}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length).trim();
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/dayjs/plugin/quarterOfYear.js
var require_quarterOfYear = __commonJS({
  "node_modules/dayjs/plugin/quarterOfYear.js"(exports, module2) {
    !function(t, n) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = n() : "function" == typeof define && define.amd ? define(n) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_quarterOfYear = n();
    }(exports, function() {
      "use strict";
      var t = "month", n = "quarter";
      return function(e, i) {
        var r = i.prototype;
        r.quarter = function(t2) {
          return this.$utils().u(t2) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t2 - 1));
        };
        var s = r.add;
        r.add = function(e2, i2) {
          return e2 = Number(e2), this.$utils().p(i2) === n ? this.add(3 * e2, t) : s.bind(this)(e2, i2);
        };
        var u = r.startOf;
        r.startOf = function(e2, i2) {
          var r2 = this.$utils(), s2 = !!r2.u(i2) || i2;
          if (r2.p(e2) === n) {
            var o = this.quarter() - 1;
            return s2 ? this.month(3 * o).startOf(t).startOf("day") : this.month(3 * o + 2).endOf(t).endOf("day");
          }
          return u.bind(this)(e2, i2);
        };
      };
    });
  }
});

// node_modules/chrono-node/dist/utils/dayjs.js
var require_dayjs = __commonJS({
  "node_modules/chrono-node/dist/utils/dayjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.implySimilarTime = exports.assignSimilarTime = exports.assignSimilarDate = exports.assignTheNextDay = void 0;
    var index_1 = require_dist();
    function assignTheNextDay(component, targetDayJs) {
      targetDayJs = targetDayJs.add(1, "day");
      assignSimilarDate(component, targetDayJs);
      implySimilarTime(component, targetDayJs);
    }
    exports.assignTheNextDay = assignTheNextDay;
    function assignSimilarDate(component, targetDayJs) {
      component.assign("day", targetDayJs.date());
      component.assign("month", targetDayJs.month() + 1);
      component.assign("year", targetDayJs.year());
    }
    exports.assignSimilarDate = assignSimilarDate;
    function assignSimilarTime(component, targetDayJs) {
      component.assign("hour", targetDayJs.hour());
      component.assign("minute", targetDayJs.minute());
      component.assign("second", targetDayJs.second());
      component.assign("millisecond", targetDayJs.millisecond());
      if (component.get("hour") < 12) {
        component.assign("meridiem", index_1.Meridiem.AM);
      } else {
        component.assign("meridiem", index_1.Meridiem.PM);
      }
    }
    exports.assignSimilarTime = assignSimilarTime;
    function implySimilarTime(component, targetDayJs) {
      component.imply("hour", targetDayJs.hour());
      component.imply("minute", targetDayJs.minute());
      component.imply("second", targetDayJs.second());
      component.imply("millisecond", targetDayJs.millisecond());
    }
    exports.implySimilarTime = implySimilarTime;
  }
});

// node_modules/chrono-node/dist/timezone.js
var require_timezone = __commonJS({
  "node_modules/chrono-node/dist/timezone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toTimezoneOffset = exports.TIMEZONE_ABBR_MAP = void 0;
    exports.TIMEZONE_ABBR_MAP = {
      ACDT: 630,
      ACST: 570,
      ADT: -180,
      AEDT: 660,
      AEST: 600,
      AFT: 270,
      AKDT: -480,
      AKST: -540,
      ALMT: 360,
      AMST: -180,
      AMT: -240,
      ANAST: 720,
      ANAT: 720,
      AQTT: 300,
      ART: -180,
      AST: -240,
      AWDT: 540,
      AWST: 480,
      AZOST: 0,
      AZOT: -60,
      AZST: 300,
      AZT: 240,
      BNT: 480,
      BOT: -240,
      BRST: -120,
      BRT: -180,
      BST: 60,
      BTT: 360,
      CAST: 480,
      CAT: 120,
      CCT: 390,
      CDT: -300,
      CEST: 120,
      CET: 60,
      CHADT: 825,
      CHAST: 765,
      CKT: -600,
      CLST: -180,
      CLT: -240,
      COT: -300,
      CST: -360,
      CVT: -60,
      CXT: 420,
      ChST: 600,
      DAVT: 420,
      EASST: -300,
      EAST: -360,
      EAT: 180,
      ECT: -300,
      EDT: -240,
      EEST: 180,
      EET: 120,
      EGST: 0,
      EGT: -60,
      EST: -300,
      ET: -300,
      FJST: 780,
      FJT: 720,
      FKST: -180,
      FKT: -240,
      FNT: -120,
      GALT: -360,
      GAMT: -540,
      GET: 240,
      GFT: -180,
      GILT: 720,
      GMT: 0,
      GST: 240,
      GYT: -240,
      HAA: -180,
      HAC: -300,
      HADT: -540,
      HAE: -240,
      HAP: -420,
      HAR: -360,
      HAST: -600,
      HAT: -90,
      HAY: -480,
      HKT: 480,
      HLV: -210,
      HNA: -240,
      HNC: -360,
      HNE: -300,
      HNP: -480,
      HNR: -420,
      HNT: -150,
      HNY: -540,
      HOVT: 420,
      ICT: 420,
      IDT: 180,
      IOT: 360,
      IRDT: 270,
      IRKST: 540,
      IRKT: 540,
      IRST: 210,
      IST: 330,
      JST: 540,
      KGT: 360,
      KRAST: 480,
      KRAT: 480,
      KST: 540,
      KUYT: 240,
      LHDT: 660,
      LHST: 630,
      LINT: 840,
      MAGST: 720,
      MAGT: 720,
      MART: -510,
      MAWT: 300,
      MDT: -360,
      MESZ: 120,
      MEZ: 60,
      MHT: 720,
      MMT: 390,
      MSD: 240,
      MSK: 180,
      MST: -420,
      MUT: 240,
      MVT: 300,
      MYT: 480,
      NCT: 660,
      NDT: -90,
      NFT: 690,
      NOVST: 420,
      NOVT: 360,
      NPT: 345,
      NST: -150,
      NUT: -660,
      NZDT: 780,
      NZST: 720,
      OMSST: 420,
      OMST: 420,
      PDT: -420,
      PET: -300,
      PETST: 720,
      PETT: 720,
      PGT: 600,
      PHOT: 780,
      PHT: 480,
      PKT: 300,
      PMDT: -120,
      PMST: -180,
      PONT: 660,
      PST: -480,
      PT: -480,
      PWT: 540,
      PYST: -180,
      PYT: -240,
      RET: 240,
      SAMT: 240,
      SAST: 120,
      SBT: 660,
      SCT: 240,
      SGT: 480,
      SRT: -180,
      SST: -660,
      TAHT: -600,
      TFT: 300,
      TJT: 300,
      TKT: 780,
      TLT: 540,
      TMT: 300,
      TVT: 720,
      ULAT: 480,
      UTC: 0,
      UYST: -120,
      UYT: -180,
      UZT: 300,
      VET: -210,
      VLAST: 660,
      VLAT: 660,
      VUT: 660,
      WAST: 120,
      WAT: 60,
      WEST: 60,
      WESZ: 60,
      WET: 0,
      WEZ: 0,
      WFT: 720,
      WGST: -120,
      WGT: -180,
      WIB: 420,
      WIT: 540,
      WITA: 480,
      WST: 780,
      WT: 0,
      YAKST: 600,
      YAKT: 600,
      YAPT: 600,
      YEKST: 360,
      YEKT: 360
    };
    function toTimezoneOffset(timezoneInput) {
      var _a;
      if (timezoneInput === null || timezoneInput === void 0) {
        return null;
      }
      if (typeof timezoneInput === "number") {
        return timezoneInput;
      }
      return (_a = exports.TIMEZONE_ABBR_MAP[timezoneInput]) !== null && _a !== void 0 ? _a : null;
    }
    exports.toTimezoneOffset = toTimezoneOffset;
  }
});

// node_modules/chrono-node/dist/results.js
var require_results = __commonJS({
  "node_modules/chrono-node/dist/results.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsingResult = exports.ParsingComponents = exports.ReferenceWithTimezone = void 0;
    var quarterOfYear_1 = __importDefault(require_quarterOfYear());
    var dayjs_1 = __importDefault(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var timezone_1 = require_timezone();
    dayjs_1.default.extend(quarterOfYear_1.default);
    var ReferenceWithTimezone = class {
      constructor(input) {
        var _a;
        input = input !== null && input !== void 0 ? input : new Date();
        if (input instanceof Date) {
          this.instant = input;
        } else {
          this.instant = (_a = input.instant) !== null && _a !== void 0 ? _a : new Date();
          this.timezoneOffset = timezone_1.toTimezoneOffset(input.timezone);
        }
      }
    };
    exports.ReferenceWithTimezone = ReferenceWithTimezone;
    var ParsingComponents = class {
      constructor(reference2, knownComponents) {
        this.reference = reference2;
        this.knownValues = {};
        this.impliedValues = {};
        if (knownComponents) {
          for (const key in knownComponents) {
            this.knownValues[key] = knownComponents[key];
          }
        }
        const refDayJs = dayjs_1.default(reference2.instant);
        this.imply("day", refDayJs.date());
        this.imply("month", refDayJs.month() + 1);
        this.imply("year", refDayJs.year());
        this.imply("hour", 12);
        this.imply("minute", 0);
        this.imply("second", 0);
        this.imply("millisecond", 0);
      }
      get(component) {
        if (component in this.knownValues) {
          return this.knownValues[component];
        }
        if (component in this.impliedValues) {
          return this.impliedValues[component];
        }
        return null;
      }
      isCertain(component) {
        return component in this.knownValues;
      }
      getCertainComponents() {
        return Object.keys(this.knownValues);
      }
      imply(component, value) {
        if (component in this.knownValues) {
          return this;
        }
        this.impliedValues[component] = value;
        return this;
      }
      assign(component, value) {
        this.knownValues[component] = value;
        delete this.impliedValues[component];
        return this;
      }
      delete(component) {
        delete this.knownValues[component];
        delete this.impliedValues[component];
      }
      clone() {
        const component = new ParsingComponents(this.reference);
        component.knownValues = {};
        component.impliedValues = {};
        for (const key in this.knownValues) {
          component.knownValues[key] = this.knownValues[key];
        }
        for (const key in this.impliedValues) {
          component.impliedValues[key] = this.impliedValues[key];
        }
        return component;
      }
      isOnlyDate() {
        return !this.isCertain("hour") && !this.isCertain("minute") && !this.isCertain("second");
      }
      isOnlyTime() {
        return !this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
      }
      isOnlyWeekdayComponent() {
        return this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
      }
      isOnlyDayMonthComponent() {
        return this.isCertain("day") && this.isCertain("month") && !this.isCertain("year");
      }
      isValidDate() {
        const date = this.dateWithoutTimezoneAdjustment();
        if (date.getFullYear() !== this.get("year"))
          return false;
        if (date.getMonth() !== this.get("month") - 1)
          return false;
        if (date.getDate() !== this.get("day"))
          return false;
        if (this.get("hour") != null && date.getHours() != this.get("hour"))
          return false;
        if (this.get("minute") != null && date.getMinutes() != this.get("minute"))
          return false;
        return true;
      }
      toString() {
        return `[ParsingComponents {knownValues: ${JSON.stringify(this.knownValues)}, impliedValues: ${JSON.stringify(this.impliedValues)}}, reference: ${JSON.stringify(this.reference)}]`;
      }
      dayjs() {
        return dayjs_1.default(this.date());
      }
      date() {
        const date = this.dateWithoutTimezoneAdjustment();
        return new Date(date.getTime() + this.getSystemTimezoneAdjustmentMinute(date) * 6e4);
      }
      dateWithoutTimezoneAdjustment() {
        const date = new Date(this.get("year"), this.get("month") - 1, this.get("day"), this.get("hour"), this.get("minute"), this.get("second"), this.get("millisecond"));
        date.setFullYear(this.get("year"));
        return date;
      }
      getSystemTimezoneAdjustmentMinute(date) {
        var _a, _b;
        if (!date || date.getTime() < 0) {
          date = new Date();
        }
        const currentTimezoneOffset = -date.getTimezoneOffset();
        const targetTimezoneOffset = (_b = (_a = this.get("timezoneOffset")) !== null && _a !== void 0 ? _a : this.reference.timezoneOffset) !== null && _b !== void 0 ? _b : currentTimezoneOffset;
        return currentTimezoneOffset - targetTimezoneOffset;
      }
      static createRelativeFromReference(reference2, fragments) {
        let date = dayjs_1.default(reference2.instant);
        for (const key in fragments) {
          date = date.add(fragments[key], key);
        }
        const components = new ParsingComponents(reference2);
        if (fragments["hour"] || fragments["minute"] || fragments["second"]) {
          dayjs_2.assignSimilarTime(components, date);
          dayjs_2.assignSimilarDate(components, date);
          if (reference2.timezoneOffset !== null) {
            components.assign("timezoneOffset", -reference2.instant.getTimezoneOffset());
          }
        } else {
          dayjs_2.implySimilarTime(components, date);
          if (reference2.timezoneOffset !== null) {
            components.imply("timezoneOffset", -reference2.instant.getTimezoneOffset());
          }
          if (fragments["d"]) {
            components.assign("day", date.date());
            components.assign("month", date.month() + 1);
            components.assign("year", date.year());
          } else {
            if (fragments["week"]) {
              components.imply("weekday", date.day());
            }
            components.imply("day", date.date());
            if (fragments["month"]) {
              components.assign("month", date.month() + 1);
              components.assign("year", date.year());
            } else {
              components.imply("month", date.month() + 1);
              if (fragments["year"]) {
                components.assign("year", date.year());
              } else {
                components.imply("year", date.year());
              }
            }
          }
        }
        return components;
      }
    };
    exports.ParsingComponents = ParsingComponents;
    var ParsingResult = class {
      constructor(reference2, index, text, start2, end2) {
        this.reference = reference2;
        this.refDate = reference2.instant;
        this.index = index;
        this.text = text;
        this.start = start2 || new ParsingComponents(reference2);
        this.end = end2;
      }
      clone() {
        const result = new ParsingResult(this.reference, this.index, this.text);
        result.start = this.start ? this.start.clone() : null;
        result.end = this.end ? this.end.clone() : null;
        return result;
      }
      date() {
        return this.start.date();
      }
      toString() {
        return `[ParsingResult {index: ${this.index}, text: '${this.text}', ...}]`;
      }
    };
    exports.ParsingResult = ParsingResult;
  }
});

// node_modules/chrono-node/dist/common/parsers/AbstractParserWithWordBoundary.js
var require_AbstractParserWithWordBoundary = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/AbstractParserWithWordBoundary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractParserWithWordBoundaryChecking = void 0;
    var AbstractParserWithWordBoundaryChecking = class {
      constructor() {
        this.cachedInnerPattern = null;
        this.cachedPattern = null;
      }
      patternLeftBoundary() {
        return `(\\W|^)`;
      }
      pattern(context) {
        const innerPattern = this.innerPattern(context);
        if (innerPattern == this.cachedInnerPattern) {
          return this.cachedPattern;
        }
        this.cachedPattern = new RegExp(`${this.patternLeftBoundary()}${innerPattern.source}`, innerPattern.flags);
        this.cachedInnerPattern = innerPattern;
        return this.cachedPattern;
      }
      extract(context, match) {
        var _a;
        const header = (_a = match[1]) !== null && _a !== void 0 ? _a : "";
        match.index = match.index + header.length;
        match[0] = match[0].substring(header.length);
        for (let i = 2; i < match.length; i++) {
          match[i - 1] = match[i];
        }
        return this.innerExtract(context, match);
      }
    };
    exports.AbstractParserWithWordBoundaryChecking = AbstractParserWithWordBoundaryChecking;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitWithinFormatParser.js
var require_ENTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN_WITH_PREFIX = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var PATTERN_WITHOUT_PREFIX = new RegExp(`(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var ENTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return context.option.forwardDate ? PATTERN_WITHOUT_PREFIX : PATTERN_WITH_PREFIX;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = ENTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameLittleEndianParser.js
var require_ENMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants();
    var constants_2 = require_constants();
    var constants_3 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s{0,3})?(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:to|\\-|\\\u2013|until|through|till)?\\s{0,3}(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s{0,3}(?:of)?\\s{0,3})(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s{0,3})(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var ENMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = ENMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameMiddleEndianParser.js
var require_ENMonthNameMiddleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameMiddleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants();
    var constants_2 = require_constants();
    var constants_3 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:-|/|\\s*,?\\s*)(${constants_2.ORDINAL_NUMBER_PATTERN})(?!\\s*(?:am|pm))\\s*(?:(?:to|\\-)\\s*(${constants_2.ORDINAL_NUMBER_PATTERN})\\s*)?(?:(?:-|/|\\s*,?\\s*)(${constants_3.YEAR_PATTERN}))?(?=\\W|$)(?!\\:\\d)`, "i");
    var MONTH_NAME_GROUP = 1;
    var DATE_GROUP = 2;
    var DATE_TO_GROUP = 3;
    var YEAR_GROUP = 4;
    var ENMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_2.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          return null;
        }
        const components = context.createParsingComponents({
          day,
          month
        });
        if (match[YEAR_GROUP]) {
          const year = constants_3.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          components.imply("year", year);
        }
        if (!match[DATE_TO_GROUP]) {
          return components;
        }
        const endDate = constants_2.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
        const result = context.createParsingResult(match.index, match[0]);
        result.start = components;
        result.end = components.clone();
        result.end.assign("day", endDate);
        return result;
      }
    };
    exports.default = ENMonthNameMiddleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameParser.js
var require_ENMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`((?:in)\\s*)?(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
    var PREFIX_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var YEAR_GROUP = 3;
    var ENMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const monthName = match[MONTH_NAME_GROUP].toLowerCase();
        if (match[0].length <= 3 && !constants_1.FULL_MONTH_NAME_DICTIONARY[monthName]) {
          return null;
        }
        const result = context.createParsingResult(match.index + (match[PREFIX_GROUP] || "").length, match.index + match[0].length);
        result.start.imply("day", 1);
        const month = constants_1.MONTH_DICTIONARY[monthName];
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, 1, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = ENMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualYearMonthDayParser.js
var require_ENCasualYearMonthDayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualYearMonthDayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var MONTH_NUMBER_GROUP = 3;
    var DATE_NUMBER_GROUP = 4;
    var ENCasualYearMonthDayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        if (month < 1 || month > 12) {
          return null;
        }
        const year = parseInt(match[YEAR_NUMBER_GROUP]);
        const day = parseInt(match[DATE_NUMBER_GROUP]);
        return {
          day,
          month,
          year
        };
      }
    };
    exports.default = ENCasualYearMonthDayParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENSlashMonthFormatParser.js
var require_ENSlashMonthFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENSlashMonthFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
    var MONTH_GROUP = 1;
    var YEAR_GROUP = 2;
    var ENSlashMonthFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const year = parseInt(match[YEAR_GROUP]);
        const month = parseInt(match[MONTH_GROUP]);
        return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year);
      }
    };
    exports.default = ENSlashMonthFormatParser;
  }
});

// node_modules/chrono-node/dist/common/parsers/AbstractTimeExpressionParser.js
var require_AbstractTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/AbstractTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractTimeExpressionParser = void 0;
    var index_1 = require_dist();
    function primaryTimePattern(leftBoundary, primaryPrefix, primarySuffix, flags) {
      return new RegExp(`${leftBoundary}${primaryPrefix}(\\d{1,4})(?:(?:\\.|:|\uFF1A)(\\d{1,2})(?:(?::|\uFF1A)(\\d{2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${primarySuffix}`, flags);
    }
    function followingTimePatten(followingPhase, followingSuffix) {
      return new RegExp(`^(${followingPhase})(\\d{1,4})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${followingSuffix}`, "i");
    }
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var MILLI_SECOND_GROUP = 5;
    var AM_PM_HOUR_GROUP = 6;
    var AbstractTimeExpressionParser = class {
      constructor(strictMode = false) {
        this.cachedPrimaryPrefix = null;
        this.cachedPrimarySuffix = null;
        this.cachedPrimaryTimePattern = null;
        this.cachedFollowingPhase = null;
        this.cachedFollowingSuffix = null;
        this.cachedFollowingTimePatten = null;
        this.strictMode = strictMode;
      }
      patternFlags() {
        return "i";
      }
      primaryPatternLeftBoundary() {
        return `(^|\\s|T|\\b)`;
      }
      primarySuffix() {
        return `(?=\\W|$)`;
      }
      followingSuffix() {
        return `(?=\\W|$)`;
      }
      pattern(context) {
        return this.getPrimaryTimePatternThroughCache();
      }
      extract(context, match) {
        const startComponents = this.extractPrimaryTimeComponents(context, match);
        if (!startComponents) {
          match.index += match[0].length;
          return null;
        }
        const index = match.index + match[1].length;
        const text = match[0].substring(match[1].length);
        const result = context.createParsingResult(index, text, startComponents);
        match.index += match[0].length;
        const remainingText = context.text.substring(match.index);
        const followingPattern = this.getFollowingTimePatternThroughCache();
        const followingMatch = followingPattern.exec(remainingText);
        if (text.match(/^\d{3,4}/) && followingMatch && followingMatch[0].match(/^\s*([+-])\s*\d{2,4}$/)) {
          return null;
        }
        if (!followingMatch || followingMatch[0].match(/^\s*([+-])\s*\d{3,4}$/)) {
          return this.checkAndReturnWithoutFollowingPattern(result);
        }
        result.end = this.extractFollowingTimeComponents(context, followingMatch, result);
        if (result.end) {
          result.text += followingMatch[0];
        }
        return this.checkAndReturnWithFollowingPattern(result);
      }
      extractPrimaryTimeComponents(context, match, strict = false) {
        const components = context.createParsingComponents();
        let minute = 0;
        let meridiem = null;
        let hour = parseInt(match[HOUR_GROUP]);
        if (hour > 100) {
          if (this.strictMode || match[MINUTE_GROUP] != null) {
            return null;
          }
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (hour > 24) {
          return null;
        }
        if (match[MINUTE_GROUP] != null) {
          if (match[MINUTE_GROUP].length == 1 && !match[AM_PM_HOUR_GROUP]) {
            return null;
          }
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
        }
        components.assign("hour", hour);
        components.assign("minute", minute);
        if (meridiem !== null) {
          components.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            components.imply("meridiem", index_1.Meridiem.AM);
          } else {
            components.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[MILLI_SECOND_GROUP] != null) {
          const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
          if (millisecond >= 1e3)
            return null;
          components.assign("millisecond", millisecond);
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          components.assign("second", second);
        }
        return components;
      }
      extractFollowingTimeComponents(context, match, result) {
        const components = context.createParsingComponents();
        if (match[MILLI_SECOND_GROUP] != null) {
          const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
          if (millisecond >= 1e3)
            return null;
          components.assign("millisecond", millisecond);
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          components.assign("second", second);
        }
        let hour = parseInt(match[HOUR_GROUP]);
        let minute = 0;
        let meridiem = -1;
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12) {
            return null;
          }
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
              if (!components.isCertain("day")) {
                components.imply("day", components.get("day") + 1);
              }
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == index_1.Meridiem.AM) {
              result.start.imply("meridiem", index_1.Meridiem.AM);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", index_1.Meridiem.PM);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        }
        components.assign("hour", hour);
        components.assign("minute", minute);
        if (meridiem >= 0) {
          components.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("hour") > 12;
          if (startAtPM) {
            if (result.start.get("hour") - 12 > hour) {
              components.imply("meridiem", index_1.Meridiem.AM);
            } else if (hour <= 12) {
              components.assign("hour", hour + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            }
          } else if (hour > 12) {
            components.imply("meridiem", index_1.Meridiem.PM);
          } else if (hour <= 12) {
            components.imply("meridiem", index_1.Meridiem.AM);
          }
        }
        if (components.date().getTime() < result.start.date().getTime()) {
          components.imply("day", components.get("day") + 1);
        }
        return components;
      }
      checkAndReturnWithoutFollowingPattern(result) {
        if (result.text.match(/^\d$/)) {
          return null;
        }
        if (result.text.match(/^\d\d\d+$/)) {
          return null;
        }
        if (result.text.match(/\d[apAP]$/)) {
          return null;
        }
        const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)$/);
        if (endingWithNumbers) {
          const endingNumbers = endingWithNumbers[1];
          if (this.strictMode) {
            return null;
          }
          if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
            return null;
          }
          const endingNumberVal = parseInt(endingNumbers);
          if (endingNumberVal > 24) {
            return null;
          }
        }
        return result;
      }
      checkAndReturnWithFollowingPattern(result) {
        if (result.text.match(/^\d+-\d+$/)) {
          return null;
        }
        const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)\s*-\s*(\d[\d.]+)$/);
        if (endingWithNumbers) {
          if (this.strictMode) {
            return null;
          }
          const startingNumbers = endingWithNumbers[1];
          const endingNumbers = endingWithNumbers[2];
          if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
            return null;
          }
          const endingNumberVal = parseInt(endingNumbers);
          const startingNumberVal = parseInt(startingNumbers);
          if (endingNumberVal > 24 || startingNumberVal > 24) {
            return null;
          }
        }
        return result;
      }
      getPrimaryTimePatternThroughCache() {
        const primaryPrefix = this.primaryPrefix();
        const primarySuffix = this.primarySuffix();
        if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {
          return this.cachedPrimaryTimePattern;
        }
        this.cachedPrimaryTimePattern = primaryTimePattern(this.primaryPatternLeftBoundary(), primaryPrefix, primarySuffix, this.patternFlags());
        this.cachedPrimaryPrefix = primaryPrefix;
        this.cachedPrimarySuffix = primarySuffix;
        return this.cachedPrimaryTimePattern;
      }
      getFollowingTimePatternThroughCache() {
        const followingPhase = this.followingPhase();
        const followingSuffix = this.followingSuffix();
        if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {
          return this.cachedFollowingTimePatten;
        }
        this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);
        this.cachedFollowingPhase = followingPhase;
        this.cachedFollowingSuffix = followingSuffix;
        return this.cachedFollowingTimePatten;
      }
    };
    exports.AbstractTimeExpressionParser = AbstractTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeExpressionParser.js
var require_ENTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var ENTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      constructor(strictMode) {
        super(strictMode);
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|to|\\?)\\s*";
      }
      primaryPrefix() {
        return "(?:(?:at|from)\\s*)??";
      }
      primarySuffix() {
        return "(?:\\s*(?:o\\W*clock|at\\s*night|in\\s*the\\s*(?:morning|afternoon)))?(?!/)(?=\\W|$)";
      }
      extractPrimaryTimeComponents(context, match) {
        const components = super.extractPrimaryTimeComponents(context, match);
        if (components) {
          if (match[0].endsWith("night")) {
            const hour = components.get("hour");
            if (hour >= 6 && hour < 12) {
              components.assign("hour", components.get("hour") + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            } else if (hour < 6) {
              components.assign("meridiem", index_1.Meridiem.AM);
            }
          }
          if (match[0].endsWith("afternoon")) {
            components.assign("meridiem", index_1.Meridiem.PM);
            const hour = components.get("hour");
            if (hour >= 0 && hour <= 6) {
              components.assign("hour", components.get("hour") + 12);
            }
          }
          if (match[0].endsWith("morning")) {
            components.assign("meridiem", index_1.Meridiem.AM);
            const hour = components.get("hour");
            if (hour < 12) {
              components.assign("hour", components.get("hour"));
            }
          }
        }
        return components;
      }
    };
    exports.default = ENTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/utils/timeunits.js
var require_timeunits = __commonJS({
  "node_modules/chrono-node/dist/utils/timeunits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addImpliedTimeUnits = exports.reverseTimeUnits = void 0;
    function reverseTimeUnits(timeUnits) {
      const reversed = {};
      for (const key in timeUnits) {
        reversed[key] = -timeUnits[key];
      }
      return reversed;
    }
    exports.reverseTimeUnits = reverseTimeUnits;
    function addImpliedTimeUnits(components, timeUnits) {
      const output = components.clone();
      let date = components.dayjs();
      for (const key in timeUnits) {
        date = date.add(timeUnits[key], key);
      }
      if ("day" in timeUnits || "d" in timeUnits || "week" in timeUnits || "month" in timeUnits || "year" in timeUnits) {
        output.imply("day", date.date());
        output.imply("month", date.month() + 1);
        output.imply("year", date.year());
      }
      if ("second" in timeUnits || "minute" in timeUnits || "hour" in timeUnits) {
        output.imply("second", date.second());
        output.imply("minute", date.minute());
        output.imply("hour", date.hour());
      }
      return output;
    }
    exports.addImpliedTimeUnits = addImpliedTimeUnits;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitAgoFormatParser.js
var require_ENTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=(?:\\W|$))`, "i");
    var STRICT_PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}ago(?=(?:\\W|$))`, "i");
    var ENTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = ENTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitLaterFormatParser.js
var require_ENTimeUnitLaterFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitLaterFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}(?:later|after|from now|henceforth|forward|out)(?=(?:\\W|$))`, "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|from now)(?=(?:\\W|$))", "i");
    var GROUP_NUM_TIMEUNITS = 1;
    var ENTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const fragments = constants_1.parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, fragments);
      }
    };
    exports.default = ENTimeUnitLaterFormatParser;
  }
});

// node_modules/chrono-node/dist/common/abstractRefiners.js
var require_abstractRefiners = __commonJS({
  "node_modules/chrono-node/dist/common/abstractRefiners.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MergingRefiner = exports.Filter = void 0;
    var Filter = class {
      refine(context, results) {
        return results.filter((r) => this.isValid(context, r));
      }
    };
    exports.Filter = Filter;
    var MergingRefiner = class {
      refine(context, results) {
        if (results.length < 2) {
          return results;
        }
        const mergedResults = [];
        let curResult = results[0];
        let nextResult = null;
        for (let i = 1; i < results.length; i++) {
          nextResult = results[i];
          const textBetween = context.text.substring(curResult.index + curResult.text.length, nextResult.index);
          if (!this.shouldMergeResults(textBetween, curResult, nextResult, context)) {
            mergedResults.push(curResult);
            curResult = nextResult;
          } else {
            const left2 = curResult;
            const right2 = nextResult;
            const mergedResult = this.mergeResults(textBetween, left2, right2, context);
            context.debug(() => {
              console.log(`${this.constructor.name} merged ${left2} and ${right2} into ${mergedResult}`);
            });
            curResult = mergedResult;
          }
        }
        if (curResult != null) {
          mergedResults.push(curResult);
        }
        return mergedResults;
      }
    };
    exports.MergingRefiner = MergingRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/AbstractMergeDateRangeRefiner.js
var require_AbstractMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/AbstractMergeDateRangeRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var AbstractMergeDateRangeRefiner = class extends abstractRefiners_1.MergingRefiner {
      shouldMergeResults(textBetween, currentResult, nextResult) {
        return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;
      }
      mergeResults(textBetween, fromResult, toResult) {
        if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {
          toResult.start.getCertainComponents().forEach((key) => {
            if (!fromResult.start.isCertain(key)) {
              fromResult.start.assign(key, toResult.start.get(key));
            }
          });
          fromResult.start.getCertainComponents().forEach((key) => {
            if (!toResult.start.isCertain(key)) {
              toResult.start.assign(key, fromResult.start.get(key));
            }
          });
        }
        if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {
          let fromMoment = fromResult.start.dayjs();
          let toMoment = toResult.start.dayjs();
          if (fromResult.start.isOnlyWeekdayComponent() && fromMoment.add(-7, "days").isBefore(toMoment)) {
            fromMoment = fromMoment.add(-7, "days");
            fromResult.start.imply("day", fromMoment.date());
            fromResult.start.imply("month", fromMoment.month() + 1);
            fromResult.start.imply("year", fromMoment.year());
          } else if (toResult.start.isOnlyWeekdayComponent() && toMoment.add(7, "days").isAfter(fromMoment)) {
            toMoment = toMoment.add(7, "days");
            toResult.start.imply("day", toMoment.date());
            toResult.start.imply("month", toMoment.month() + 1);
            toResult.start.imply("year", toMoment.year());
          } else {
            [toResult, fromResult] = [fromResult, toResult];
          }
        }
        const result = fromResult.clone();
        result.start = fromResult.start;
        result.end = toResult.start;
        result.index = Math.min(fromResult.index, toResult.index);
        if (fromResult.index < toResult.index) {
          result.text = fromResult.text + textBetween + toResult.text;
        } else {
          result.text = toResult.text + textBetween + fromResult.text;
        }
        return result;
      }
    };
    exports.default = AbstractMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateRangeRefiner.js
var require_ENMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var ENMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(to|-)\s*$/i;
      }
    };
    exports.default = ENMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/calculation/mergingCalculation.js
var require_mergingCalculation = __commonJS({
  "node_modules/chrono-node/dist/calculation/mergingCalculation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeDateTimeComponent = exports.mergeDateTimeResult = void 0;
    var index_1 = require_dist();
    function mergeDateTimeResult(dateResult, timeResult) {
      const result = dateResult.clone();
      const beginDate = dateResult.start;
      const beginTime = timeResult.start;
      result.start = mergeDateTimeComponent(beginDate, beginTime);
      if (dateResult.end != null || timeResult.end != null) {
        const endDate = dateResult.end == null ? dateResult.start : dateResult.end;
        const endTime = timeResult.end == null ? timeResult.start : timeResult.end;
        const endDateTime = mergeDateTimeComponent(endDate, endTime);
        if (dateResult.end == null && endDateTime.date().getTime() < result.start.date().getTime()) {
          if (endDateTime.isCertain("day")) {
            endDateTime.assign("day", endDateTime.get("day") + 1);
          } else {
            endDateTime.imply("day", endDateTime.get("day") + 1);
          }
        }
        result.end = endDateTime;
      }
      return result;
    }
    exports.mergeDateTimeResult = mergeDateTimeResult;
    function mergeDateTimeComponent(dateComponent, timeComponent) {
      const dateTimeComponent = dateComponent.clone();
      if (timeComponent.isCertain("hour")) {
        dateTimeComponent.assign("hour", timeComponent.get("hour"));
        dateTimeComponent.assign("minute", timeComponent.get("minute"));
        if (timeComponent.isCertain("second")) {
          dateTimeComponent.assign("second", timeComponent.get("second"));
          if (timeComponent.isCertain("millisecond")) {
            dateTimeComponent.assign("millisecond", timeComponent.get("millisecond"));
          } else {
            dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
          }
        } else {
          dateTimeComponent.imply("second", timeComponent.get("second"));
          dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
        }
      } else {
        dateTimeComponent.imply("hour", timeComponent.get("hour"));
        dateTimeComponent.imply("minute", timeComponent.get("minute"));
        dateTimeComponent.imply("second", timeComponent.get("second"));
        dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
      }
      if (timeComponent.isCertain("timezoneOffset")) {
        dateTimeComponent.assign("timezoneOffset", timeComponent.get("timezoneOffset"));
      }
      if (timeComponent.isCertain("meridiem")) {
        dateTimeComponent.assign("meridiem", timeComponent.get("meridiem"));
      } else if (timeComponent.get("meridiem") != null && dateTimeComponent.get("meridiem") == null) {
        dateTimeComponent.imply("meridiem", timeComponent.get("meridiem"));
      }
      if (dateTimeComponent.get("meridiem") == index_1.Meridiem.PM && dateTimeComponent.get("hour") < 12) {
        if (timeComponent.isCertain("hour")) {
          dateTimeComponent.assign("hour", dateTimeComponent.get("hour") + 12);
        } else {
          dateTimeComponent.imply("hour", dateTimeComponent.get("hour") + 12);
        }
      }
      return dateTimeComponent;
    }
    exports.mergeDateTimeComponent = mergeDateTimeComponent;
  }
});

// node_modules/chrono-node/dist/common/refiners/AbstractMergeDateTimeRefiner.js
var require_AbstractMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/AbstractMergeDateTimeRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var mergingCalculation_1 = require_mergingCalculation();
    var ENMergeDateTimeRefiner = class extends abstractRefiners_1.MergingRefiner {
      shouldMergeResults(textBetween, currentResult, nextResult) {
        return (currentResult.start.isOnlyDate() && nextResult.start.isOnlyTime() || nextResult.start.isOnlyDate() && currentResult.start.isOnlyTime()) && textBetween.match(this.patternBetween()) != null;
      }
      mergeResults(textBetween, currentResult, nextResult) {
        const result = currentResult.start.isOnlyDate() ? mergingCalculation_1.mergeDateTimeResult(currentResult, nextResult) : mergingCalculation_1.mergeDateTimeResult(nextResult, currentResult);
        result.index = currentResult.index;
        result.text = currentResult.text + textBetween + nextResult.text;
        return result;
      }
    };
    exports.default = ENMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateTimeRefiner.js
var require_ENMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var ENMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|at|after|before|on|of|,|-)?\\s*$");
      }
    };
    exports.default = ENMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ExtractTimezoneAbbrRefiner.js
var require_ExtractTimezoneAbbrRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ExtractTimezoneAbbrRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TIMEZONE_NAME_PATTERN = new RegExp("^\\s*,?\\s*\\(?([A-Z]{2,4})\\)?(?=\\W|$)", "i");
    var DEFAULT_TIMEZONE_ABBR_MAP = {
      ACDT: 630,
      ACST: 570,
      ADT: -180,
      AEDT: 660,
      AEST: 600,
      AFT: 270,
      AKDT: -480,
      AKST: -540,
      ALMT: 360,
      AMST: -180,
      AMT: -240,
      ANAST: 720,
      ANAT: 720,
      AQTT: 300,
      ART: -180,
      AST: -240,
      AWDT: 540,
      AWST: 480,
      AZOST: 0,
      AZOT: -60,
      AZST: 300,
      AZT: 240,
      BNT: 480,
      BOT: -240,
      BRST: -120,
      BRT: -180,
      BST: 60,
      BTT: 360,
      CAST: 480,
      CAT: 120,
      CCT: 390,
      CDT: -300,
      CEST: 120,
      CET: 60,
      CHADT: 825,
      CHAST: 765,
      CKT: -600,
      CLST: -180,
      CLT: -240,
      COT: -300,
      CST: -360,
      CVT: -60,
      CXT: 420,
      ChST: 600,
      DAVT: 420,
      EASST: -300,
      EAST: -360,
      EAT: 180,
      ECT: -300,
      EDT: -240,
      EEST: 180,
      EET: 120,
      EGST: 0,
      EGT: -60,
      EST: -300,
      ET: -300,
      FJST: 780,
      FJT: 720,
      FKST: -180,
      FKT: -240,
      FNT: -120,
      GALT: -360,
      GAMT: -540,
      GET: 240,
      GFT: -180,
      GILT: 720,
      GMT: 0,
      GST: 240,
      GYT: -240,
      HAA: -180,
      HAC: -300,
      HADT: -540,
      HAE: -240,
      HAP: -420,
      HAR: -360,
      HAST: -600,
      HAT: -90,
      HAY: -480,
      HKT: 480,
      HLV: -210,
      HNA: -240,
      HNC: -360,
      HNE: -300,
      HNP: -480,
      HNR: -420,
      HNT: -150,
      HNY: -540,
      HOVT: 420,
      ICT: 420,
      IDT: 180,
      IOT: 360,
      IRDT: 270,
      IRKST: 540,
      IRKT: 540,
      IRST: 210,
      IST: 330,
      JST: 540,
      KGT: 360,
      KRAST: 480,
      KRAT: 480,
      KST: 540,
      KUYT: 240,
      LHDT: 660,
      LHST: 630,
      LINT: 840,
      MAGST: 720,
      MAGT: 720,
      MART: -510,
      MAWT: 300,
      MDT: -360,
      MESZ: 120,
      MEZ: 60,
      MHT: 720,
      MMT: 390,
      MSD: 240,
      MSK: 240,
      MST: -420,
      MUT: 240,
      MVT: 300,
      MYT: 480,
      NCT: 660,
      NDT: -90,
      NFT: 690,
      NOVST: 420,
      NOVT: 360,
      NPT: 345,
      NST: -150,
      NUT: -660,
      NZDT: 780,
      NZST: 720,
      OMSST: 420,
      OMST: 420,
      PDT: -420,
      PET: -300,
      PETST: 720,
      PETT: 720,
      PGT: 600,
      PHOT: 780,
      PHT: 480,
      PKT: 300,
      PMDT: -120,
      PMST: -180,
      PONT: 660,
      PST: -480,
      PT: -480,
      PWT: 540,
      PYST: -180,
      PYT: -240,
      RET: 240,
      SAMT: 240,
      SAST: 120,
      SBT: 660,
      SCT: 240,
      SGT: 480,
      SRT: -180,
      SST: -660,
      TAHT: -600,
      TFT: 300,
      TJT: 300,
      TKT: 780,
      TLT: 540,
      TMT: 300,
      TVT: 720,
      ULAT: 480,
      UTC: 0,
      UYST: -120,
      UYT: -180,
      UZT: 300,
      VET: -210,
      VLAST: 660,
      VLAT: 660,
      VUT: 660,
      WAST: 120,
      WAT: 60,
      WEST: 60,
      WESZ: 60,
      WET: 0,
      WEZ: 0,
      WFT: 720,
      WGST: -120,
      WGT: -180,
      WIB: 420,
      WIT: 540,
      WITA: 480,
      WST: 780,
      WT: 0,
      YAKST: 600,
      YAKT: 600,
      YAPT: 600,
      YEKST: 360,
      YEKT: 360
    };
    var ExtractTimezoneAbbrRefiner = class {
      constructor(timezoneOverrides) {
        this.timezone = Object.assign(Object.assign({}, DEFAULT_TIMEZONE_ABBR_MAP), timezoneOverrides);
      }
      refine(context, results) {
        var _a;
        const timezoneOverrides = (_a = context.option.timezones) !== null && _a !== void 0 ? _a : {};
        results.forEach((result) => {
          var _a2, _b;
          const suffix = context.text.substring(result.index + result.text.length);
          const match = TIMEZONE_NAME_PATTERN.exec(suffix);
          if (!match) {
            return;
          }
          const timezoneAbbr = match[1].toUpperCase();
          const extractedTimezoneOffset = (_b = (_a2 = timezoneOverrides[timezoneAbbr]) !== null && _a2 !== void 0 ? _a2 : this.timezone[timezoneAbbr]) !== null && _b !== void 0 ? _b : null;
          if (extractedTimezoneOffset === null) {
            return;
          }
          context.debug(() => {
            console.log(`Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result.start}`);
          });
          const currentTimezoneOffset = result.start.get("timezoneOffset");
          if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {
            if (result.start.isCertain("timezoneOffset")) {
              return;
            }
            if (timezoneAbbr != match[1]) {
              return;
            }
          }
          if (result.start.isOnlyDate()) {
            if (timezoneAbbr != match[1]) {
              return;
            }
          }
          result.text += match[0];
          if (!result.start.isCertain("timezoneOffset")) {
            result.start.assign("timezoneOffset", extractedTimezoneOffset);
          }
          if (result.end != null && !result.end.isCertain("timezoneOffset")) {
            result.end.assign("timezoneOffset", extractedTimezoneOffset);
          }
        });
        return results;
      }
    };
    exports.default = ExtractTimezoneAbbrRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ExtractTimezoneOffsetRefiner.js
var require_ExtractTimezoneOffsetRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ExtractTimezoneOffsetRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TIMEZONE_OFFSET_PATTERN = new RegExp("^\\s*(?:\\(?(?:GMT|UTC)\\s?)?([+-])(\\d{1,2})(?::?(\\d{2}))?\\)?", "i");
    var TIMEZONE_OFFSET_SIGN_GROUP = 1;
    var TIMEZONE_OFFSET_HOUR_OFFSET_GROUP = 2;
    var TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP = 3;
    var ExtractTimezoneOffsetRefiner = class {
      refine(context, results) {
        results.forEach(function(result) {
          if (result.start.isCertain("timezoneOffset")) {
            return;
          }
          const suffix = context.text.substring(result.index + result.text.length);
          const match = TIMEZONE_OFFSET_PATTERN.exec(suffix);
          if (!match) {
            return;
          }
          context.debug(() => {
            console.log(`Extracting timezone: '${match[0]}' into : ${result}`);
          });
          const hourOffset = parseInt(match[TIMEZONE_OFFSET_HOUR_OFFSET_GROUP]);
          const minuteOffset = parseInt(match[TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP] || "0");
          let timezoneOffset = hourOffset * 60 + minuteOffset;
          if (timezoneOffset > 14 * 60) {
            return;
          }
          if (match[TIMEZONE_OFFSET_SIGN_GROUP] === "-") {
            timezoneOffset = -timezoneOffset;
          }
          if (result.end != null) {
            result.end.assign("timezoneOffset", timezoneOffset);
          }
          result.start.assign("timezoneOffset", timezoneOffset);
          result.text += match[0];
        });
        return results;
      }
    };
    exports.default = ExtractTimezoneOffsetRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/OverlapRemovalRefiner.js
var require_OverlapRemovalRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/OverlapRemovalRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OverlapRemovalRefiner = class {
      refine(context, results) {
        if (results.length < 2) {
          return results;
        }
        const filteredResults = [];
        let prevResult = results[0];
        for (let i = 1; i < results.length; i++) {
          const result = results[i];
          if (result.index < prevResult.index + prevResult.text.length) {
            if (result.text.length > prevResult.text.length) {
              prevResult = result;
            }
          } else {
            filteredResults.push(prevResult);
            prevResult = result;
          }
        }
        if (prevResult != null) {
          filteredResults.push(prevResult);
        }
        return filteredResults;
      }
    };
    exports.default = OverlapRemovalRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ForwardDateRefiner.js
var require_ForwardDateRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ForwardDateRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var ForwardDateRefiner = class {
      refine(context, results) {
        if (!context.option.forwardDate) {
          return results;
        }
        results.forEach(function(result) {
          let refMoment = dayjs_1.default(context.refDate);
          if (result.start.isOnlyDayMonthComponent() && refMoment.isAfter(result.start.dayjs())) {
            for (let i = 0; i < 3 && refMoment.isAfter(result.start.dayjs()); i++) {
              result.start.imply("year", result.start.get("year") + 1);
              context.debug(() => {
                console.log(`Forward yearly adjusted for ${result} (${result.start})`);
              });
              if (result.end && !result.end.isCertain("year")) {
                result.end.imply("year", result.end.get("year") + 1);
                context.debug(() => {
                  console.log(`Forward yearly adjusted for ${result} (${result.end})`);
                });
              }
            }
          }
          if (result.start.isOnlyWeekdayComponent() && refMoment.isAfter(result.start.dayjs())) {
            if (refMoment.day() >= result.start.get("weekday")) {
              refMoment = refMoment.day(result.start.get("weekday") + 7);
            } else {
              refMoment = refMoment.day(result.start.get("weekday"));
            }
            result.start.imply("day", refMoment.date());
            result.start.imply("month", refMoment.month() + 1);
            result.start.imply("year", refMoment.year());
            context.debug(() => {
              console.log(`Forward weekly adjusted for ${result} (${result.start})`);
            });
            if (result.end && result.end.isOnlyWeekdayComponent()) {
              if (refMoment.day() > result.end.get("weekday")) {
                refMoment = refMoment.day(result.end.get("weekday") + 7);
              } else {
                refMoment = refMoment.day(result.end.get("weekday"));
              }
              result.end.imply("day", refMoment.date());
              result.end.imply("month", refMoment.month() + 1);
              result.end.imply("year", refMoment.year());
              context.debug(() => {
                console.log(`Forward weekly adjusted for ${result} (${result.end})`);
              });
            }
          }
        });
        return results;
      }
    };
    exports.default = ForwardDateRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/UnlikelyFormatFilter.js
var require_UnlikelyFormatFilter = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/UnlikelyFormatFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var UnlikelyFormatFilter = class extends abstractRefiners_1.Filter {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      isValid(context, result) {
        if (result.text.replace(" ", "").match(/^\d*(\.\d*)?$/)) {
          context.debug(() => {
            console.log(`Removing unlikely result '${result.text}'`);
          });
          return false;
        }
        if (!result.start.isValidDate()) {
          context.debug(() => {
            console.log(`Removing invalid result: ${result} (${result.start})`);
          });
          return false;
        }
        if (result.end && !result.end.isValidDate()) {
          context.debug(() => {
            console.log(`Removing invalid result: ${result} (${result.end})`);
          });
          return false;
        }
        if (this.strictMode) {
          return this.isStrictModeValid(context, result);
        }
        return true;
      }
      isStrictModeValid(context, result) {
        if (result.start.isOnlyWeekdayComponent()) {
          context.debug(() => {
            console.log(`(Strict) Removing weekday only component: ${result} (${result.end})`);
          });
          return false;
        }
        if (result.start.isOnlyTime() && (!result.start.isCertain("hour") || !result.start.isCertain("minute"))) {
          context.debug(() => {
            console.log(`(Strict) Removing uncertain time component: ${result} (${result.end})`);
          });
          return false;
        }
        return true;
      }
    };
    exports.default = UnlikelyFormatFilter;
  }
});

// node_modules/chrono-node/dist/common/parsers/ISOFormatParser.js
var require_ISOFormatParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/ISOFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]{4})\\-([0-9]{1,2})\\-([0-9]{1,2})(?:T([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2})(?:\\.(\\d{1,4}))?)?(?:Z|([+-]\\d{2}):?(\\d{2})?)?)?(?=\\W|$)", "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NUMBER_GROUP = 2;
    var DATE_NUMBER_GROUP = 3;
    var HOUR_NUMBER_GROUP = 4;
    var MINUTE_NUMBER_GROUP = 5;
    var SECOND_NUMBER_GROUP = 6;
    var MILLISECOND_NUMBER_GROUP = 7;
    var TZD_HOUR_OFFSET_GROUP = 8;
    var TZD_MINUTE_OFFSET_GROUP = 9;
    var ISOFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const components = {};
        components["year"] = parseInt(match[YEAR_NUMBER_GROUP]);
        components["month"] = parseInt(match[MONTH_NUMBER_GROUP]);
        components["day"] = parseInt(match[DATE_NUMBER_GROUP]);
        if (match[HOUR_NUMBER_GROUP] != null) {
          components["hour"] = parseInt(match[HOUR_NUMBER_GROUP]);
          components["minute"] = parseInt(match[MINUTE_NUMBER_GROUP]);
          if (match[SECOND_NUMBER_GROUP] != null) {
            components["second"] = parseInt(match[SECOND_NUMBER_GROUP]);
          }
          if (match[MILLISECOND_NUMBER_GROUP] != null) {
            components["millisecond"] = parseInt(match[MILLISECOND_NUMBER_GROUP]);
          }
          if (match[TZD_HOUR_OFFSET_GROUP] == null) {
            components["timezoneOffset"] = 0;
          } else {
            const hourOffset = parseInt(match[TZD_HOUR_OFFSET_GROUP]);
            let minuteOffset = 0;
            if (match[TZD_MINUTE_OFFSET_GROUP] != null) {
              minuteOffset = parseInt(match[TZD_MINUTE_OFFSET_GROUP]);
            }
            let offset2 = hourOffset * 60;
            if (offset2 < 0) {
              offset2 -= minuteOffset;
            } else {
              offset2 += minuteOffset;
            }
            components["timezoneOffset"] = offset2;
          }
        }
        return components;
      }
    };
    exports.default = ISOFormatParser;
  }
});

// node_modules/chrono-node/dist/common/refiners/MergeWeekdayComponentRefiner.js
var require_MergeWeekdayComponentRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/MergeWeekdayComponentRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var MergeWeekdayComponentRefiner = class extends abstractRefiners_1.MergingRefiner {
      mergeResults(textBetween, currentResult, nextResult) {
        const newResult = nextResult.clone();
        newResult.index = currentResult.index;
        newResult.text = currentResult.text + textBetween + newResult.text;
        newResult.start.assign("weekday", currentResult.start.get("weekday"));
        if (newResult.end) {
          newResult.end.assign("weekday", currentResult.start.get("weekday"));
        }
        return newResult;
      }
      shouldMergeResults(textBetween, currentResult, nextResult) {
        const weekdayThenNormalDate = currentResult.start.isOnlyWeekdayComponent() && !currentResult.start.isCertain("hour") && nextResult.start.isCertain("day");
        return weekdayThenNormalDate && textBetween.match(/^,?\s*$/) != null;
      }
    };
    exports.default = MergeWeekdayComponentRefiner;
  }
});

// node_modules/chrono-node/dist/configurations.js
var require_configurations = __commonJS({
  "node_modules/chrono-node/dist/configurations.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.includeCommonConfiguration = void 0;
    var ExtractTimezoneAbbrRefiner_1 = __importDefault(require_ExtractTimezoneAbbrRefiner());
    var ExtractTimezoneOffsetRefiner_1 = __importDefault(require_ExtractTimezoneOffsetRefiner());
    var OverlapRemovalRefiner_1 = __importDefault(require_OverlapRemovalRefiner());
    var ForwardDateRefiner_1 = __importDefault(require_ForwardDateRefiner());
    var UnlikelyFormatFilter_1 = __importDefault(require_UnlikelyFormatFilter());
    var ISOFormatParser_1 = __importDefault(require_ISOFormatParser());
    var MergeWeekdayComponentRefiner_1 = __importDefault(require_MergeWeekdayComponentRefiner());
    function includeCommonConfiguration(configuration, strictMode = false) {
      configuration.parsers.unshift(new ISOFormatParser_1.default());
      configuration.refiners.unshift(new MergeWeekdayComponentRefiner_1.default());
      configuration.refiners.unshift(new ExtractTimezoneAbbrRefiner_1.default());
      configuration.refiners.unshift(new ExtractTimezoneOffsetRefiner_1.default());
      configuration.refiners.unshift(new OverlapRemovalRefiner_1.default());
      configuration.refiners.push(new OverlapRemovalRefiner_1.default());
      configuration.refiners.push(new ForwardDateRefiner_1.default());
      configuration.refiners.push(new UnlikelyFormatFilter_1.default(strictMode));
      return configuration;
    }
    exports.includeCommonConfiguration = includeCommonConfiguration;
  }
});

// node_modules/chrono-node/dist/common/casualReferences.js
var require_casualReferences = __commonJS({
  "node_modules/chrono-node/dist/common/casualReferences.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.noon = exports.morning = exports.midnight = exports.yesterdayEvening = exports.evening = exports.lastNight = exports.tonight = exports.theDayAfter = exports.tomorrow = exports.theDayBefore = exports.yesterday = exports.today = exports.now = void 0;
    var results_1 = require_results();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var index_1 = require_dist();
    function now(reference2) {
      const targetDate = dayjs_1.default(reference2.instant);
      const component = new results_1.ParsingComponents(reference2, {});
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.assignSimilarTime(component, targetDate);
      if (reference2.timezoneOffset !== null) {
        component.assign("timezoneOffset", targetDate.utcOffset());
      }
      return component;
    }
    exports.now = now;
    function today(reference2) {
      const targetDate = dayjs_1.default(reference2.instant);
      const component = new results_1.ParsingComponents(reference2, {});
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.implySimilarTime(component, targetDate);
      return component;
    }
    exports.today = today;
    function yesterday(reference2) {
      return theDayBefore(reference2, 1);
    }
    exports.yesterday = yesterday;
    function theDayBefore(reference2, numDay) {
      return theDayAfter(reference2, -numDay);
    }
    exports.theDayBefore = theDayBefore;
    function tomorrow(reference2) {
      return theDayAfter(reference2, 1);
    }
    exports.tomorrow = tomorrow;
    function theDayAfter(reference2, nDays) {
      let targetDate = dayjs_1.default(reference2.instant);
      const component = new results_1.ParsingComponents(reference2, {});
      targetDate = targetDate.add(nDays, "day");
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.implySimilarTime(component, targetDate);
      return component;
    }
    exports.theDayAfter = theDayAfter;
    function tonight(reference2, implyHour = 22) {
      const targetDate = dayjs_1.default(reference2.instant);
      const component = new results_1.ParsingComponents(reference2, {});
      component.imply("hour", implyHour);
      component.imply("meridiem", index_1.Meridiem.PM);
      dayjs_2.assignSimilarDate(component, targetDate);
      return component;
    }
    exports.tonight = tonight;
    function lastNight(reference2, implyHour = 0) {
      let targetDate = dayjs_1.default(reference2.instant);
      const component = new results_1.ParsingComponents(reference2, {});
      if (targetDate.hour() < 6) {
        targetDate = targetDate.add(-1, "day");
      }
      dayjs_2.assignSimilarDate(component, targetDate);
      component.imply("hour", implyHour);
      return component;
    }
    exports.lastNight = lastNight;
    function evening(reference2, implyHour = 20) {
      const component = new results_1.ParsingComponents(reference2, {});
      component.imply("meridiem", index_1.Meridiem.PM);
      component.imply("hour", implyHour);
      return component;
    }
    exports.evening = evening;
    function yesterdayEvening(reference2, implyHour = 20) {
      let targetDate = dayjs_1.default(reference2.instant);
      const component = new results_1.ParsingComponents(reference2, {});
      targetDate = targetDate.add(-1, "day");
      dayjs_2.assignSimilarDate(component, targetDate);
      component.imply("hour", implyHour);
      component.imply("meridiem", index_1.Meridiem.PM);
      return component;
    }
    exports.yesterdayEvening = yesterdayEvening;
    function midnight(reference2) {
      const component = new results_1.ParsingComponents(reference2, {});
      component.imply("hour", 0);
      component.imply("minute", 0);
      component.imply("second", 0);
      return component;
    }
    exports.midnight = midnight;
    function morning(reference2, implyHour = 6) {
      const component = new results_1.ParsingComponents(reference2, {});
      component.imply("meridiem", index_1.Meridiem.AM);
      component.imply("hour", implyHour);
      return component;
    }
    exports.morning = morning;
    function noon(reference2) {
      const component = new results_1.ParsingComponents(reference2, {});
      component.imply("meridiem", index_1.Meridiem.AM);
      component.imply("hour", 12);
      return component;
    }
    exports.noon = noon;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualDateParser.js
var require_ENCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var references = __importStar(require_casualReferences());
    var PATTERN = /(now|today|tonight|tomorrow|tmr|tmrw|yesterday|last\s*night)(?=\W|$)/i;
    var ENCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return PATTERN;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_1.default(context.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "now":
            return references.now(context.reference);
          case "today":
            return references.today(context.reference);
          case "yesterday":
            return references.yesterday(context.reference);
          case "tomorrow":
          case "tmr":
          case "tmrw":
            return references.tomorrow(context.reference);
          case "tonight":
            return references.tonight(context.reference);
          default:
            if (lowerText.match(/last\s*night/)) {
              if (targetDate.hour() > 6) {
                targetDate = targetDate.add(-1, "day");
              }
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
            break;
        }
        return component;
      }
    };
    exports.default = ENCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualTimeParser.js
var require_ENCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var PATTERN = /(?:this)?\s{0,3}(morning|afternoon|evening|night|midnight|noon)(?=\W|$)/i;
    var ENCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_1.default(context.refDate);
        const component = context.createParsingComponents();
        switch (match[1].toLowerCase()) {
          case "afternoon":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "evening":
          case "night":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
          case "midnight":
            dayjs_2.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "morning":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "noon":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = ENCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/calculation/weeks.js
var require_weeks = __commonJS({
  "node_modules/chrono-node/dist/calculation/weeks.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toDayJSClosestWeekday = exports.toDayJSWeekday = void 0;
    var dayjs_1 = __importDefault(require_dayjs_min());
    function toDayJSWeekday(refDate, offset2, modifier) {
      if (!modifier) {
        return toDayJSClosestWeekday(refDate, offset2);
      }
      let date = dayjs_1.default(refDate);
      switch (modifier) {
        case "this":
          date = date.day(offset2);
          break;
        case "next":
          date = date.day(offset2 + 7);
          break;
        case "last":
          date = date.day(offset2 - 7);
          break;
      }
      return date;
    }
    exports.toDayJSWeekday = toDayJSWeekday;
    function toDayJSClosestWeekday(refDate, offset2) {
      let date = dayjs_1.default(refDate);
      const refOffset = date.day();
      if (Math.abs(offset2 - 7 - refOffset) < Math.abs(offset2 - refOffset)) {
        date = date.day(offset2 - 7);
      } else if (Math.abs(offset2 + 7 - refOffset) < Math.abs(offset2 - refOffset)) {
        date = date.day(offset2 + 7);
      } else {
        date = date.day(offset2);
      }
      return date;
    }
    exports.toDayJSClosestWeekday = toDayJSClosestWeekday;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENWeekdayParser.js
var require_ENWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:on\\s*?)?(?:(this|last|past|next)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(this|last|past|next)\\s*week)?(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var ENWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset2 = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "last" || modifierWord == "past") {
          modifier = "last";
        } else if (modifierWord == "next") {
          modifier = "next";
        } else if (modifierWord == "this") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset2, modifier);
        return context.createParsingComponents().assign("weekday", offset2).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = ENWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENRelativeDateFormatParser.js
var require_ENRelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENRelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(this|last|past|next|after\\s*this)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var ENRelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "next" || modifier.startsWith("after")) {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        if (modifier == "last" || modifier == "past") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        const components = context.createParsingComponents();
        let date = dayjs_1.default(context.reference.instant);
        if (unitWord.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (unitWord.match(/month/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (unitWord.match(/year/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = ENRelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/chrono.js
var require_chrono = __commonJS({
  "node_modules/chrono-node/dist/chrono.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsingContext = exports.Chrono = void 0;
    var results_1 = require_results();
    var en_1 = require_en();
    var Chrono = class {
      constructor(configuration) {
        configuration = configuration || en_1.createCasualConfiguration();
        this.parsers = [...configuration.parsers];
        this.refiners = [...configuration.refiners];
      }
      clone() {
        return new Chrono({
          parsers: [...this.parsers],
          refiners: [...this.refiners]
        });
      }
      parseDate(text, referenceDate, option) {
        const results = this.parse(text, referenceDate, option);
        return results.length > 0 ? results[0].start.date() : null;
      }
      parse(text, referenceDate, option) {
        const context = new ParsingContext(text, referenceDate, option);
        let results = [];
        this.parsers.forEach((parser) => {
          const parsedResults = Chrono.executeParser(context, parser);
          results = results.concat(parsedResults);
        });
        results.sort((a, b) => {
          return a.index - b.index;
        });
        this.refiners.forEach(function(refiner) {
          results = refiner.refine(context, results);
        });
        return results;
      }
      static executeParser(context, parser) {
        const results = [];
        const pattern = parser.pattern(context);
        const originalText = context.text;
        let remainingText = context.text;
        let match = pattern.exec(remainingText);
        while (match) {
          const index = match.index + originalText.length - remainingText.length;
          match.index = index;
          const result = parser.extract(context, match);
          if (!result) {
            remainingText = originalText.substring(match.index + 1);
            match = pattern.exec(remainingText);
            continue;
          }
          let parsedResult = null;
          if (result instanceof results_1.ParsingResult) {
            parsedResult = result;
          } else if (result instanceof results_1.ParsingComponents) {
            parsedResult = context.createParsingResult(match.index, match[0]);
            parsedResult.start = result;
          } else {
            parsedResult = context.createParsingResult(match.index, match[0], result);
          }
          context.debug(() => console.log(`${parser.constructor.name} extracted result ${parsedResult}`));
          results.push(parsedResult);
          remainingText = originalText.substring(index + parsedResult.text.length);
          match = pattern.exec(remainingText);
        }
        return results;
      }
    };
    exports.Chrono = Chrono;
    var ParsingContext = class {
      constructor(text, refDate, option) {
        this.text = text;
        this.reference = new results_1.ReferenceWithTimezone(refDate);
        this.option = option !== null && option !== void 0 ? option : {};
        this.refDate = this.reference.instant;
      }
      createParsingComponents(components) {
        if (components instanceof results_1.ParsingComponents) {
          return components;
        }
        return new results_1.ParsingComponents(this.reference, components);
      }
      createParsingResult(index, textOrEndIndex, startComponents, endComponents) {
        const text = typeof textOrEndIndex === "string" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);
        const start2 = startComponents ? this.createParsingComponents(startComponents) : null;
        const end2 = endComponents ? this.createParsingComponents(endComponents) : null;
        return new results_1.ParsingResult(this.reference, index, text, start2, end2);
      }
      debug(block) {
        if (this.option.debug) {
          if (this.option.debug instanceof Function) {
            this.option.debug(block);
          } else {
            const handler = this.option.debug;
            handler.debug(block);
          }
        }
      }
    };
    exports.ParsingContext = ParsingContext;
  }
});

// node_modules/chrono-node/dist/common/parsers/SlashDateFormatParser.js
var require_SlashDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/SlashDateFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var PATTERN = new RegExp("([^\\d]|^)([0-3]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})(?:[\\/\\.\\-]([0-9]{4}|[0-9]{2}))?(\\W|$)", "i");
    var OPENING_GROUP = 1;
    var ENDING_GROUP = 5;
    var FIRST_NUMBERS_GROUP = 2;
    var SECOND_NUMBERS_GROUP = 3;
    var YEAR_GROUP = 4;
    var SlashDateFormatParser = class {
      constructor(littleEndian) {
        this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;
        this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;
      }
      pattern() {
        return PATTERN;
      }
      extract(context, match) {
        if (match[OPENING_GROUP] == "/" || match[ENDING_GROUP] == "/") {
          match.index += match[0].length;
          return;
        }
        const index = match.index + match[OPENING_GROUP].length;
        const text = match[0].substr(match[OPENING_GROUP].length, match[0].length - match[OPENING_GROUP].length - match[ENDING_GROUP].length);
        if (text.match(/^\d\.\d$/) || text.match(/^\d\.\d{1,2}\.\d{1,2}\s*$/)) {
          return;
        }
        if (!match[YEAR_GROUP] && match[0].indexOf("/") < 0) {
          return;
        }
        const result = context.createParsingResult(index, text);
        let month = parseInt(match[this.groupNumberMonth]);
        let day = parseInt(match[this.groupNumberDay]);
        if (month < 1 || month > 12) {
          if (month > 12) {
            if (day >= 1 && day <= 12 && month <= 31) {
              [day, month] = [month, day];
            } else {
              return null;
            }
          }
        }
        if (day < 1 || day > 31) {
          return null;
        }
        result.start.assign("day", day);
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const rawYearNumber = parseInt(match[YEAR_GROUP]);
          const year = years_1.findMostLikelyADYear(rawYearNumber);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = SlashDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js
var require_ENTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var ENTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "last":
          case "past":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = ENTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeRelativeDateRefiner.js
var require_ENMergeRelativeDateRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeRelativeDateRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var results_1 = require_results();
    var constants_1 = require_constants();
    var timeunits_1 = require_timeunits();
    function hasImpliedEarlierReferenceDate(result) {
      return result.text.match(/\s+(before|from)$/i) != null;
    }
    function hasImpliedLaterReferenceDate(result) {
      return result.text.match(/\s+(after|since)$/i) != null;
    }
    var ENMergeRelativeDateRefiner = class extends abstractRefiners_1.MergingRefiner {
      patternBetween() {
        return /^\s*$/i;
      }
      shouldMergeResults(textBetween, currentResult, nextResult) {
        if (!textBetween.match(this.patternBetween())) {
          return false;
        }
        if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {
          return false;
        }
        return !!nextResult.start.get("day") && !!nextResult.start.get("month") && !!nextResult.start.get("year");
      }
      mergeResults(textBetween, currentResult, nextResult) {
        let timeUnits = constants_1.parseTimeUnits(currentResult.text);
        if (hasImpliedEarlierReferenceDate(currentResult)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        const components = results_1.ParsingComponents.createRelativeFromReference(new results_1.ReferenceWithTimezone(nextResult.start.date()), timeUnits);
        return new results_1.ParsingResult(nextResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);
      }
    };
    exports.default = ENMergeRelativeDateRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/index.js
var require_en = __commonJS({
  "node_modules/chrono-node/dist/locales/en/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.GB = exports.strict = exports.casual = void 0;
    var ENTimeUnitWithinFormatParser_1 = __importDefault(require_ENTimeUnitWithinFormatParser());
    var ENMonthNameLittleEndianParser_1 = __importDefault(require_ENMonthNameLittleEndianParser());
    var ENMonthNameMiddleEndianParser_1 = __importDefault(require_ENMonthNameMiddleEndianParser());
    var ENMonthNameParser_1 = __importDefault(require_ENMonthNameParser());
    var ENCasualYearMonthDayParser_1 = __importDefault(require_ENCasualYearMonthDayParser());
    var ENSlashMonthFormatParser_1 = __importDefault(require_ENSlashMonthFormatParser());
    var ENTimeExpressionParser_1 = __importDefault(require_ENTimeExpressionParser());
    var ENTimeUnitAgoFormatParser_1 = __importDefault(require_ENTimeUnitAgoFormatParser());
    var ENTimeUnitLaterFormatParser_1 = __importDefault(require_ENTimeUnitLaterFormatParser());
    var ENMergeDateRangeRefiner_1 = __importDefault(require_ENMergeDateRangeRefiner());
    var ENMergeDateTimeRefiner_1 = __importDefault(require_ENMergeDateTimeRefiner());
    var configurations_1 = require_configurations();
    var ENCasualDateParser_1 = __importDefault(require_ENCasualDateParser());
    var ENCasualTimeParser_1 = __importDefault(require_ENCasualTimeParser());
    var ENWeekdayParser_1 = __importDefault(require_ENWeekdayParser());
    var ENRelativeDateFormatParser_1 = __importDefault(require_ENRelativeDateFormatParser());
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var ENTimeUnitCasualRelativeFormatParser_1 = __importDefault(require_ENTimeUnitCasualRelativeFormatParser());
    var ENMergeRelativeDateRefiner_1 = __importDefault(require_ENMergeRelativeDateRefiner());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration(false));
    exports.strict = new chrono_1.Chrono(createConfiguration(true, false));
    exports.GB = new chrono_1.Chrono(createConfiguration(false, true));
    function parse2(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse2;
    function parseDate2(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate2;
    function createCasualConfiguration(littleEndian = false) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new ENCasualDateParser_1.default());
      option.parsers.unshift(new ENCasualTimeParser_1.default());
      option.parsers.unshift(new ENMonthNameParser_1.default());
      option.parsers.unshift(new ENRelativeDateFormatParser_1.default());
      option.parsers.unshift(new ENTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = false) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new ENTimeUnitWithinFormatParser_1.default(),
          new ENMonthNameLittleEndianParser_1.default(),
          new ENMonthNameMiddleEndianParser_1.default(),
          new ENWeekdayParser_1.default(),
          new ENCasualYearMonthDayParser_1.default(),
          new ENSlashMonthFormatParser_1.default(),
          new ENTimeExpressionParser_1.default(strictMode),
          new ENTimeUnitAgoFormatParser_1.default(strictMode),
          new ENTimeUnitLaterFormatParser_1.default(strictMode)
        ],
        refiners: [new ENMergeRelativeDateRefiner_1.default(), new ENMergeDateTimeRefiner_1.default(), new ENMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DETimeExpressionParser.js
var require_DETimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DETimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var DETimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:um|von)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|bis)\\s*";
      }
      extractPrimaryTimeComponents(context, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context, match);
      }
    };
    exports.default = DETimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/de/constants.js
var require_constants2 = __commonJS({
  "node_modules/chrono-node/dist/locales/de/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      "sonntag": 0,
      "so": 0,
      "montag": 1,
      "mo": 1,
      "dienstag": 2,
      "di": 2,
      "mittwoch": 3,
      "mi": 3,
      "donnerstag": 4,
      "do": 4,
      "freitag": 5,
      "fr": 5,
      "samstag": 6,
      "sa": 6
    };
    exports.MONTH_DICTIONARY = {
      "januar": 1,
      "j\xE4nner": 1,
      "janner": 1,
      "jan": 1,
      "jan.": 1,
      "februar": 2,
      "feber": 2,
      "feb": 2,
      "feb.": 2,
      "m\xE4rz": 3,
      "maerz": 3,
      "m\xE4r": 3,
      "m\xE4r.": 3,
      "mrz": 3,
      "mrz.": 3,
      "april": 4,
      "apr": 4,
      "apr.": 4,
      "mai": 5,
      "juni": 6,
      "jun": 6,
      "jun.": 6,
      "juli": 7,
      "jul": 7,
      "jul.": 7,
      "august": 8,
      "aug": 8,
      "aug.": 8,
      "september": 9,
      "sep": 9,
      "sep.": 9,
      "sept": 9,
      "sept.": 9,
      "oktober": 10,
      "okt": 10,
      "okt.": 10,
      "november": 11,
      "nov": 11,
      "nov.": 11,
      "dezember": 12,
      "dez": 12,
      "dez.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      "eins": 1,
      "eine": 1,
      "einem": 1,
      "einen": 1,
      "einer": 1,
      "zwei": 2,
      "drei": 3,
      "vier": 4,
      "f\xFCnf": 5,
      "fuenf": 5,
      "sechs": 6,
      "sieben": 7,
      "acht": 8,
      "neun": 9,
      "zehn": 10,
      "elf": 11,
      "zw\xF6lf": 12,
      "zwoelf": 12
    };
    exports.TIME_UNIT_DICTIONARY = {
      sek: "second",
      sekunde: "second",
      sekunden: "second",
      min: "minute",
      minute: "minute",
      minuten: "minute",
      h: "hour",
      std: "hour",
      stunde: "hour",
      stunden: "hour",
      tag: "d",
      tage: "d",
      tagen: "d",
      woche: "week",
      wochen: "week",
      monat: "month",
      monate: "month",
      monaten: "month",
      monats: "month",
      quartal: "quarter",
      quartals: "quarter",
      quartale: "quarter",
      quartalen: "quarter",
      a: "year",
      j: "year",
      jr: "year",
      jahr: "year",
      jahre: "year",
      jahren: "year",
      jahres: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s*an?)?|an?\\b(?:\\s*few)?|few|several|a?\\s*couple\\s*(?:of)?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "a" || num === "an") {
        return 1;
      } else if (num.match(/few/)) {
        return 3;
      } else if (num.match(/half/)) {
        return 0.5;
      } else if (num.match(/couple/)) {
        return 2;
      } else if (num.match(/several/)) {
        return 7;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.YEAR_PATTERN = `(?:[0-9]{1,4}(?:\\s*[vn]\\.?\\s*(?:C(?:hr)?|(?:u\\.?|d\\.?(?:\\s*g\\.?)?)?\\s*Z)\\.?|\\s*(?:u\\.?|d\\.?(?:\\s*g\\.)?)\\s*Z\\.?)?)`;
    function parseYear(match) {
      if (/v/i.test(match)) {
        return -parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      if (/n/i.test(match)) {
        return parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      if (/z/i.test(match)) {
        return parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DEWeekdayParser.js
var require_DEWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DEWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants2();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:a[mn]\\s*?)?(?:(diese[mn]|letzte[mn]|n(?:\xE4|ae)chste[mn])\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(diese|letzte|n(?:\xE4|ae)chste)\\s*woche)?(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var SUFFIX_GROUP = 3;
    var WEEKDAY_GROUP = 2;
    var DEWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset2 = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[SUFFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord.match(/letzte/)) {
          modifier = "last";
        } else if (modifierWord.match(/chste/)) {
          modifier = "next";
        } else if (modifierWord.match(/diese/)) {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset2, modifier);
        return context.createParsingComponents().assign("weekday", offset2).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = DEWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DESpecificTimeExpressionParser.js
var require_DESpecificTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DESpecificTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var FIRST_REG_PATTERN = new RegExp("(^|\\s|T)(?:(?:um|von)\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
    var SECOND_REG_PATTERN = new RegExp("^\\s*(\\-|\\\u2013|\\~|\\\u301C|bis(?:\\s+um)?|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var AM_PM_HOUR_GROUP = 5;
    var DESpecificTimeExpressionParser = class {
      pattern(context) {
        return FIRST_REG_PATTERN;
      }
      extract(context, match) {
        const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
        if (result.text.match(/^\d{4}$/)) {
          match.index += match[0].length;
          return null;
        }
        result.start = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
        if (!result.start) {
          match.index += match[0].length;
          return null;
        }
        const remainingText = context.text.substring(match.index + match[0].length);
        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);
        if (secondMatch) {
          result.end = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
          if (result.end) {
            result.text += secondMatch[0];
          }
        }
        return result;
      }
      static extractTimeComponent(extractingComponents, match) {
        let hour = 0;
        let minute = 0;
        let meridiem = null;
        hour = parseInt(match[HOUR_GROUP]);
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP].toLowerCase();
          if (ampm.match(/morgen|vormittag/)) {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm.match(/nachmittag|abend/)) {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
          if (ampm.match(/nacht/)) {
            if (hour == 12) {
              meridiem = index_1.Meridiem.AM;
              hour = 0;
            } else if (hour < 6) {
              meridiem = index_1.Meridiem.AM;
            } else {
              meridiem = index_1.Meridiem.PM;
              hour += 12;
            }
          }
        }
        extractingComponents.assign("hour", hour);
        extractingComponents.assign("minute", minute);
        if (meridiem !== null) {
          extractingComponents.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            extractingComponents.imply("meridiem", index_1.Meridiem.AM);
          } else {
            extractingComponents.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          extractingComponents.assign("second", second);
        }
        return extractingComponents;
      }
    };
    exports.default = DESpecificTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateRangeRefiner.js
var require_DEMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var DEMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(bis(?:\s*(?:am|zum))?|-)\s*$/i;
      }
    };
    exports.default = DEMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateTimeRefiner.js
var require_DEMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var DEMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|um|am|,|-)?\\s*$");
      }
    };
    exports.default = DEMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DECasualTimeParser.js
var require_DECasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DECasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var timeunits_1 = require_timeunits();
    var DECasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(diesen)?\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_1.default(context.refDate);
        const timeKeywordPattern = match[2].toLowerCase();
        const component = context.createParsingComponents();
        dayjs_2.implySimilarTime(component, targetDate);
        return DECasualTimeParser.extractTimeComponents(component, timeKeywordPattern);
      }
      static extractTimeComponents(component, timeKeywordPattern) {
        switch (timeKeywordPattern) {
          case "morgen":
            component.imply("hour", 6);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "vormittag":
            component.imply("hour", 9);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "mittag":
          case "mittags":
            component.imply("hour", 12);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "nachmittag":
            component.imply("hour", 15);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "abend":
            component.imply("hour", 18);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "nacht":
            component.imply("hour", 22);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "mitternacht":
            if (component.get("hour") > 1) {
              component = timeunits_1.addImpliedTimeUnits(component, { "day": 1 });
            }
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
        }
        return component;
      }
    };
    exports.default = DECasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DECasualDateParser.js
var require_DECasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DECasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var DECasualTimeParser_1 = __importDefault(require_DECasualTimeParser());
    var references = __importStar(require_casualReferences());
    var PATTERN = new RegExp(`(jetzt|heute|morgen|\xFCbermorgen|uebermorgen|gestern|vorgestern|letzte\\s*nacht)(?:\\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var TIME_GROUP = 2;
    var DECasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return PATTERN;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_1.default(context.refDate);
        const dateKeyword = (match[DATE_GROUP] || "").toLowerCase();
        const timeKeyword = (match[TIME_GROUP] || "").toLowerCase();
        let component = context.createParsingComponents();
        switch (dateKeyword) {
          case "jetzt":
            component = references.now(context.reference);
            break;
          case "heute":
            component = references.today(context.reference);
            break;
          case "morgen":
            dayjs_2.assignTheNextDay(component, targetDate);
            break;
          case "\xFCbermorgen":
          case "uebermorgen":
            targetDate = targetDate.add(1, "day");
            dayjs_2.assignTheNextDay(component, targetDate);
            break;
          case "gestern":
            targetDate = targetDate.add(-1, "day");
            dayjs_2.assignSimilarDate(component, targetDate);
            dayjs_2.implySimilarTime(component, targetDate);
            break;
          case "vorgestern":
            targetDate = targetDate.add(-2, "day");
            dayjs_2.assignSimilarDate(component, targetDate);
            dayjs_2.implySimilarTime(component, targetDate);
            break;
          default:
            if (dateKeyword.match(/letzte\s*nacht/)) {
              if (targetDate.hour() > 6) {
                targetDate = targetDate.add(-1, "day");
              }
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
            break;
        }
        if (timeKeyword) {
          component = DECasualTimeParser_1.default.extractTimeComponents(component, timeKeyword);
        }
        return component;
      }
    };
    exports.default = DECasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DEMonthNameLittleEndianParser.js
var require_DEMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DEMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants2();
    var constants_2 = require_constants2();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:am\\s*?)?(?:den\\s*?)?([0-9]{1,2})\\.(?:\\s*(?:bis(?:\\s*(?:am|zum))?|\\-|\\\u2013|\\s)\\s*([0-9]{1,2})\\.?)?\\s*(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s*)(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var DEMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = parseInt(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = parseInt(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = DEMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DETimeUnitRelativeFormatParser.js
var require_DETimeUnitRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DETimeUnitRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants2();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var pattern_1 = require_pattern();
    var DETimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`(?:\\s*((?:n\xE4chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?|vor|in)\\s*)?(${constants_1.NUMBER_PATTERN})?(?:\\s*(n\xE4chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?)?\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})`, "i");
      }
      innerExtract(context, match) {
        const num = match[2] ? constants_1.parseNumberPattern(match[2]) : 1;
        const unit = constants_1.TIME_UNIT_DICTIONARY[match[4].toLowerCase()];
        let timeUnits = {};
        timeUnits[unit] = num;
        let modifier = match[1] || match[3] || "";
        modifier = modifier.toLowerCase();
        if (!modifier) {
          return;
        }
        if (/vor/.test(modifier) || /letzte/.test(modifier) || /vergangen/.test(modifier)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = DETimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/de/index.js
var require_de = __commonJS({
  "node_modules/chrono-node/dist/locales/de/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var ISOFormatParser_1 = __importDefault(require_ISOFormatParser());
    var DETimeExpressionParser_1 = __importDefault(require_DETimeExpressionParser());
    var DEWeekdayParser_1 = __importDefault(require_DEWeekdayParser());
    var DESpecificTimeExpressionParser_1 = __importDefault(require_DESpecificTimeExpressionParser());
    var DEMergeDateRangeRefiner_1 = __importDefault(require_DEMergeDateRangeRefiner());
    var DEMergeDateTimeRefiner_1 = __importDefault(require_DEMergeDateTimeRefiner());
    var DECasualDateParser_1 = __importDefault(require_DECasualDateParser());
    var DECasualTimeParser_1 = __importDefault(require_DECasualTimeParser());
    var DEMonthNameLittleEndianParser_1 = __importDefault(require_DEMonthNameLittleEndianParser());
    var DETimeUnitRelativeFormatParser_1 = __importDefault(require_DETimeUnitRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse2(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse2;
    function parseDate2(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate2;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new DECasualTimeParser_1.default());
      option.parsers.unshift(new DECasualDateParser_1.default());
      option.parsers.unshift(new DETimeUnitRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new ISOFormatParser_1.default(),
          new SlashDateFormatParser_1.default(littleEndian),
          new DETimeExpressionParser_1.default(),
          new DESpecificTimeExpressionParser_1.default(),
          new DEMonthNameLittleEndianParser_1.default(),
          new DEWeekdayParser_1.default()
        ],
        refiners: [new DEMergeDateRangeRefiner_1.default(), new DEMergeDateTimeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRCasualDateParser.js
var require_FRCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var references = __importStar(require_casualReferences());
    var FRCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(maintenant|aujourd'hui|demain|hier|cette\s*nuit|la\s*veille)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_1.default(context.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "maintenant":
            return references.now(context.reference);
          case "aujourd'hui":
            return references.today(context.reference);
          case "hier":
            return references.yesterday(context.reference);
          case "demain":
            return references.tomorrow(context.reference);
          default:
            if (lowerText.match(/cette\s*nuit/)) {
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 22);
              component.imply("meridiem", index_1.Meridiem.PM);
            } else if (lowerText.match(/la\s*veille/)) {
              targetDate = targetDate.add(-1, "day");
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
        }
        return component;
      }
    };
    exports.default = FRCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRCasualTimeParser.js
var require_FRCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRCasualTimeParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var FRCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(cet?)?\s*(matin|soir|après-midi|aprem|a midi|à minuit)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const suffixLower = match[2].toLowerCase();
        const component = context.createParsingComponents();
        switch (suffixLower) {
          case "apr\xE8s-midi":
          case "aprem":
            component.imply("hour", 14);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "soir":
            component.imply("hour", 18);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "matin":
            component.imply("hour", 8);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "a midi":
            component.imply("hour", 12);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "\xE0 minuit":
            component.imply("hour", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
        }
        return component;
      }
    };
    exports.default = FRCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeExpressionParser.js
var require_FRTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var FRTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:[\xE0a])\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|[\xE0a]|\\?)\\s*";
      }
      extractPrimaryTimeComponents(context, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context, match);
      }
    };
    exports.default = FRTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateTimeRefiner.js
var require_FRMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var FRMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|\xE0|a|vers|de|,|-)?\\s*$");
      }
    };
    exports.default = FRMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateRangeRefiner.js
var require_FRMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var FRMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(à|a|-)\s*$/i;
      }
    };
    exports.default = FRMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/fr/constants.js
var require_constants3 = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    exports.WEEKDAY_DICTIONARY = {
      "dimanche": 0,
      "dim": 0,
      "lundi": 1,
      "lun": 1,
      "mardi": 2,
      "mar": 2,
      "mercredi": 3,
      "mer": 3,
      "jeudi": 4,
      "jeu": 4,
      "vendredi": 5,
      "ven": 5,
      "samedi": 6,
      "sam": 6
    };
    exports.MONTH_DICTIONARY = {
      "janvier": 1,
      "jan": 1,
      "jan.": 1,
      "f\xE9vrier": 2,
      "f\xE9v": 2,
      "f\xE9v.": 2,
      "fevrier": 2,
      "fev": 2,
      "fev.": 2,
      "mars": 3,
      "mar": 3,
      "mar.": 3,
      "avril": 4,
      "avr": 4,
      "avr.": 4,
      "mai": 5,
      "juin": 6,
      "jun": 6,
      "juillet": 7,
      "juil": 7,
      "jul": 7,
      "jul.": 7,
      "ao\xFBt": 8,
      "aout": 8,
      "septembre": 9,
      "sep": 9,
      "sep.": 9,
      "sept": 9,
      "sept.": 9,
      "octobre": 10,
      "oct": 10,
      "oct.": 10,
      "novembre": 11,
      "nov": 11,
      "nov.": 11,
      "d\xE9cembre": 12,
      "decembre": 12,
      "dec": 12,
      "dec.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      "un": 1,
      "deux": 2,
      "trois": 3,
      "quatre": 4,
      "cinq": 5,
      "six": 6,
      "sept": 7,
      "huit": 8,
      "neuf": 9,
      "dix": 10,
      "onze": 11,
      "douze": 12,
      "treize": 13
    };
    exports.TIME_UNIT_DICTIONARY = {
      "sec": "second",
      "seconde": "second",
      "secondes": "second",
      "min": "minute",
      "mins": "minute",
      "minute": "minute",
      "minutes": "minute",
      "h": "hour",
      "hr": "hour",
      "hrs": "hour",
      "heure": "hour",
      "heures": "hour",
      "jour": "d",
      "jours": "d",
      "semaine": "week",
      "semaines": "week",
      "mois": "month",
      "trimestre": "quarter",
      "trimestres": "quarter",
      "ans": "year",
      "ann\xE9e": "year",
      "ann\xE9es": "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|une?\\b|quelques?|demi-?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "une" || num === "un") {
        return 1;
      } else if (num.match(/quelques?/)) {
        return 3;
      } else if (num.match(/demi-?/)) {
        return 0.5;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:[0-9]{1,2}(?:er)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      num = num.replace(/(?:er)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s*(?:AC|AD|p\\.\\s*C(?:hr?)?\\.\\s*n\\.)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/AC/i.test(match)) {
        match = match.replace(/BC/i, "");
        return -parseInt(match);
      }
      if (/AD/i.test(match) || /C/i.test(match)) {
        match = match.replace(/[^\d]+/i, "");
        return parseInt(match);
      }
      let yearNumber = parseInt(match);
      if (yearNumber < 100) {
        if (yearNumber > 50) {
          yearNumber = yearNumber + 1900;
        } else {
          yearNumber = yearNumber + 2e3;
        }
      }
      return yearNumber;
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRWeekdayParser.js
var require_FRWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:(?:ce)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(dernier|prochain)\\s*)?(?=\\W|\\d|$)`, "i");
    var WEEKDAY_GROUP = 1;
    var POSTFIX_GROUP = 2;
    var FRWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset2 = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        if (offset2 === void 0) {
          return null;
        }
        let suffix = match[POSTFIX_GROUP];
        suffix = suffix || "";
        suffix = suffix.toLowerCase();
        let modifier = null;
        if (suffix == "dernier") {
          modifier = "last";
        } else if (suffix == "prochain") {
          modifier = "next";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset2, modifier);
        return context.createParsingComponents().assign("weekday", offset2).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = FRWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRSpecificTimeExpressionParser.js
var require_FRSpecificTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRSpecificTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var FIRST_REG_PATTERN = new RegExp("(^|\\s|T)(?:(?:[\xE0a])\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
    var SECOND_REG_PATTERN = new RegExp("^\\s*(\\-|\\\u2013|\\~|\\\u301C|[\xE0a]|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var AM_PM_HOUR_GROUP = 5;
    var FRSpecificTimeExpressionParser = class {
      pattern(context) {
        return FIRST_REG_PATTERN;
      }
      extract(context, match) {
        const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
        if (result.text.match(/^\d{4}$/)) {
          match.index += match[0].length;
          return null;
        }
        result.start = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
        if (!result.start) {
          match.index += match[0].length;
          return null;
        }
        const remainingText = context.text.substring(match.index + match[0].length);
        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);
        if (secondMatch) {
          result.end = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
          if (result.end) {
            result.text += secondMatch[0];
          }
        }
        return result;
      }
      static extractTimeComponent(extractingComponents, match) {
        let hour = 0;
        let minute = 0;
        let meridiem = null;
        hour = parseInt(match[HOUR_GROUP]);
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
        }
        extractingComponents.assign("hour", hour);
        extractingComponents.assign("minute", minute);
        if (meridiem !== null) {
          extractingComponents.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            extractingComponents.imply("meridiem", index_1.Meridiem.AM);
          } else {
            extractingComponents.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          extractingComponents.assign("second", second);
        }
        return extractingComponents;
      }
    };
    exports.default = FRSpecificTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRMonthNameLittleEndianParser.js
var require_FRMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants3();
    var constants_2 = require_constants3();
    var constants_3 = require_constants3();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s*?)?(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s*(?:au|\\-|\\\u2013|jusqu'au?|\\s)\\s*(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s*(?:de)?\\s*)(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s*)(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var FRMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = FRMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitAgoFormatParser.js
var require_FRTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var FRTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`il y a\\s*(${constants_1.TIME_UNITS_PATTERN})(?=(?:\\W|$))`, "i");
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = FRTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitWithinFormatParser.js
var require_FRTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var FRTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp(`(?:dans|en|pour|pendant|de)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = FRTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitRelativeFormatParser.js
var require_FRTimeUnitRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var pattern_1 = require_pattern();
    var FRTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`(?:les?|la|l'|du|des?)\\s*(${constants_1.NUMBER_PATTERN})?(?:\\s*(prochaine?s?|derni[e\xE8]re?s?|pass[\xE9e]e?s?|pr[\xE9e]c[\xE9e]dents?|suivante?s?))?\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?:\\s*(prochaine?s?|derni[e\xE8]re?s?|pass[\xE9e]e?s?|pr[\xE9e]c[\xE9e]dents?|suivante?s?))?`, "i");
      }
      innerExtract(context, match) {
        const num = match[1] ? constants_1.parseNumberPattern(match[1]) : 1;
        const unit = constants_1.TIME_UNIT_DICTIONARY[match[3].toLowerCase()];
        let timeUnits = {};
        timeUnits[unit] = num;
        let modifier = match[2] || match[4] || "";
        modifier = modifier.toLowerCase();
        if (!modifier) {
          return;
        }
        if (/derni[eè]re?s?/.test(modifier) || /pass[ée]e?s?/.test(modifier) || /pr[ée]c[ée]dents?/.test(modifier)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = FRTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/index.js
var require_fr = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var FRCasualDateParser_1 = __importDefault(require_FRCasualDateParser());
    var FRCasualTimeParser_1 = __importDefault(require_FRCasualTimeParser());
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var FRTimeExpressionParser_1 = __importDefault(require_FRTimeExpressionParser());
    var FRMergeDateTimeRefiner_1 = __importDefault(require_FRMergeDateTimeRefiner());
    var FRMergeDateRangeRefiner_1 = __importDefault(require_FRMergeDateRangeRefiner());
    var FRWeekdayParser_1 = __importDefault(require_FRWeekdayParser());
    var FRSpecificTimeExpressionParser_1 = __importDefault(require_FRSpecificTimeExpressionParser());
    var FRMonthNameLittleEndianParser_1 = __importDefault(require_FRMonthNameLittleEndianParser());
    var FRTimeUnitAgoFormatParser_1 = __importDefault(require_FRTimeUnitAgoFormatParser());
    var FRTimeUnitWithinFormatParser_1 = __importDefault(require_FRTimeUnitWithinFormatParser());
    var FRTimeUnitRelativeFormatParser_1 = __importDefault(require_FRTimeUnitRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse2(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse2;
    function parseDate2(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate2;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new FRCasualDateParser_1.default());
      option.parsers.unshift(new FRCasualTimeParser_1.default());
      option.parsers.unshift(new FRTimeUnitRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new FRMonthNameLittleEndianParser_1.default(),
          new FRTimeExpressionParser_1.default(),
          new FRSpecificTimeExpressionParser_1.default(),
          new FRTimeUnitAgoFormatParser_1.default(),
          new FRTimeUnitWithinFormatParser_1.default(),
          new FRWeekdayParser_1.default()
        ],
        refiners: [new FRMergeDateTimeRefiner_1.default(), new FRMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/ja/constants.js
var require_constants4 = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toHankaku = void 0;
    function toHankaku(text) {
      return String(text).replace(/\u2019/g, "'").replace(/\u201D/g, '"').replace(/\u3000/g, " ").replace(/\uFFE5/g, "\xA5").replace(/[\uFF01\uFF03-\uFF06\uFF08\uFF09\uFF0C-\uFF19\uFF1C-\uFF1F\uFF21-\uFF3B\uFF3D\uFF3F\uFF41-\uFF5B\uFF5D\uFF5E]/g, alphaNum);
    }
    exports.toHankaku = toHankaku;
    function alphaNum(token) {
      return String.fromCharCode(token.charCodeAt(0) - 65248);
    }
  }
});

// node_modules/chrono-node/dist/locales/ja/parsers/JPStandardParser.js
var require_JPStandardParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/parsers/JPStandardParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants4();
    var years_1 = require_years();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var PATTERN = /(?:(?:([同今本])|((昭和|平成|令和)?([0-9０-９]{1,4}|元)))年\s*)?([0-9０-９]{1,2})月\s*([0-9０-９]{1,2})日/i;
    var SPECIAL_YEAR_GROUP = 1;
    var TYPICAL_YEAR_GROUP = 2;
    var ERA_GROUP = 3;
    var YEAR_NUMBER_GROUP = 4;
    var MONTH_GROUP = 5;
    var DAY_GROUP = 6;
    var JPStandardParser = class {
      pattern() {
        return PATTERN;
      }
      extract(context, match) {
        const month = parseInt(constants_1.toHankaku(match[MONTH_GROUP]));
        const day = parseInt(constants_1.toHankaku(match[DAY_GROUP]));
        const components = context.createParsingComponents({
          day,
          month
        });
        if (match[SPECIAL_YEAR_GROUP] && match[SPECIAL_YEAR_GROUP].match("\u540C|\u4ECA|\u672C")) {
          const moment = dayjs_1.default(context.refDate);
          components.assign("year", moment.year());
        }
        if (match[TYPICAL_YEAR_GROUP]) {
          const yearNumText = match[YEAR_NUMBER_GROUP];
          let year = yearNumText == "\u5143" ? 1 : parseInt(constants_1.toHankaku(yearNumText));
          if (match[ERA_GROUP] == "\u4EE4\u548C") {
            year += 2018;
          } else if (match[ERA_GROUP] == "\u5E73\u6210") {
            year += 1988;
          } else if (match[ERA_GROUP] == "\u662D\u548C") {
            year += 1925;
          }
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          components.imply("year", year);
        }
        return components;
      }
    };
    exports.default = JPStandardParser;
  }
});

// node_modules/chrono-node/dist/locales/ja/refiners/JPMergeDateRangeRefiner.js
var require_JPMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/refiners/JPMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var JPMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(から|ー|-)\s*$/i;
      }
    };
    exports.default = JPMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/ja/parsers/JPCasualDateParser.js
var require_JPCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/parsers/JPCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var index_1 = require_dist();
    var references = __importStar(require_casualReferences());
    var PATTERN = /今日|当日|昨日|明日|今夜|今夕|今晩|今朝/i;
    var JPCasualDateParser = class {
      pattern() {
        return PATTERN;
      }
      extract(context, match) {
        const text = match[0];
        const date = dayjs_1.default(context.refDate);
        const components = context.createParsingComponents();
        switch (text) {
          case "\u6628\u65E5":
            return references.yesterday(context.reference);
          case "\u660E\u65E5":
            return references.tomorrow(context.reference);
          case "\u4ECA\u65E5":
          case "\u5F53\u65E5":
            return references.today(context.reference);
        }
        if (text == "\u4ECA\u591C" || text == "\u4ECA\u5915" || text == "\u4ECA\u6669") {
          components.imply("hour", 22);
          components.assign("meridiem", index_1.Meridiem.PM);
        } else if (text.match("\u4ECA\u671D")) {
          components.imply("hour", 6);
          components.assign("meridiem", index_1.Meridiem.AM);
        }
        components.assign("day", date.date());
        components.assign("month", date.month() + 1);
        components.assign("year", date.year());
        return components;
      }
    };
    exports.default = JPCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/ja/index.js
var require_ja = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var JPStandardParser_1 = __importDefault(require_JPStandardParser());
    var JPMergeDateRangeRefiner_1 = __importDefault(require_JPMergeDateRangeRefiner());
    var JPCasualDateParser_1 = __importDefault(require_JPCasualDateParser());
    var chrono_1 = require_chrono();
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse2(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse2;
    function parseDate2(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate2;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new JPCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      return {
        parsers: [new JPStandardParser_1.default()],
        refiners: [new JPMergeDateRangeRefiner_1.default()]
      };
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/pt/constants.js
var require_constants5 = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseYear = exports.YEAR_PATTERN = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    exports.WEEKDAY_DICTIONARY = {
      "domingo": 0,
      "dom": 0,
      "segunda": 1,
      "segunda-feira": 1,
      "seg": 1,
      "ter\xE7a": 2,
      "ter\xE7a-feira": 2,
      "ter": 2,
      "quarta": 3,
      "quarta-feira": 3,
      "qua": 3,
      "quinta": 4,
      "quinta-feira": 4,
      "qui": 4,
      "sexta": 5,
      "sexta-feira": 5,
      "sex": 5,
      "s\xE1bado": 6,
      "sabado": 6,
      "sab": 6
    };
    exports.MONTH_DICTIONARY = {
      "janeiro": 1,
      "jan": 1,
      "jan.": 1,
      "fevereiro": 2,
      "fev": 2,
      "fev.": 2,
      "mar\xE7o": 3,
      "mar": 3,
      "mar.": 3,
      "abril": 4,
      "abr": 4,
      "abr.": 4,
      "maio": 5,
      "mai": 5,
      "mai.": 5,
      "junho": 6,
      "jun": 6,
      "jun.": 6,
      "julho": 7,
      "jul": 7,
      "jul.": 7,
      "agosto": 8,
      "ago": 8,
      "ago.": 8,
      "setembro": 9,
      "set": 9,
      "set.": 9,
      "outubro": 10,
      "out": 10,
      "out.": 10,
      "novembro": 11,
      "nov": 11,
      "nov.": 11,
      "dezembro": 12,
      "dez": 12,
      "dez.": 12
    };
    exports.YEAR_PATTERN = "[0-9]{1,4}(?![^\\s]\\d)(?:\\s*[a|d]\\.?\\s*c\\.?|\\s*a\\.?\\s*d\\.?)?";
    function parseYear(match) {
      if (match.match(/^[0-9]{1,4}$/)) {
        let yearNumber = parseInt(match);
        if (yearNumber < 100) {
          if (yearNumber > 50) {
            yearNumber = yearNumber + 1900;
          } else {
            yearNumber = yearNumber + 2e3;
          }
        }
        return yearNumber;
      }
      if (match.match(/a\.?\s*c\.?/i)) {
        match = match.replace(/a\.?\s*c\.?/i, "");
        return -parseInt(match);
      }
      return parseInt(match);
    }
    exports.parseYear = parseYear;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTWeekdayParser.js
var require_PTWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants5();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:(este|esta|passado|pr[o\xF3]ximo)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(este|esta|passado|pr[\xF3o]ximo)\\s*semana)?(?=\\W|\\d|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var PTWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset2 = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        if (offset2 === void 0) {
          return null;
        }
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let norm = prefix || postfix || "";
        norm = norm.toLowerCase();
        let modifier = null;
        if (norm == "passado") {
          modifier = "this";
        } else if (norm == "pr\xF3ximo" || norm == "proximo") {
          modifier = "next";
        } else if (norm == "este") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset2, modifier);
        return context.createParsingComponents().assign("weekday", offset2).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = PTWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTTimeExpressionParser.js
var require_PTTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var PTTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:ao?|\xE0s?|das|da|de|do)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|a(?:o)?|\\?)\\s*";
      }
    };
    exports.default = PTTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateTimeRefiner.js
var require_PTMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var PTMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(?:,|\xE0)?\\s*$");
      }
    };
    exports.default = PTMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateRangeRefiner.js
var require_PTMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var PTMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(?:-)\s*$/i;
      }
    };
    exports.default = PTMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTMonthNameLittleEndianParser.js
var require_PTMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants5();
    var constants_2 = require_constants5();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{1,2})(?:\xBA|\xAA|\xB0)?(?:\\s*(?:desde|de|\\-|\\\u2013|ao?|\\s)\\s*([0-9]{1,2})(?:\xBA|\xAA|\xB0)?)?\\s*(?:de)?\\s*(?:-|/|\\s*(?:de|,)?\\s*)(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:\\s*(?:de|,)?\\s*(${constants_2.YEAR_PATTERN}))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var PTMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = parseInt(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = parseInt(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = PTMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTCasualDateParser.js
var require_PTCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar(require_casualReferences());
    var PTCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(agora|hoje|amanha|amanhã|ontem)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "agora":
            return references.now(context.reference);
          case "hoje":
            return references.today(context.reference);
          case "amanha":
          case "amanh\xE3":
            return references.tomorrow(context.reference);
          case "ontem":
            return references.yesterday(context.reference);
        }
        return component;
      }
    };
    exports.default = PTCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTCasualTimeParser.js
var require_PTCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault(require_dayjs_min());
    var PTCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return /(?:esta\s*)?(manha|manhã|tarde|meia-noite|meio-dia|noite)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_2.default(context.refDate);
        const component = context.createParsingComponents();
        switch (match[1].toLowerCase()) {
          case "tarde":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "noite":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 22);
            break;
          case "manha":
          case "manh\xE3":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "meia-noite":
            dayjs_1.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "meio-dia":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = PTCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/index.js
var require_pt = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var PTWeekdayParser_1 = __importDefault(require_PTWeekdayParser());
    var PTTimeExpressionParser_1 = __importDefault(require_PTTimeExpressionParser());
    var PTMergeDateTimeRefiner_1 = __importDefault(require_PTMergeDateTimeRefiner());
    var PTMergeDateRangeRefiner_1 = __importDefault(require_PTMergeDateRangeRefiner());
    var PTMonthNameLittleEndianParser_1 = __importDefault(require_PTMonthNameLittleEndianParser());
    var PTCasualDateParser_1 = __importDefault(require_PTCasualDateParser());
    var PTCasualTimeParser_1 = __importDefault(require_PTCasualTimeParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse2(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse2;
    function parseDate2(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate2;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.push(new PTCasualDateParser_1.default());
      option.parsers.push(new PTCasualTimeParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new PTWeekdayParser_1.default(),
          new PTTimeExpressionParser_1.default(),
          new PTMonthNameLittleEndianParser_1.default()
        ],
        refiners: [new PTMergeDateTimeRefiner_1.default(), new PTMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateRangeRefiner.js
var require_NLMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var NLMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(tot|-)\s*$/i;
      }
    };
    exports.default = NLMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateTimeRefiner.js
var require_NLMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var NLMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(om|na|voor|in de|,|-)?\\s*$");
      }
    };
    exports.default = NLMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateParser.js
var require_NLCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar(require_casualReferences());
    var NLCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(nu|vandaag|morgen|morgend|gisteren)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "nu":
            return references.now(context.reference);
          case "vandaag":
            return references.today(context.reference);
          case "morgen":
          case "morgend":
            return references.tomorrow(context.reference);
          case "gisteren":
            return references.yesterday(context.reference);
        }
        return component;
      }
    };
    exports.default = NLCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualTimeParser.js
var require_NLCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var DAY_GROUP = 1;
    var MOMENT_GROUP = 2;
    var NLCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return /(deze)?\s*(namiddag|avond|middernacht|ochtend|middag|'s middags|'s avonds|'s ochtends)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_1.default(context.refDate);
        const component = context.createParsingComponents();
        if (match[DAY_GROUP] === "deze") {
          component.assign("day", context.refDate.getDate());
          component.assign("month", context.refDate.getMonth() + 1);
          component.assign("year", context.refDate.getFullYear());
        }
        switch (match[MOMENT_GROUP].toLowerCase()) {
          case "namiddag":
          case "'s namiddags":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "avond":
          case "'s avonds'":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
          case "middernacht":
            dayjs_2.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "ochtend":
          case "'s ochtends":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "middag":
          case "'s middags":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = NLCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/constants.js
var require_constants6 = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      zondag: 0,
      zon: 0,
      "zon.": 0,
      zo: 0,
      "zo.": 0,
      maandag: 1,
      ma: 1,
      "ma.": 1,
      dinsdag: 2,
      din: 2,
      "din.": 2,
      di: 2,
      "di.": 2,
      woensdag: 3,
      woe: 3,
      "woe.": 3,
      wo: 3,
      "wo.": 3,
      donderdag: 4,
      dond: 4,
      "dond.": 4,
      do: 4,
      "do.": 4,
      vrijdag: 5,
      vrij: 5,
      "vrij.": 5,
      vr: 5,
      "vr.": 5,
      zaterdag: 6,
      zat: 6,
      "zat.": 6,
      "za": 6,
      "za.": 6
    };
    exports.MONTH_DICTIONARY = {
      januari: 1,
      jan: 1,
      "jan.": 1,
      februari: 2,
      feb: 2,
      "feb.": 2,
      maart: 3,
      mar: 3,
      "mar.": 3,
      april: 4,
      apr: 4,
      "apr.": 4,
      mei: 5,
      juni: 6,
      jun: 6,
      "jun.": 6,
      juli: 7,
      jul: 7,
      "jul.": 7,
      augustus: 8,
      aug: 8,
      "aug.": 8,
      september: 9,
      sep: 9,
      "sep.": 9,
      sept: 9,
      "sept.": 9,
      oktober: 10,
      okt: 10,
      "okt.": 10,
      november: 11,
      nov: 11,
      "nov.": 11,
      december: 12,
      dec: 12,
      "dec.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      een: 1,
      twee: 2,
      drie: 3,
      vier: 4,
      vijf: 5,
      zes: 6,
      zeven: 7,
      acht: 8,
      negen: 9,
      tien: 10,
      elf: 11,
      twaalf: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      eerste: 1,
      tweede: 2,
      derde: 3,
      vierde: 4,
      vijfde: 5,
      zesde: 6,
      zevende: 7,
      achtste: 8,
      negende: 9,
      tiende: 10,
      elfde: 11,
      twaalfde: 12,
      dertiende: 13,
      veertiende: 14,
      vijftiende: 15,
      zestiende: 16,
      zeventiende: 17,
      achttiende: 18,
      negentiende: 19,
      twintigste: 20,
      "eenentwintigste": 21,
      "twee\xEBntwintigste": 22,
      "drieentwintigste": 23,
      "vierentwintigste": 24,
      "vijfentwintigste": 25,
      "zesentwintigste": 26,
      "zevenentwintigste": 27,
      "achtentwintig": 28,
      "negenentwintig": 29,
      "dertigste": 30,
      "eenendertigste": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      sec: "second",
      second: "second",
      seconden: "second",
      min: "minute",
      mins: "minute",
      minute: "minute",
      minuut: "minute",
      minuten: "minute",
      minuutje: "minute",
      h: "hour",
      hr: "hour",
      hrs: "hour",
      uur: "hour",
      u: "hour",
      uren: "hour",
      dag: "d",
      dagen: "d",
      week: "week",
      weken: "week",
      maand: "month",
      maanden: "month",
      jaar: "year",
      jr: "year",
      jaren: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+[\\.,][0-9]+|halve?|half|paar)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "paar") {
        return 2;
      } else if (num === "half" || num.match(/halve?/)) {
        return 0.5;
      }
      return parseFloat(num.replace(",", "."));
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:ste|de)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:ste|de)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s*(?:voor Christus|na Christus)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/voor Christus/i.test(match)) {
        match = match.replace(/voor Christus/i, "");
        return -parseInt(match);
      }
      if (/na Christus/i.test(match)) {
        match = match.replace(/na Christus/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:binnen|in)\\s*)?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitWithinFormatParser.js
var require_NLTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NLTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp(`(?:binnen|in|binnen de|voor)\\s*(` + constants_1.TIME_UNITS_PATTERN + `)(?=\\W|$)`, "i");
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = NLTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLWeekdayParser.js
var require_NLWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:op\\s*?)?(?:(deze|vorige|volgende)\\s*(?:week\\s*)?)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var NLWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset2 = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "vorige") {
          modifier = "last";
        } else if (modifierWord == "volgende") {
          modifier = "next";
        } else if (modifierWord == "deze") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset2, modifier);
        return context.createParsingComponents().assign("weekday", offset2).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = NLWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameMiddleEndianParser.js
var require_NLMonthNameMiddleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameMiddleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants6();
    var constants_2 = require_constants6();
    var constants_3 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s*?)?(${constants_2.ORDINAL_NUMBER_PATTERN})(?:\\s*(?:tot|\\-|\\\u2013|until|through|till|\\s)\\s*(${constants_2.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s*(?:of)?\\s*)(` + pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY) + `)(?:(?:-|/|,?\\s*)(${constants_3.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var MONTH_NAME_GROUP = 3;
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var YEAR_GROUP = 4;
    var NLMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_2.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        const components = context.createParsingComponents({
          day,
          month
        });
        if (match[YEAR_GROUP]) {
          const year = constants_3.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          components.imply("year", year);
        }
        if (!match[DATE_TO_GROUP]) {
          return components;
        }
        const endDate = constants_2.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
        const result = context.createParsingResult(match.index, match[0]);
        result.start = components;
        result.end = components.clone();
        result.end.assign("day", endDate);
        return result;
      }
    };
    exports.default = NLMonthNameMiddleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameParser.js
var require_NLMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants6();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
    var MONTH_NAME_GROUP = 1;
    var YEAR_GROUP = 2;
    var NLMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const components = context.createParsingComponents();
        components.imply("day", 1);
        const monthName = match[MONTH_NAME_GROUP];
        const month = constants_1.MONTH_DICTIONARY[monthName.toLowerCase()];
        components.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, 1, month);
          components.imply("year", year);
        }
        return components;
      }
    };
    exports.default = NLMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLSlashMonthFormatParser.js
var require_NLSlashMonthFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLSlashMonthFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
    var MONTH_GROUP = 1;
    var YEAR_GROUP = 2;
    var NLSlashMonthFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const year = parseInt(match[YEAR_GROUP]);
        const month = parseInt(match[MONTH_GROUP]);
        return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year);
      }
    };
    exports.default = NLSlashMonthFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeExpressionParser.js
var require_NLTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var NLTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:om)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|om|\\?)\\s*";
      }
      primarySuffix() {
        return "(?:\\s*(?:uur))?(?!/)(?=\\W|$)";
      }
      extractPrimaryTimeComponents(context, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context, match);
      }
    };
    exports.default = NLTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualYearMonthDayParser.js
var require_NLCasualYearMonthDayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualYearMonthDayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var MONTH_NUMBER_GROUP = 3;
    var DATE_NUMBER_GROUP = 4;
    var NLCasualYearMonthDayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        if (month < 1 || month > 12) {
          return null;
        }
        const year = parseInt(match[YEAR_NUMBER_GROUP]);
        const day = parseInt(match[DATE_NUMBER_GROUP]);
        return {
          day,
          month,
          year
        };
      }
    };
    exports.default = NLCasualYearMonthDayParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateTimeParser.js
var require_NLCasualDateTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateTimeParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var index_1 = require_dist();
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault(require_dayjs_min());
    var DATE_GROUP = 1;
    var TIME_OF_DAY_GROUP = 2;
    var NLCasualDateTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(gisteren|morgen|van)(ochtend|middag|namiddag|avond|nacht)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const dateText = match[DATE_GROUP].toLowerCase();
        const timeText = match[TIME_OF_DAY_GROUP].toLowerCase();
        const component = context.createParsingComponents();
        const targetDate = dayjs_2.default(context.refDate);
        switch (dateText) {
          case "gisteren":
            dayjs_1.assignSimilarDate(component, targetDate.add(-1, "day"));
            break;
          case "van":
            dayjs_1.assignSimilarDate(component, targetDate);
            break;
          case "morgen":
            dayjs_1.assignTheNextDay(component, targetDate);
            break;
        }
        switch (timeText) {
          case "ochtend":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "middag":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
          case "namiddag":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "avond":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
        }
        return component;
      }
    };
    exports.default = NLCasualDateTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.js
var require_NLTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(deze|vorige|afgelopen|komende|over|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var NLTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "vorige":
          case "afgelopen":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = NLTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLRelativeDateFormatParser.js
var require_NLRelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLRelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(dit|deze|komende|volgend|volgende|afgelopen|vorige)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var NLRelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "volgend" || modifier == "volgende" || modifier == "komende") {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        if (modifier == "afgelopen" || modifier == "vorige") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        const components = context.createParsingComponents();
        let date = dayjs_1.default(context.reference.instant);
        if (unitWord.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (unitWord.match(/maand/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (unitWord.match(/jaar/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = NLRelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitAgoFormatParser.js
var require_NLTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(?:geleden|voor|eerder)(?=(?:\\W|$))", "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")geleden(?=(?:\\W|$))", "i");
    var NLTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = NLTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitLaterFormatParser.js
var require_NLTimeUnitLaterFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitLaterFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|na|vanaf nu|voortaan|vooruit|uit)(?=(?:\\W|$))", "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|vanaf nu)(?=(?:\\W|$))", "i");
    var GROUP_NUM_TIMEUNITS = 1;
    var NLTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const fragments = constants_1.parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, fragments);
      }
    };
    exports.default = NLTimeUnitLaterFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/index.js
var require_nl = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var NLMergeDateRangeRefiner_1 = __importDefault(require_NLMergeDateRangeRefiner());
    var NLMergeDateTimeRefiner_1 = __importDefault(require_NLMergeDateTimeRefiner());
    var NLCasualDateParser_1 = __importDefault(require_NLCasualDateParser());
    var NLCasualTimeParser_1 = __importDefault(require_NLCasualTimeParser());
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var NLTimeUnitWithinFormatParser_1 = __importDefault(require_NLTimeUnitWithinFormatParser());
    var NLWeekdayParser_1 = __importDefault(require_NLWeekdayParser());
    var NLMonthNameMiddleEndianParser_1 = __importDefault(require_NLMonthNameMiddleEndianParser());
    var NLMonthNameParser_1 = __importDefault(require_NLMonthNameParser());
    var NLSlashMonthFormatParser_1 = __importDefault(require_NLSlashMonthFormatParser());
    var NLTimeExpressionParser_1 = __importDefault(require_NLTimeExpressionParser());
    var NLCasualYearMonthDayParser_1 = __importDefault(require_NLCasualYearMonthDayParser());
    var NLCasualDateTimeParser_1 = __importDefault(require_NLCasualDateTimeParser());
    var NLTimeUnitCasualRelativeFormatParser_1 = __importDefault(require_NLTimeUnitCasualRelativeFormatParser());
    var NLRelativeDateFormatParser_1 = __importDefault(require_NLRelativeDateFormatParser());
    var NLTimeUnitAgoFormatParser_1 = __importDefault(require_NLTimeUnitAgoFormatParser());
    var NLTimeUnitLaterFormatParser_1 = __importDefault(require_NLTimeUnitLaterFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse2(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse2;
    function parseDate2(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate2;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new NLCasualDateParser_1.default());
      option.parsers.unshift(new NLCasualTimeParser_1.default());
      option.parsers.unshift(new NLCasualDateTimeParser_1.default());
      option.parsers.unshift(new NLMonthNameParser_1.default());
      option.parsers.unshift(new NLRelativeDateFormatParser_1.default());
      option.parsers.unshift(new NLTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new NLTimeUnitWithinFormatParser_1.default(),
          new NLMonthNameMiddleEndianParser_1.default(),
          new NLMonthNameParser_1.default(),
          new NLWeekdayParser_1.default(),
          new NLCasualYearMonthDayParser_1.default(),
          new NLSlashMonthFormatParser_1.default(),
          new NLTimeExpressionParser_1.default(strictMode),
          new NLTimeUnitAgoFormatParser_1.default(strictMode),
          new NLTimeUnitLaterFormatParser_1.default(strictMode)
        ],
        refiners: [new NLMergeDateTimeRefiner_1.default(), new NLMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantCasualDateParser.js
var require_ZHHantCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantCasualDateParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NOW_GROUP = 1;
    var DAY_GROUP_1 = 2;
    var TIME_GROUP_1 = 3;
    var TIME_GROUP_2 = 4;
    var DAY_GROUP_3 = 5;
    var TIME_GROUP_3 = 6;
    var ZHHantCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return new RegExp("(\u800C\u5BB6|\u7ACB(?:\u523B|\u5373)|\u5373\u523B)|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s|,|\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?", "i");
      }
      innerExtract(context, match) {
        const index = match.index;
        const result = context.createParsingResult(index, match[0]);
        const refMoment = dayjs_1.default(context.refDate);
        let startMoment = refMoment;
        if (match[NOW_GROUP]) {
          result.start.imply("hour", refMoment.hour());
          result.start.imply("minute", refMoment.minute());
          result.start.imply("second", refMoment.second());
          result.start.imply("millisecond", refMoment.millisecond());
        } else if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          const time1 = match[TIME_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            startMoment = startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            startMoment = startMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            startMoment = startMoment.add(3, "day");
          }
          if (time1 == "\u65E9" || time1 == "\u671D") {
            result.start.imply("hour", 6);
          } else if (time1 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          }
        } else if (match[TIME_GROUP_2]) {
          const timeString2 = match[TIME_GROUP_2];
          const time2 = timeString2[0];
          if (time2 == "\u65E9" || time2 == "\u671D" || time2 == "\u4E0A") {
            result.start.imply("hour", 6);
          } else if (time2 == "\u4E0B" || time2 == "\u664F") {
            result.start.imply("hour", 15);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u4E2D") {
            result.start.imply("hour", 12);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u591C" || time2 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u51CC") {
            result.start.imply("hour", 0);
          }
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            startMoment = startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            startMoment = startMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            startMoment = startMoment.add(3, "day");
          }
          const timeString3 = match[TIME_GROUP_3];
          if (timeString3) {
            const time3 = timeString3[0];
            if (time3 == "\u65E9" || time3 == "\u671D" || time3 == "\u4E0A") {
              result.start.imply("hour", 6);
            } else if (time3 == "\u4E0B" || time3 == "\u664F") {
              result.start.imply("hour", 15);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u4E2D") {
              result.start.imply("hour", 12);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u591C" || time3 == "\u665A") {
              result.start.imply("hour", 22);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u51CC") {
              result.start.imply("hour", 0);
            }
          }
        }
        result.start.assign("day", startMoment.date());
        result.start.assign("month", startMoment.month() + 1);
        result.start.assign("year", startMoment.year());
        return result;
      }
    };
    exports.default = ZHHantCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/constants.js
var require_constants7 = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zhStringToYear = exports.zhStringToNumber = exports.WEEKDAY_OFFSET = exports.NUMBER = void 0;
    exports.NUMBER = {
      "\u96F6": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u5169": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6,
      "\u4E03": 7,
      "\u516B": 8,
      "\u4E5D": 9,
      "\u5341": 10,
      "\u5EFF": 20,
      "\u5345": 30
    };
    exports.WEEKDAY_OFFSET = {
      "\u5929": 0,
      "\u65E5": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6
    };
    function zhStringToNumber(text) {
      let number = 0;
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (char === "\u5341") {
          number = number === 0 ? exports.NUMBER[char] : number * exports.NUMBER[char];
        } else {
          number += exports.NUMBER[char];
        }
      }
      return number;
    }
    exports.zhStringToNumber = zhStringToNumber;
    function zhStringToYear(text) {
      let string = "";
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        string = string + exports.NUMBER[char];
      }
      return parseInt(string);
    }
    exports.zhStringToYear = zhStringToYear;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDateParser.js
var require_ZHHantDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDateParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var YEAR_GROUP = 1;
    var MONTH_GROUP = 2;
    var DAY_GROUP = 3;
    var ZHHantDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp("(\\d{2,4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{2})?(?:\\s*)(?:\u5E74)?(?:[\\s|,|\uFF0C]*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,2})(?:\\s*)(?:\u6708)(?:\\s*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,2})?(?:\\s*)(?:\u65E5|\u865F)?");
      }
      innerExtract(context, match) {
        const startMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        let month = parseInt(match[MONTH_GROUP]);
        if (isNaN(month))
          month = constants_1.zhStringToNumber(match[MONTH_GROUP]);
        result.start.assign("month", month);
        if (match[DAY_GROUP]) {
          let day = parseInt(match[DAY_GROUP]);
          if (isNaN(day))
            day = constants_1.zhStringToNumber(match[DAY_GROUP]);
          result.start.assign("day", day);
        } else {
          result.start.imply("day", startMoment.date());
        }
        if (match[YEAR_GROUP]) {
          let year = parseInt(match[YEAR_GROUP]);
          if (isNaN(year))
            year = constants_1.zhStringToYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.js
var require_ZHHantDeadlineFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+|\u534A|\u5E7E)(?:\\s*)(?:\u500B)?(\u79D2(?:\u9418)?|\u5206\u9418|\u5C0F\u6642|\u9418|\u65E5|\u5929|\u661F\u671F|\u79AE\u62DC|\u6708|\u5E74)(?:(?:\u4E4B|\u904E)?\u5F8C|(?:\u4E4B)?\u5167)", "i");
    var NUMBER_GROUP = 1;
    var UNIT_GROUP = 2;
    var ZHHantDeadlineFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        let number = parseInt(match[NUMBER_GROUP]);
        if (isNaN(number)) {
          number = constants_1.zhStringToNumber(match[NUMBER_GROUP]);
        }
        if (isNaN(number)) {
          const string = match[NUMBER_GROUP];
          if (string === "\u5E7E") {
            number = 3;
          } else if (string === "\u534A") {
            number = 0.5;
          } else {
            return null;
          }
        }
        let date = dayjs_1.default(context.refDate);
        const unit = match[UNIT_GROUP];
        const unitAbbr = unit[0];
        if (unitAbbr.match(/[日天星禮月年]/)) {
          if (unitAbbr == "\u65E5" || unitAbbr == "\u5929") {
            date = date.add(number, "d");
          } else if (unitAbbr == "\u661F" || unitAbbr == "\u79AE") {
            date = date.add(number * 7, "d");
          } else if (unitAbbr == "\u6708") {
            date = date.add(number, "month");
          } else if (unitAbbr == "\u5E74") {
            date = date.add(number, "year");
          }
          result.start.assign("year", date.year());
          result.start.assign("month", date.month() + 1);
          result.start.assign("day", date.date());
          return result;
        }
        if (unitAbbr == "\u79D2") {
          date = date.add(number, "second");
        } else if (unitAbbr == "\u5206") {
          date = date.add(number, "minute");
        } else if (unitAbbr == "\u5C0F" || unitAbbr == "\u9418") {
          date = date.add(number, "hour");
        }
        result.start.imply("year", date.year());
        result.start.imply("month", date.month() + 1);
        result.start.imply("day", date.date());
        result.start.assign("hour", date.hour());
        result.start.assign("minute", date.minute());
        result.start.assign("second", date.second());
        return result;
      }
    };
    exports.default = ZHHantDeadlineFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.js
var require_ZHHantRelationWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(?<prefix>\u4E0A|\u4ECA|\u4E0B|\u9019|\u5462)(?:\u500B)?(?:\u661F\u671F|\u79AE\u62DC|\u9031)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHantRelationWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset2 = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset2 === void 0)
          return null;
        let modifier = null;
        const prefix = match.groups.prefix;
        if (prefix == "\u4E0A") {
          modifier = "last";
        } else if (prefix == "\u4E0B") {
          modifier = "next";
        } else if (prefix == "\u4ECA" || prefix == "\u9019" || prefix == "\u5462") {
          modifier = "this";
        }
        let startMoment = dayjs_1.default(context.refDate);
        let startMomentFixed = false;
        const refOffset = startMoment.day();
        if (modifier == "last" || modifier == "past") {
          startMoment = startMoment.day(offset2 - 7);
          startMomentFixed = true;
        } else if (modifier == "next") {
          startMoment = startMoment.day(offset2 + 7);
          startMomentFixed = true;
        } else if (modifier == "this") {
          startMoment = startMoment.day(offset2);
        } else {
          if (Math.abs(offset2 - 7 - refOffset) < Math.abs(offset2 - refOffset)) {
            startMoment = startMoment.day(offset2 - 7);
          } else if (Math.abs(offset2 + 7 - refOffset) < Math.abs(offset2 - refOffset)) {
            startMoment = startMoment.day(offset2 + 7);
          } else {
            startMoment = startMoment.day(offset2);
          }
        }
        result.start.assign("weekday", offset2);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantRelationWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantTimeExpressionParser.js
var require_ZHHantTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantTimeExpressionParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var FIRST_REG_PATTERN = new RegExp("(?:\u7531|\u5F9E|\u81EA)?(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u9EDE|\u6642|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var SECOND_REG_PATTERN = new RegExp("(?:^\\s*(?:\u5230|\u81F3|\\-|\\\u2013|\\~|\\\u301C)\\s*)(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u9EDE|\u6642|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var DAY_GROUP_1 = 1;
    var ZH_AM_PM_HOUR_GROUP_1 = 2;
    var ZH_AM_PM_HOUR_GROUP_2 = 3;
    var DAY_GROUP_3 = 4;
    var ZH_AM_PM_HOUR_GROUP_3 = 5;
    var HOUR_GROUP = 6;
    var MINUTE_GROUP = 7;
    var SECOND_GROUP = 8;
    var AM_PM_HOUR_GROUP = 9;
    var ZHHantTimeExpressionParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return FIRST_REG_PATTERN;
      }
      innerExtract(context, match) {
        if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
          return null;
        }
        const refMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        const startMoment = refMoment.clone();
        if (match[DAY_GROUP_1]) {
          var day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            startMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else if (match[DAY_GROUP_3]) {
          var day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            startMoment.add(1, "day");
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            startMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        let hour = 0;
        let minute = 0;
        let meridiem = -1;
        if (match[SECOND_GROUP]) {
          var second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.start.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          var zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u671D" || zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          var zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u671D" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u664F" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          var zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u671D" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u664F" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.start.assign("hour", hour);
        result.start.assign("minute", minute);
        if (meridiem >= 0) {
          result.start.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            result.start.imply("meridiem", 0);
          } else {
            result.start.imply("meridiem", 1);
          }
        }
        match = SECOND_REG_PATTERN.exec(context.text.substring(result.index + result.text.length));
        if (!match) {
          if (result.text.match(/^\d+$/)) {
            return null;
          }
          return result;
        }
        const endMoment = startMoment.clone();
        result.end = context.createParsingComponents();
        if (match[DAY_GROUP_1]) {
          var day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              endMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            endMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            endMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else if (match[DAY_GROUP_3]) {
          var day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            endMoment.add(1, "day");
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            endMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            endMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else {
          result.end.imply("day", endMoment.date());
          result.end.imply("month", endMoment.month() + 1);
          result.end.imply("year", endMoment.year());
        }
        hour = 0;
        minute = 0;
        meridiem = -1;
        if (match[SECOND_GROUP]) {
          var second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.end.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == 0) {
              result.start.imply("meridiem", 0);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", 1);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          var zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u671D" || zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          var zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u671D" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u664F" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          var zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u671D" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u664F" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.text = result.text + match[0];
        result.end.assign("hour", hour);
        result.end.assign("minute", minute);
        if (meridiem >= 0) {
          result.end.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
          if (startAtPM && result.start.get("hour") > hour) {
            result.end.imply("meridiem", 0);
          } else if (hour > 12) {
            result.end.imply("meridiem", 1);
          }
        }
        if (result.end.date().getTime() < result.start.date().getTime()) {
          result.end.imply("day", result.end.get("day") + 1);
        }
        return result;
      }
    };
    exports.default = ZHHantTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantWeekdayParser.js
var require_ZHHantWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(?:\u661F\u671F|\u79AE\u62DC|\u9031)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHantWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset2 = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset2 === void 0)
          return null;
        let startMoment = dayjs_1.default(context.refDate);
        const startMomentFixed = false;
        const refOffset = startMoment.day();
        if (Math.abs(offset2 - 7 - refOffset) < Math.abs(offset2 - refOffset)) {
          startMoment = startMoment.day(offset2 - 7);
        } else if (Math.abs(offset2 + 7 - refOffset) < Math.abs(offset2 - refOffset)) {
          startMoment = startMoment.day(offset2 + 7);
        } else {
          startMoment = startMoment.day(offset2);
        }
        result.start.assign("weekday", offset2);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.js
var require_ZHHantMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var ZHHantMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(至|到|\-|\~|～|－|ー)\s*$/i;
      }
    };
    exports.default = ZHHantMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.js
var require_ZHHantMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var ZHHantMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return /^\s*$/i;
      }
    };
    exports.default = ZHHantMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/index.js
var require_hant = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = exports.hant = void 0;
    var chrono_1 = require_chrono();
    var ExtractTimezoneOffsetRefiner_1 = __importDefault(require_ExtractTimezoneOffsetRefiner());
    var configurations_1 = require_configurations();
    var ZHHantCasualDateParser_1 = __importDefault(require_ZHHantCasualDateParser());
    var ZHHantDateParser_1 = __importDefault(require_ZHHantDateParser());
    var ZHHantDeadlineFormatParser_1 = __importDefault(require_ZHHantDeadlineFormatParser());
    var ZHHantRelationWeekdayParser_1 = __importDefault(require_ZHHantRelationWeekdayParser());
    var ZHHantTimeExpressionParser_1 = __importDefault(require_ZHHantTimeExpressionParser());
    var ZHHantWeekdayParser_1 = __importDefault(require_ZHHantWeekdayParser());
    var ZHHantMergeDateRangeRefiner_1 = __importDefault(require_ZHHantMergeDateRangeRefiner());
    var ZHHantMergeDateTimeRefiner_1 = __importDefault(require_ZHHantMergeDateTimeRefiner());
    exports.hant = new chrono_1.Chrono(createCasualConfiguration());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse2(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse2;
    function parseDate2(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate2;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new ZHHantCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      const configuration = configurations_1.includeCommonConfiguration({
        parsers: [
          new ZHHantDateParser_1.default(),
          new ZHHantRelationWeekdayParser_1.default(),
          new ZHHantWeekdayParser_1.default(),
          new ZHHantTimeExpressionParser_1.default(),
          new ZHHantDeadlineFormatParser_1.default()
        ],
        refiners: [new ZHHantMergeDateRangeRefiner_1.default(), new ZHHantMergeDateTimeRefiner_1.default()]
      });
      configuration.refiners = configuration.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner_1.default));
      return configuration;
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansCasualDateParser.js
var require_ZHHansCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansCasualDateParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NOW_GROUP = 1;
    var DAY_GROUP_1 = 2;
    var TIME_GROUP_1 = 3;
    var TIME_GROUP_2 = 4;
    var DAY_GROUP_3 = 5;
    var TIME_GROUP_3 = 6;
    var ZHHansCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return new RegExp("(\u73B0\u5728|\u7ACB(?:\u523B|\u5373)|\u5373\u523B)|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s|,|\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?", "i");
      }
      innerExtract(context, match) {
        const index = match.index;
        const result = context.createParsingResult(index, match[0]);
        const refMoment = dayjs_1.default(context.refDate);
        let startMoment = refMoment;
        if (match[NOW_GROUP]) {
          result.start.imply("hour", refMoment.hour());
          result.start.imply("minute", refMoment.minute());
          result.start.imply("second", refMoment.second());
          result.start.imply("millisecond", refMoment.millisecond());
        } else if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          const time1 = match[TIME_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            startMoment = startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            startMoment = startMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            startMoment = startMoment.add(3, "day");
          }
          if (time1 == "\u65E9") {
            result.start.imply("hour", 6);
          } else if (time1 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          }
        } else if (match[TIME_GROUP_2]) {
          const timeString2 = match[TIME_GROUP_2];
          const time2 = timeString2[0];
          if (time2 == "\u65E9" || time2 == "\u4E0A") {
            result.start.imply("hour", 6);
          } else if (time2 == "\u4E0B") {
            result.start.imply("hour", 15);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u4E2D") {
            result.start.imply("hour", 12);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u591C" || time2 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u51CC") {
            result.start.imply("hour", 0);
          }
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day3 == "\u6628") {
            startMoment = startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            startMoment = startMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            startMoment = startMoment.add(3, "day");
          }
          const timeString3 = match[TIME_GROUP_3];
          if (timeString3) {
            const time3 = timeString3[0];
            if (time3 == "\u65E9" || time3 == "\u4E0A") {
              result.start.imply("hour", 6);
            } else if (time3 == "\u4E0B") {
              result.start.imply("hour", 15);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u4E2D") {
              result.start.imply("hour", 12);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u591C" || time3 == "\u665A") {
              result.start.imply("hour", 22);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u51CC") {
              result.start.imply("hour", 0);
            }
          }
        }
        result.start.assign("day", startMoment.date());
        result.start.assign("month", startMoment.month() + 1);
        result.start.assign("year", startMoment.year());
        return result;
      }
    };
    exports.default = ZHHansCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/constants.js
var require_constants8 = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zhStringToYear = exports.zhStringToNumber = exports.WEEKDAY_OFFSET = exports.NUMBER = void 0;
    exports.NUMBER = {
      "\u96F6": 0,
      "\u3007": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E24": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6,
      "\u4E03": 7,
      "\u516B": 8,
      "\u4E5D": 9,
      "\u5341": 10
    };
    exports.WEEKDAY_OFFSET = {
      "\u5929": 0,
      "\u65E5": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6
    };
    function zhStringToNumber(text) {
      let number = 0;
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (char === "\u5341") {
          number = number === 0 ? exports.NUMBER[char] : number * exports.NUMBER[char];
        } else {
          number += exports.NUMBER[char];
        }
      }
      return number;
    }
    exports.zhStringToNumber = zhStringToNumber;
    function zhStringToYear(text) {
      let string = "";
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        string = string + exports.NUMBER[char];
      }
      return parseInt(string);
    }
    exports.zhStringToYear = zhStringToYear;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDateParser.js
var require_ZHHansDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDateParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var YEAR_GROUP = 1;
    var MONTH_GROUP = 2;
    var DAY_GROUP = 3;
    var ZHHansDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp("(\\d{2,4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{2})?(?:\\s*)(?:\u5E74)?(?:[\\s|,|\uFF0C]*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,3})(?:\\s*)(?:\u6708)(?:\\s*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,3})?(?:\\s*)(?:\u65E5|\u53F7)?");
      }
      innerExtract(context, match) {
        const startMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        let month = parseInt(match[MONTH_GROUP]);
        if (isNaN(month))
          month = constants_1.zhStringToNumber(match[MONTH_GROUP]);
        result.start.assign("month", month);
        if (match[DAY_GROUP]) {
          let day = parseInt(match[DAY_GROUP]);
          if (isNaN(day))
            day = constants_1.zhStringToNumber(match[DAY_GROUP]);
          result.start.assign("day", day);
        } else {
          result.start.imply("day", startMoment.date());
        }
        if (match[YEAR_GROUP]) {
          let year = parseInt(match[YEAR_GROUP]);
          if (isNaN(year))
            year = constants_1.zhStringToYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.js
var require_ZHHansDeadlineFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+|\u534A|\u51E0)(?:\\s*)(?:\u4E2A)?(\u79D2(?:\u949F)?|\u5206\u949F|\u5C0F\u65F6|\u949F|\u65E5|\u5929|\u661F\u671F|\u793C\u62DC|\u6708|\u5E74)(?:(?:\u4E4B|\u8FC7)?\u540E|(?:\u4E4B)?\u5185)", "i");
    var NUMBER_GROUP = 1;
    var UNIT_GROUP = 2;
    var ZHHansDeadlineFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        let number = parseInt(match[NUMBER_GROUP]);
        if (isNaN(number)) {
          number = constants_1.zhStringToNumber(match[NUMBER_GROUP]);
        }
        if (isNaN(number)) {
          const string = match[NUMBER_GROUP];
          if (string === "\u51E0") {
            number = 3;
          } else if (string === "\u534A") {
            number = 0.5;
          } else {
            return null;
          }
        }
        let date = dayjs_1.default(context.refDate);
        const unit = match[UNIT_GROUP];
        const unitAbbr = unit[0];
        if (unitAbbr.match(/[日天星礼月年]/)) {
          if (unitAbbr == "\u65E5" || unitAbbr == "\u5929") {
            date = date.add(number, "d");
          } else if (unitAbbr == "\u661F" || unitAbbr == "\u793C") {
            date = date.add(number * 7, "d");
          } else if (unitAbbr == "\u6708") {
            date = date.add(number, "month");
          } else if (unitAbbr == "\u5E74") {
            date = date.add(number, "year");
          }
          result.start.assign("year", date.year());
          result.start.assign("month", date.month() + 1);
          result.start.assign("day", date.date());
          return result;
        }
        if (unitAbbr == "\u79D2") {
          date = date.add(number, "second");
        } else if (unitAbbr == "\u5206") {
          date = date.add(number, "minute");
        } else if (unitAbbr == "\u5C0F" || unitAbbr == "\u949F") {
          date = date.add(number, "hour");
        }
        result.start.imply("year", date.year());
        result.start.imply("month", date.month() + 1);
        result.start.imply("day", date.date());
        result.start.assign("hour", date.hour());
        result.start.assign("minute", date.minute());
        result.start.assign("second", date.second());
        return result;
      }
    };
    exports.default = ZHHansDeadlineFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.js
var require_ZHHansRelationWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(?<prefix>\u4E0A|\u4E0B|\u8FD9)(?:\u4E2A)?(?:\u661F\u671F|\u793C\u62DC|\u5468)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHansRelationWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset2 = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset2 === void 0)
          return null;
        let modifier = null;
        const prefix = match.groups.prefix;
        if (prefix == "\u4E0A") {
          modifier = "last";
        } else if (prefix == "\u4E0B") {
          modifier = "next";
        } else if (prefix == "\u8FD9") {
          modifier = "this";
        }
        let startMoment = dayjs_1.default(context.refDate);
        let startMomentFixed = false;
        const refOffset = startMoment.day();
        if (modifier == "last" || modifier == "past") {
          startMoment = startMoment.day(offset2 - 7);
          startMomentFixed = true;
        } else if (modifier == "next") {
          startMoment = startMoment.day(offset2 + 7);
          startMomentFixed = true;
        } else if (modifier == "this") {
          startMoment = startMoment.day(offset2);
        } else {
          if (Math.abs(offset2 - 7 - refOffset) < Math.abs(offset2 - refOffset)) {
            startMoment = startMoment.day(offset2 - 7);
          } else if (Math.abs(offset2 + 7 - refOffset) < Math.abs(offset2 - refOffset)) {
            startMoment = startMoment.day(offset2 + 7);
          } else {
            startMoment = startMoment.day(offset2);
          }
        }
        result.start.assign("weekday", offset2);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansRelationWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansTimeExpressionParser.js
var require_ZHHansTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansTimeExpressionParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var FIRST_REG_PATTERN = new RegExp("(?:\u4ECE|\u81EA)?(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u70B9|\u65F6|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var SECOND_REG_PATTERN = new RegExp("(?:^\\s*(?:\u5230|\u81F3|\\-|\\\u2013|\\~|\\\u301C)\\s*)(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u70B9|\u65F6|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var DAY_GROUP_1 = 1;
    var ZH_AM_PM_HOUR_GROUP_1 = 2;
    var ZH_AM_PM_HOUR_GROUP_2 = 3;
    var DAY_GROUP_3 = 4;
    var ZH_AM_PM_HOUR_GROUP_3 = 5;
    var HOUR_GROUP = 6;
    var MINUTE_GROUP = 7;
    var SECOND_GROUP = 8;
    var AM_PM_HOUR_GROUP = 9;
    var ZHHansTimeExpressionParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return FIRST_REG_PATTERN;
      }
      innerExtract(context, match) {
        if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
          return null;
        }
        const refMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        const startMoment = refMoment.clone();
        if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            startMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            startMoment.add(1, "day");
          } else if (day3 == "\u6628") {
            startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            startMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        let hour = 0;
        let minute = 0;
        let meridiem = -1;
        if (match[SECOND_GROUP]) {
          let second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.start.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          const zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          const zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          const zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.start.assign("hour", hour);
        result.start.assign("minute", minute);
        if (meridiem >= 0) {
          result.start.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            result.start.imply("meridiem", 0);
          } else {
            result.start.imply("meridiem", 1);
          }
        }
        match = SECOND_REG_PATTERN.exec(context.text.substring(result.index + result.text.length));
        if (!match) {
          if (result.text.match(/^\d+$/)) {
            return null;
          }
          return result;
        }
        const endMoment = startMoment.clone();
        result.end = context.createParsingComponents();
        if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              endMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            endMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            endMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            endMoment.add(1, "day");
          } else if (day3 == "\u6628") {
            endMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            endMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else {
          result.end.imply("day", endMoment.date());
          result.end.imply("month", endMoment.month() + 1);
          result.end.imply("year", endMoment.year());
        }
        hour = 0;
        minute = 0;
        meridiem = -1;
        if (match[SECOND_GROUP]) {
          let second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.end.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == 0) {
              result.start.imply("meridiem", 0);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", 1);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          const zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          const zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          const zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.text = result.text + match[0];
        result.end.assign("hour", hour);
        result.end.assign("minute", minute);
        if (meridiem >= 0) {
          result.end.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
          if (startAtPM && result.start.get("hour") > hour) {
            result.end.imply("meridiem", 0);
          } else if (hour > 12) {
            result.end.imply("meridiem", 1);
          }
        }
        if (result.end.date().getTime() < result.start.date().getTime()) {
          result.end.imply("day", result.end.get("day") + 1);
        }
        return result;
      }
    };
    exports.default = ZHHansTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansWeekdayParser.js
var require_ZHHansWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(?:\u661F\u671F|\u793C\u62DC|\u5468)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHansWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset2 = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset2 === void 0)
          return null;
        let startMoment = dayjs_1.default(context.refDate);
        const startMomentFixed = false;
        const refOffset = startMoment.day();
        if (Math.abs(offset2 - 7 - refOffset) < Math.abs(offset2 - refOffset)) {
          startMoment = startMoment.day(offset2 - 7);
        } else if (Math.abs(offset2 + 7 - refOffset) < Math.abs(offset2 - refOffset)) {
          startMoment = startMoment.day(offset2 + 7);
        } else {
          startMoment = startMoment.day(offset2);
        }
        result.start.assign("weekday", offset2);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.js
var require_ZHHansMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var ZHHansMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(至|到|-|~|～|－|ー)\s*$/i;
      }
    };
    exports.default = ZHHansMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.js
var require_ZHHansMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var ZHHansMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return /^\s*$/i;
      }
    };
    exports.default = ZHHansMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/index.js
var require_hans = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = exports.hans = void 0;
    var chrono_1 = require_chrono();
    var ExtractTimezoneOffsetRefiner_1 = __importDefault(require_ExtractTimezoneOffsetRefiner());
    var configurations_1 = require_configurations();
    var ZHHansCasualDateParser_1 = __importDefault(require_ZHHansCasualDateParser());
    var ZHHansDateParser_1 = __importDefault(require_ZHHansDateParser());
    var ZHHansDeadlineFormatParser_1 = __importDefault(require_ZHHansDeadlineFormatParser());
    var ZHHansRelationWeekdayParser_1 = __importDefault(require_ZHHansRelationWeekdayParser());
    var ZHHansTimeExpressionParser_1 = __importDefault(require_ZHHansTimeExpressionParser());
    var ZHHansWeekdayParser_1 = __importDefault(require_ZHHansWeekdayParser());
    var ZHHansMergeDateRangeRefiner_1 = __importDefault(require_ZHHansMergeDateRangeRefiner());
    var ZHHansMergeDateTimeRefiner_1 = __importDefault(require_ZHHansMergeDateTimeRefiner());
    exports.hans = new chrono_1.Chrono(createCasualConfiguration());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse2(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse2;
    function parseDate2(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate2;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new ZHHansCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      const configuration = configurations_1.includeCommonConfiguration({
        parsers: [
          new ZHHansDateParser_1.default(),
          new ZHHansRelationWeekdayParser_1.default(),
          new ZHHansWeekdayParser_1.default(),
          new ZHHansTimeExpressionParser_1.default(),
          new ZHHansDeadlineFormatParser_1.default()
        ],
        refiners: [new ZHHansMergeDateRangeRefiner_1.default(), new ZHHansMergeDateTimeRefiner_1.default()]
      });
      configuration.refiners = configuration.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner_1.default));
      return configuration;
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/index.js
var require_zh = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hans = void 0;
    __exportStar(require_hant(), exports);
    exports.hans = __importStar(require_hans());
  }
});

// node_modules/chrono-node/dist/locales/ru/constants.js
var require_constants9 = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.FULL_MONTH_NAME_DICTIONARY = exports.WEEKDAY_DICTIONARY = exports.REGEX_PARTS = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.REGEX_PARTS = {
      leftBoundary: "([^\\p{L}\\p{N}_]|^)",
      rightBoundary: "(?=[^\\p{L}\\p{N}_]|$)",
      flags: "iu"
    };
    exports.WEEKDAY_DICTIONARY = {
      \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435: 0,
      \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u044F: 0,
      \u0432\u0441\u043A: 0,
      "\u0432\u0441\u043A.": 0,
      \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A: 1,
      \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A\u0430: 1,
      \u043F\u043D: 1,
      "\u043F\u043D.": 1,
      \u0432\u0442\u043E\u0440\u043D\u0438\u043A: 2,
      \u0432\u0442\u043E\u0440\u043D\u0438\u043A\u0430: 2,
      \u0432\u0442: 2,
      "\u0432\u0442.": 2,
      \u0441\u0440\u0435\u0434\u0430: 3,
      \u0441\u0440\u0435\u0434\u044B: 3,
      \u0441\u0440\u0435\u0434\u0443: 3,
      \u0441\u0440: 3,
      "\u0441\u0440.": 3,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0433: 4,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0433\u0430: 4,
      \u0447\u0442: 4,
      "\u0447\u0442.": 4,
      \u043F\u044F\u0442\u043D\u0438\u0446\u0430: 5,
      \u043F\u044F\u0442\u043D\u0438\u0446\u0443: 5,
      \u043F\u044F\u0442\u043D\u0438\u0446\u044B: 5,
      \u043F\u0442: 5,
      "\u043F\u0442.": 5,
      \u0441\u0443\u0431\u0431\u043E\u0442\u0430: 6,
      \u0441\u0443\u0431\u0431\u043E\u0442\u0443: 6,
      \u0441\u0443\u0431\u0431\u043E\u0442\u044B: 6,
      \u0441\u0431: 6,
      "\u0441\u0431.": 6
    };
    exports.FULL_MONTH_NAME_DICTIONARY = {
      \u044F\u043D\u0432\u0430\u0440\u044C: 1,
      \u044F\u043D\u0432\u0430\u0440\u044F: 1,
      \u044F\u043D\u0432\u0430\u0440\u0435: 1,
      \u0444\u0435\u0432\u0440\u044F\u043B\u044C: 2,
      \u0444\u0435\u0432\u0440\u044F\u043B\u044F: 2,
      \u0444\u0435\u0432\u0440\u044F\u043B\u0435: 2,
      \u043C\u0430\u0440\u0442: 3,
      \u043C\u0430\u0440\u0442\u0430: 3,
      \u043C\u0430\u0440\u0442\u0435: 3,
      \u0430\u043F\u0440\u0435\u043B\u044C: 4,
      \u0430\u043F\u0440\u0435\u043B\u044F: 4,
      \u0430\u043F\u0440\u0435\u043B\u0435: 4,
      \u043C\u0430\u0439: 5,
      \u043C\u0430\u044F: 5,
      \u043C\u0430\u0435: 5,
      \u0438\u044E\u043D\u044C: 6,
      \u0438\u044E\u043D\u044F: 6,
      \u0438\u044E\u043D\u0435: 6,
      \u0438\u044E\u043B\u044C: 7,
      \u0438\u044E\u043B\u044F: 7,
      \u0438\u044E\u043B\u0435: 7,
      \u0430\u0432\u0433\u0443\u0441\u0442: 8,
      \u0430\u0432\u0433\u0443\u0441\u0442\u0430: 8,
      \u0430\u0432\u0433\u0443\u0441\u0442\u0435: 8,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044C: 9,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044F: 9,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u0435: 9,
      \u043E\u043A\u0442\u044F\u0431\u0440\u044C: 10,
      \u043E\u043A\u0442\u044F\u0431\u0440\u044F: 10,
      \u043E\u043A\u0442\u044F\u0431\u0440\u0435: 10,
      \u043D\u043E\u044F\u0431\u0440\u044C: 11,
      \u043D\u043E\u044F\u0431\u0440\u044F: 11,
      \u043D\u043E\u044F\u0431\u0440\u0435: 11,
      \u0434\u0435\u043A\u0430\u0431\u0440\u044C: 12,
      \u0434\u0435\u043A\u0430\u0431\u0440\u044F: 12,
      \u0434\u0435\u043A\u0430\u0431\u0440\u0435: 12
    };
    exports.MONTH_DICTIONARY = Object.assign(Object.assign({}, exports.FULL_MONTH_NAME_DICTIONARY), { \u044F\u043D\u0432: 1, "\u044F\u043D\u0432.": 1, \u0444\u0435\u0432: 2, "\u0444\u0435\u0432.": 2, \u043C\u0430\u0440: 3, "\u043C\u0430\u0440.": 3, \u0430\u043F\u0440: 4, "\u0430\u043F\u0440.": 4, \u0430\u0432\u0433: 8, "\u0430\u0432\u0433.": 8, \u0441\u0435\u043D: 9, "\u0441\u0435\u043D.": 9, \u043E\u043A\u0442: 10, "\u043E\u043A\u0442.": 10, \u043D\u043E\u044F: 11, "\u043D\u043E\u044F.": 11, \u0434\u0435\u043A: 12, "\u0434\u0435\u043A.": 12 });
    exports.INTEGER_WORD_DICTIONARY = {
      \u043E\u0434\u0438\u043D: 1,
      \u043E\u0434\u043D\u0430: 1,
      \u043E\u0434\u043D\u043E\u0439: 1,
      \u043E\u0434\u043D\u0443: 1,
      \u0434\u0432\u0435: 2,
      \u0434\u0432\u0430: 2,
      \u0434\u0432\u0443\u0445: 2,
      \u0442\u0440\u0438: 3,
      \u0442\u0440\u0435\u0445: 3,
      \u0442\u0440\u0451\u0445: 3,
      \u0447\u0435\u0442\u044B\u0440\u0435: 4,
      \u0447\u0435\u0442\u044B\u0440\u0435\u0445: 4,
      \u0447\u0435\u0442\u044B\u0440\u0451\u0445: 4,
      \u043F\u044F\u0442\u044C: 5,
      \u043F\u044F\u0442\u0438: 5,
      \u0448\u0435\u0441\u0442\u044C: 6,
      \u0448\u0435\u0441\u0442\u0438: 6,
      \u0441\u0435\u043C\u044C: 7,
      \u0441\u0435\u043C\u0438: 7,
      \u0432\u043E\u0441\u0435\u043C\u044C: 8,
      \u0432\u043E\u0441\u0435\u043C\u044C\u043C\u0438: 8,
      \u0434\u0435\u0432\u044F\u0442\u044C: 9,
      \u0434\u0435\u0432\u044F\u0442\u0438: 9,
      \u0434\u0435\u0441\u044F\u0442\u044C: 10,
      \u0434\u0435\u0441\u044F\u0442\u0438: 10,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u044C: 11,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u0438: 11,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u044C: 12,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u0438: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      \u043F\u0435\u0440\u0432\u043E\u0435: 1,
      \u043F\u0435\u0440\u0432\u043E\u0433\u043E: 1,
      \u0432\u0442\u043E\u0440\u043E\u0435: 2,
      \u0432\u0442\u043E\u0440\u043E\u0433\u043E: 2,
      \u0442\u0440\u0435\u0442\u044C\u0435: 3,
      \u0442\u0440\u0435\u0442\u044C\u0435\u0433\u043E: 3,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0435: 4,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E: 4,
      \u043F\u044F\u0442\u043E\u0435: 5,
      \u043F\u044F\u0442\u043E\u0433\u043E: 5,
      \u0448\u0435\u0441\u0442\u043E\u0435: 6,
      \u0448\u0435\u0441\u0442\u043E\u0433\u043E: 6,
      \u0441\u0435\u0434\u044C\u043C\u043E\u0435: 7,
      \u0441\u0435\u0434\u044C\u043C\u043E\u0433\u043E: 7,
      \u0432\u043E\u0441\u044C\u043C\u043E\u0435: 8,
      \u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E: 8,
      \u0434\u0435\u0432\u044F\u0442\u043E\u0435: 9,
      \u0434\u0435\u0432\u044F\u0442\u043E\u0433\u043E: 9,
      \u0434\u0435\u0441\u044F\u0442\u043E\u0435: 10,
      \u0434\u0435\u0441\u044F\u0442\u043E\u0433\u043E: 10,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 11,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 11,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 12,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 12,
      \u0442\u0440\u0438\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 13,
      \u0442\u0440\u0438\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 13,
      \u0447\u0435\u0442\u044B\u0440\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 14,
      \u0447\u0435\u0442\u044B\u0440\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 14,
      \u043F\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 15,
      \u043F\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 15,
      \u0448\u0435\u0441\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 16,
      \u0448\u0435\u0441\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 16,
      \u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 17,
      \u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 17,
      \u0432\u043E\u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 18,
      \u0432\u043E\u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 18,
      \u0434\u0435\u0432\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 19,
      \u0434\u0435\u0432\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 19,
      \u0434\u0432\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 20,
      \u0434\u0432\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 20,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0435": 21,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0433\u043E": 21,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u0442\u043E\u0440\u043E\u0435": 22,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u0442\u043E\u0440\u043E\u0433\u043E": 22,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0442\u0440\u0435\u0442\u044C\u0435": 23,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0442\u0440\u0435\u0442\u044C\u0435\u0433\u043E": 23,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0435": 24,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E": 24,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u044F\u0442\u043E\u0435": 25,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u044F\u0442\u043E\u0433\u043E": 25,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0448\u0435\u0441\u0442\u043E\u0435": 26,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0448\u0435\u0441\u0442\u043E\u0433\u043E": 26,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0441\u0435\u0434\u044C\u043C\u043E\u0435": 27,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0441\u0435\u0434\u044C\u043C\u043E\u0433\u043E": 27,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u043E\u0435": 28,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E": 28,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0434\u0435\u0432\u044F\u0442\u043E\u0435": 29,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0434\u0435\u0432\u044F\u0442\u043E\u0433\u043E": 29,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u043E\u0435": 30,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u043E\u0433\u043E": 30,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0435": 31,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0433\u043E": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      \u0441\u0435\u043A: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u0430: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u044B: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u0443: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0430: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0438: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u0435\u043A: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0443: "second",
      \u043C\u0438\u043D: "minute",
      \u043C\u0438\u043D\u0443\u0442\u0430: "minute",
      \u043C\u0438\u043D\u0443\u0442: "minute",
      \u043C\u0438\u043D\u0443\u0442\u044B: "minute",
      \u043C\u0438\u043D\u0443\u0442\u0443: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043E\u043A: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043A\u0438: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043A\u0443: "minute",
      \u0447\u0430\u0441: "hour",
      \u0447\u0430\u0441\u043E\u0432: "hour",
      \u0447\u0430\u0441\u0430: "hour",
      \u0447\u0430\u0441\u0443: "hour",
      \u0447\u0430\u0441\u0438\u043A\u043E\u0432: "hour",
      \u0447\u0430\u0441\u0438\u043A\u0430: "hour",
      \u0447\u0430\u0441\u0438\u043A\u0435: "hour",
      \u0447\u0430\u0441\u0438\u043A: "hour",
      \u0434\u0435\u043D\u044C: "d",
      \u0434\u043D\u044F: "d",
      \u0434\u043D\u0435\u0439: "d",
      \u0441\u0443\u0442\u043E\u043A: "d",
      \u0441\u0443\u0442\u043A\u0438: "d",
      \u043D\u0435\u0434\u0435\u043B\u044F: "week",
      \u043D\u0435\u0434\u0435\u043B\u0435: "week",
      \u043D\u0435\u0434\u0435\u043B\u0438: "week",
      \u043D\u0435\u0434\u0435\u043B\u044E: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C\u043A\u0435: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C\u043A\u0438: "week",
      \u043D\u0435\u0434\u0435\u043B\u0435\u043A: "week",
      \u043C\u0435\u0441\u044F\u0446: "month",
      \u043C\u0435\u0441\u044F\u0446\u0435: "month",
      \u043C\u0435\u0441\u044F\u0446\u0435\u0432: "month",
      \u043C\u0435\u0441\u044F\u0446\u0430: "month",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B: "quarter",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u0435: "quarter",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u043E\u0432: "quarter",
      \u0433\u043E\u0434: "year",
      \u0433\u043E\u0434\u0430: "year",
      \u0433\u043E\u0434\u0443: "year",
      \u0433\u043E\u0434\u043E\u0432: "year",
      \u043B\u0435\u0442: "year",
      \u0433\u043E\u0434\u0438\u043A: "year",
      \u0433\u043E\u0434\u0438\u043A\u0430: "year",
      \u0433\u043E\u0434\u0438\u043A\u043E\u0432: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|\u043F\u043E\u043B|\u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E|\u043F\u0430\u0440(?:\u044B|\u0443)|\\s{0,3})`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      }
      if (num.match(/несколько/)) {
        return 3;
      } else if (num.match(/пол/)) {
        return 0.5;
      } else if (num.match(/пар/)) {
        return 2;
      } else if (num === "") {
        return 1;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:\u0433\u043E|\u043E\u0433\u043E|\u0435|\u043E\u0435)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:st|nd|rd|th)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    var year = "(?:\\s+(?:\u0433\u043E\u0434\u0443|\u0433\u043E\u0434\u0430|\u0433\u043E\u0434|\u0433|\u0433.))?";
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}${year}\\s*(?:\u043D.\u044D.|\u0434\u043E \u043D.\u044D.|\u043D. \u044D.|\u0434\u043E \u043D. \u044D.)|[1-2][0-9]{3}${year}|[5-9][0-9]${year})`;
    function parseYear(match) {
      if (/(год|года|г|г.)/i.test(match)) {
        match = match.replace(/(год|года|г|г.)/i, "");
      }
      if (/(до н.э.|до н. э.)/i.test(match)) {
        match = match.replace(/(до н.э.|до н. э.)/i, "");
        return -parseInt(match);
      }
      if (/(н. э.|н.э.)/i.test(match)) {
        match = match.replace(/(н. э.|н.э.)/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,3}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:\u043E\u043A\u043E\u043B\u043E|\u043F\u0440\u0438\u043C\u0435\u0440\u043D\u043E)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length).trim();
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitWithinFormatParser.js
var require_RUTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = `(?:(?:\u043E\u043A\u043E\u043B\u043E|\u043F\u0440\u0438\u043C\u0435\u0440\u043D\u043E)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})${constants_1.REGEX_PARTS.rightBoundary}`;
    var PATTERN_WITH_PREFIX = new RegExp(`(?:\u0432 \u0442\u0435\u0447\u0435\u043D\u0438\u0435|\u0432 \u0442\u0435\u0447\u0435\u043D\u0438\u0438)\\s*${PATTERN}`, constants_1.REGEX_PARTS.flags);
    var PATTERN_WITHOUT_PREFIX = new RegExp(PATTERN, "i");
    var RUTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern(context) {
        return context.option.forwardDate ? PATTERN_WITHOUT_PREFIX : PATTERN_WITH_PREFIX;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = RUTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameLittleEndianParser.js
var require_RUMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants9();
    var constants_2 = require_constants9();
    var constants_3 = require_constants9();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:\u0441)?\\s*(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:\u043F\u043E|-|\u2013|\u0434\u043E)?\\s{0,3}(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|\\/|\\s{0,3}(?:of)?\\s{0,3})(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|\\/|,?\\s{0,3})(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var RUMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = RUMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameParser.js
var require_RUMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants9();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`((?:\u0432)\\s*)?(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, constants_1.REGEX_PARTS.flags);
    var MONTH_NAME_GROUP = 2;
    var YEAR_GROUP = 3;
    var RUMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const monthName = match[MONTH_NAME_GROUP].toLowerCase();
        if (match[0].length <= 3 && !constants_1.FULL_MONTH_NAME_DICTIONARY[monthName]) {
          return null;
        }
        const result = context.createParsingResult(match.index, match.index + match[0].length);
        result.start.imply("day", 1);
        const month = constants_1.MONTH_DICTIONARY[monthName];
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, 1, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = RUMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeExpressionParser.js
var require_RUTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var constants_1 = require_constants9();
    var RUTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      constructor(strictMode) {
        super(strictMode);
      }
      patternFlags() {
        return constants_1.REGEX_PARTS.flags;
      }
      primaryPatternLeftBoundary() {
        return `(^|\\s|T|(?:[^\\p{L}\\p{N}_]))`;
      }
      followingPhase() {
        return `\\s*(?:\\-|\\\u2013|\\~|\\\u301C|\u0434\u043E|\u0438|\u043F\u043E|\\?)\\s*`;
      }
      primaryPrefix() {
        return `(?:(?:\u0432|\u0441)\\s*)??`;
      }
      primarySuffix() {
        return `(?:\\s*(?:\u0443\u0442\u0440\u0430|\u0432\u0435\u0447\u0435\u0440\u0430|\u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u043B\u0443\u0434\u043D\u044F))?(?!\\/)${constants_1.REGEX_PARTS.rightBoundary}`;
      }
      extractPrimaryTimeComponents(context, match) {
        const components = super.extractPrimaryTimeComponents(context, match);
        if (components) {
          if (match[0].endsWith("\u0432\u0435\u0447\u0435\u0440\u0430")) {
            const hour = components.get("hour");
            if (hour >= 6 && hour < 12) {
              components.assign("hour", components.get("hour") + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            } else if (hour < 6) {
              components.assign("meridiem", index_1.Meridiem.AM);
            }
          }
          if (match[0].endsWith("\u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u043B\u0443\u0434\u043D\u044F")) {
            components.assign("meridiem", index_1.Meridiem.PM);
            const hour = components.get("hour");
            if (hour >= 0 && hour <= 6) {
              components.assign("hour", components.get("hour") + 12);
            }
          }
          if (match[0].endsWith("\u0443\u0442\u0440\u0430")) {
            components.assign("meridiem", index_1.Meridiem.AM);
            const hour = components.get("hour");
            if (hour < 12) {
              components.assign("hour", components.get("hour"));
            }
          }
        }
        return components;
      }
    };
    exports.default = RUTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitAgoFormatParser.js
var require_RUTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}\u043D\u0430\u0437\u0430\u0434(?=(?:\\W|$))`, constants_1.REGEX_PARTS.flags);
    var RUTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = RUTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateRangeRefiner.js
var require_RUMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var xf = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(и до|и по|до|по|-)\s*$/i;
      }
    };
    exports.default = xf;
  }
});

// node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateTimeRefiner.js
var require_RUMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var RUMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp(`^\\s*(T|\u0432|,|-)?\\s*$`);
      }
    };
    exports.default = RUMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUCasualDateParser.js
var require_RUCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar(require_casualReferences());
    var constants_1 = require_constants9();
    var PATTERN = new RegExp(`(?:\u0441|\u0441\u043E)?\\s*(\u0441\u0435\u0433\u043E\u0434\u043D\u044F|\u0432\u0447\u0435\u0440\u0430|\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern(context) {
        return PATTERN;
      }
      innerExtract(context, match) {
        const lowerText = match[1].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "\u0441\u0435\u0433\u043E\u0434\u043D\u044F":
            return references.today(context.reference);
          case "\u0432\u0447\u0435\u0440\u0430":
            return references.yesterday(context.reference);
          case "\u0437\u0430\u0432\u0442\u0440\u0430":
            return references.tomorrow(context.reference);
          case "\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430":
            return references.theDayAfter(context.reference, 2);
          case "\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430":
            return references.theDayBefore(context.reference, 2);
        }
        return component;
      }
    };
    exports.default = RUCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUCasualTimeParser.js
var require_RUCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUCasualTimeParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar(require_casualReferences());
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault(require_dayjs_min());
    var constants_1 = require_constants9();
    var PATTERN = new RegExp(`(\u0441\u0435\u0439\u0447\u0430\u0441|\u043F\u0440\u043E\u0448\u043B\u044B\u043C\\s*\u0432\u0435\u0447\u0435\u0440\u043E\u043C|\u043F\u0440\u043E\u0448\u043B\u043E\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u0441\u0435\u0433\u043E\u0434\u043D\u044F\\s*\u043D\u043E\u0447\u044C\u044E|\u044D\u0442\u043E\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u043D\u043E\u0447\u044C\u044E|\u044D\u0442\u0438\u043C \u0443\u0442\u0440\u043E\u043C|\u0443\u0442\u0440\u043E\u043C|\u0443\u0442\u0440\u0430|\u0432\\s*\u043F\u043E\u043B\u0434\u0435\u043D\u044C|\u0432\u0435\u0447\u0435\u0440\u043E\u043C|\u0432\u0435\u0447\u0435\u0440\u0430|\u0432\\s*\u043F\u043E\u043B\u043D\u043E\u0447\u044C)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_2.default(context.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        if (lowerText === "\u0441\u0435\u0439\u0447\u0430\u0441") {
          return references.now(context.reference);
        }
        if (lowerText === "\u0432\u0435\u0447\u0435\u0440\u043E\u043C" || lowerText === "\u0432\u0435\u0447\u0435\u0440\u0430") {
          return references.evening(context.reference);
        }
        if (lowerText.endsWith("\u0443\u0442\u0440\u043E\u043C") || lowerText.endsWith("\u0443\u0442\u0440\u0430")) {
          return references.morning(context.reference);
        }
        if (lowerText.match(/в\s*полдень/)) {
          return references.noon(context.reference);
        }
        if (lowerText.match(/прошлой\s*ночью/)) {
          return references.lastNight(context.reference);
        }
        if (lowerText.match(/прошлым\s*вечером/)) {
          return references.yesterdayEvening(context.reference);
        }
        if (lowerText.match(/следующей\s*ночью/)) {
          const daysToAdd = targetDate.hour() < 22 ? 1 : 2;
          targetDate = targetDate.add(daysToAdd, "day");
          dayjs_1.assignSimilarDate(component, targetDate);
          component.imply("hour", 0);
        }
        if (lowerText.match(/в\s*полночь/) || lowerText.endsWith("\u043D\u043E\u0447\u044C\u044E")) {
          return references.midnight(context.reference);
        }
        return component;
      }
    };
    exports.default = RUCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUWeekdayParser.js
var require_RUWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:,|\\(|\uFF08)\\s*)?(?:\u0432\\s*?)?(?:(\u044D\u0442\u0443|\u044D\u0442\u043E\u0442|\u043F\u0440\u043E\u0448\u043B\u044B\u0439|\u043F\u0440\u043E\u0448\u043B\u0443\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:,|\\)|\uFF09))?(?:\\s*\u043D\u0430\\s*(\u044D\u0442\u043E\u0439|\u043F\u0440\u043E\u0448\u043B\u043E\u0439|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439)\\s*\u043D\u0435\u0434\u0435\u043B\u0435)?${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var RUWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset2 = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "\u043F\u0440\u043E\u0448\u043B\u044B\u0439" || modifierWord == "\u043F\u0440\u043E\u0448\u043B\u0443\u044E" || modifierWord == "\u043F\u0440\u043E\u0448\u043B\u043E\u0439") {
          modifier = "last";
        } else if (modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E") {
          modifier = "next";
        } else if (modifierWord == "\u044D\u0442\u043E\u0442" || modifierWord == "\u044D\u0442\u0443" || modifierWord == "\u044D\u0442\u043E\u0439") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset2, modifier);
        return context.createParsingComponents().assign("weekday", offset2).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = RUWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RURelativeDateFormatParser.js
var require_RURelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RURelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C|\u043D\u0430 \u043F\u0440\u043E\u0448\u043B\u043E\u0439|\u043D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439|\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C|\u043D\u0430 \u044D\u0442\u043E\u0439|\u0432 \u044D\u0442\u043E\u043C)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var RURelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "\u043D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439" || modifier == "\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C") {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        if (modifier == "\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C" || modifier == "\u043D\u0430 \u043F\u0440\u043E\u0448\u043B\u043E\u0439") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        const components = context.createParsingComponents();
        let date = dayjs_1.default(context.reference.instant);
        if (timeunit.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (timeunit.match(/month/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (timeunit.match(/year/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = RURelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.js
var require_RUTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(\u044D\u0442\u0438|\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435|\u043F\u0440\u043E\u0448\u043B\u044B\u0435|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0435|\u043F\u043E\u0441\u043B\u0435|\u0447\u0435\u0440\u0435\u0437|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435":
          case "\u043F\u0440\u043E\u0448\u043B\u044B\u0435":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = RUTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/index.js
var require_ru = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var RUTimeUnitWithinFormatParser_1 = __importDefault(require_RUTimeUnitWithinFormatParser());
    var RUMonthNameLittleEndianParser_1 = __importDefault(require_RUMonthNameLittleEndianParser());
    var RUMonthNameParser_1 = __importDefault(require_RUMonthNameParser());
    var RUTimeExpressionParser_1 = __importDefault(require_RUTimeExpressionParser());
    var RUTimeUnitAgoFormatParser_1 = __importDefault(require_RUTimeUnitAgoFormatParser());
    var RUMergeDateRangeRefiner_1 = __importDefault(require_RUMergeDateRangeRefiner());
    var RUMergeDateTimeRefiner_1 = __importDefault(require_RUMergeDateTimeRefiner());
    var configurations_1 = require_configurations();
    var RUCasualDateParser_1 = __importDefault(require_RUCasualDateParser());
    var RUCasualTimeParser_1 = __importDefault(require_RUCasualTimeParser());
    var RUWeekdayParser_1 = __importDefault(require_RUWeekdayParser());
    var RURelativeDateFormatParser_1 = __importDefault(require_RURelativeDateFormatParser());
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var RUTimeUnitCasualRelativeFormatParser_1 = __importDefault(require_RUTimeUnitCasualRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse2(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse2;
    function parseDate2(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate2;
    function createCasualConfiguration() {
      const option = createConfiguration(false);
      option.parsers.unshift(new RUCasualDateParser_1.default());
      option.parsers.unshift(new RUCasualTimeParser_1.default());
      option.parsers.unshift(new RUMonthNameParser_1.default());
      option.parsers.unshift(new RURelativeDateFormatParser_1.default());
      option.parsers.unshift(new RUTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(true),
          new RUTimeUnitWithinFormatParser_1.default(),
          new RUMonthNameLittleEndianParser_1.default(),
          new RUWeekdayParser_1.default(),
          new RUTimeExpressionParser_1.default(strictMode),
          new RUTimeUnitAgoFormatParser_1.default()
        ],
        refiners: [new RUMergeDateTimeRefiner_1.default(), new RUMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/index.js
var require_dist = __commonJS({
  "node_modules/chrono-node/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseDate = exports.parse = exports.casual = exports.strict = exports.ru = exports.zh = exports.nl = exports.pt = exports.ja = exports.fr = exports.de = exports.Meridiem = exports.Chrono = exports.en = void 0;
    var en = __importStar(require_en());
    exports.en = en;
    var chrono_1 = require_chrono();
    Object.defineProperty(exports, "Chrono", { enumerable: true, get: function() {
      return chrono_1.Chrono;
    } });
    var Meridiem;
    (function(Meridiem2) {
      Meridiem2[Meridiem2["AM"] = 0] = "AM";
      Meridiem2[Meridiem2["PM"] = 1] = "PM";
    })(Meridiem = exports.Meridiem || (exports.Meridiem = {}));
    var de = __importStar(require_de());
    exports.de = de;
    var fr = __importStar(require_fr());
    exports.fr = fr;
    var ja = __importStar(require_ja());
    exports.ja = ja;
    var pt = __importStar(require_pt());
    exports.pt = pt;
    var nl = __importStar(require_nl());
    exports.nl = nl;
    var zh = __importStar(require_zh());
    exports.zh = zh;
    var ru = __importStar(require_ru());
    exports.ru = ru;
    exports.strict = en.strict;
    exports.casual = en.casual;
    function parse2(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse2;
    function parseDate2(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate2;
  }
});

// node_modules/eventemitter2/lib/eventemitter2.js
var require_eventemitter2 = __commonJS({
  "node_modules/eventemitter2/lib/eventemitter2.js"(exports, module2) {
    !function(undefined2) {
      var hasOwnProperty = Object.hasOwnProperty;
      var isArray2 = Array.isArray ? Array.isArray : function _isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      var defaultMaxListeners = 10;
      var nextTickSupported = typeof process == "object" && typeof process.nextTick == "function";
      var symbolsSupported = typeof Symbol === "function";
      var reflectSupported = typeof Reflect === "object";
      var setImmediateSupported = typeof setImmediate === "function";
      var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;
      var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === "function" ? Reflect.ownKeys : function(obj) {
        var arr = Object.getOwnPropertyNames(obj);
        arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
        return arr;
      } : Object.keys;
      function init() {
        this._events = {};
        if (this._conf) {
          configure.call(this, this._conf);
        }
      }
      function configure(conf) {
        if (conf) {
          this._conf = conf;
          conf.delimiter && (this.delimiter = conf.delimiter);
          if (conf.maxListeners !== undefined2) {
            this._maxListeners = conf.maxListeners;
          }
          conf.wildcard && (this.wildcard = conf.wildcard);
          conf.newListener && (this._newListener = conf.newListener);
          conf.removeListener && (this._removeListener = conf.removeListener);
          conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
          conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);
          if (this.wildcard) {
            this.listenerTree = {};
          }
        }
      }
      function logPossibleMemoryLeak(count, eventName) {
        var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count + " listeners added. Use emitter.setMaxListeners() to increase limit.";
        if (this.verboseMemoryLeak) {
          errorMsg += " Event name: " + eventName + ".";
        }
        if (typeof process !== "undefined" && process.emitWarning) {
          var e = new Error(errorMsg);
          e.name = "MaxListenersExceededWarning";
          e.emitter = this;
          e.count = count;
          process.emitWarning(e);
        } else {
          console.error(errorMsg);
          if (console.trace) {
            console.trace();
          }
        }
      }
      var toArray2 = function(a, b, c) {
        var n = arguments.length;
        switch (n) {
          case 0:
            return [];
          case 1:
            return [a];
          case 2:
            return [a, b];
          case 3:
            return [a, b, c];
          default:
            var arr = new Array(n);
            while (n--) {
              arr[n] = arguments[n];
            }
            return arr;
        }
      };
      function toObject(keys, values) {
        var obj = {};
        var key;
        var len = keys.length;
        var valuesCount = values ? values.length : 0;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          obj[key] = i < valuesCount ? values[i] : undefined2;
        }
        return obj;
      }
      function TargetObserver(emitter, target, options) {
        this._emitter = emitter;
        this._target = target;
        this._listeners = {};
        this._listenersCount = 0;
        var on, off;
        if (options.on || options.off) {
          on = options.on;
          off = options.off;
        }
        if (target.addEventListener) {
          on = target.addEventListener;
          off = target.removeEventListener;
        } else if (target.addListener) {
          on = target.addListener;
          off = target.removeListener;
        } else if (target.on) {
          on = target.on;
          off = target.off;
        }
        if (!on && !off) {
          throw Error("target does not implement any known event API");
        }
        if (typeof on !== "function") {
          throw TypeError("on method must be a function");
        }
        if (typeof off !== "function") {
          throw TypeError("off method must be a function");
        }
        this._on = on;
        this._off = off;
        var _observers = emitter._observers;
        if (_observers) {
          _observers.push(this);
        } else {
          emitter._observers = [this];
        }
      }
      Object.assign(TargetObserver.prototype, {
        subscribe: function(event, localEvent, reducer) {
          var observer = this;
          var target = this._target;
          var emitter = this._emitter;
          var listeners = this._listeners;
          var handler = function() {
            var args = toArray2.apply(null, arguments);
            var eventObj = {
              data: args,
              name: localEvent,
              original: event
            };
            if (reducer) {
              var result = reducer.call(target, eventObj);
              if (result !== false) {
                emitter.emit.apply(emitter, [eventObj.name].concat(args));
              }
              return;
            }
            emitter.emit.apply(emitter, [localEvent].concat(args));
          };
          if (listeners[event]) {
            throw Error("Event '" + event + "' is already listening");
          }
          this._listenersCount++;
          if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {
            this._onNewListener = function(_event) {
              if (_event === localEvent && listeners[event] === null) {
                listeners[event] = handler;
                observer._on.call(target, event, handler);
              }
            };
            emitter.on("newListener", this._onNewListener);
            this._onRemoveListener = function(_event) {
              if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {
                listeners[event] = null;
                observer._off.call(target, event, handler);
              }
            };
            listeners[event] = null;
            emitter.on("removeListener", this._onRemoveListener);
          } else {
            listeners[event] = handler;
            observer._on.call(target, event, handler);
          }
        },
        unsubscribe: function(event) {
          var observer = this;
          var listeners = this._listeners;
          var emitter = this._emitter;
          var handler;
          var events;
          var off = this._off;
          var target = this._target;
          var i;
          if (event && typeof event !== "string") {
            throw TypeError("event must be a string");
          }
          function clearRefs() {
            if (observer._onNewListener) {
              emitter.off("newListener", observer._onNewListener);
              emitter.off("removeListener", observer._onRemoveListener);
              observer._onNewListener = null;
              observer._onRemoveListener = null;
            }
            var index = findTargetIndex.call(emitter, observer);
            emitter._observers.splice(index, 1);
          }
          if (event) {
            handler = listeners[event];
            if (!handler)
              return;
            off.call(target, event, handler);
            delete listeners[event];
            if (!--this._listenersCount) {
              clearRefs();
            }
          } else {
            events = ownKeys(listeners);
            i = events.length;
            while (i-- > 0) {
              event = events[i];
              off.call(target, event, listeners[event]);
            }
            this._listeners = {};
            this._listenersCount = 0;
            clearRefs();
          }
        }
      });
      function resolveOptions(options, schema, reducers, allowUnknown) {
        var computedOptions = Object.assign({}, schema);
        if (!options)
          return computedOptions;
        if (typeof options !== "object") {
          throw TypeError("options must be an object");
        }
        var keys = Object.keys(options);
        var length = keys.length;
        var option, value;
        var reducer;
        function reject(reason) {
          throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
        }
        for (var i = 0; i < length; i++) {
          option = keys[i];
          if (!allowUnknown && !hasOwnProperty.call(schema, option)) {
            throw Error('Unknown "' + option + '" option');
          }
          value = options[option];
          if (value !== undefined2) {
            reducer = reducers[option];
            computedOptions[option] = reducer ? reducer(value, reject) : value;
          }
        }
        return computedOptions;
      }
      function constructorReducer(value, reject) {
        if (typeof value !== "function" || !value.hasOwnProperty("prototype")) {
          reject("value must be a constructor");
        }
        return value;
      }
      function makeTypeReducer(types) {
        var message = "value must be type of " + types.join("|");
        var len = types.length;
        var firstType = types[0];
        var secondType = types[1];
        if (len === 1) {
          return function(v, reject) {
            if (typeof v === firstType) {
              return v;
            }
            reject(message);
          };
        }
        if (len === 2) {
          return function(v, reject) {
            var kind = typeof v;
            if (kind === firstType || kind === secondType)
              return v;
            reject(message);
          };
        }
        return function(v, reject) {
          var kind = typeof v;
          var i = len;
          while (i-- > 0) {
            if (kind === types[i])
              return v;
          }
          reject(message);
        };
      }
      var functionReducer = makeTypeReducer(["function"]);
      var objectFunctionReducer = makeTypeReducer(["object", "function"]);
      function makeCancelablePromise(Promise2, executor, options) {
        var isCancelable;
        var callbacks;
        var timer = 0;
        var subscriptionClosed;
        var promise = new Promise2(function(resolve, reject, onCancel) {
          options = resolveOptions(options, {
            timeout: 0,
            overload: false
          }, {
            timeout: function(value, reject2) {
              value *= 1;
              if (typeof value !== "number" || value < 0 || !Number.isFinite(value)) {
                reject2("timeout must be a positive number");
              }
              return value;
            }
          });
          isCancelable = !options.overload && typeof Promise2.prototype.cancel === "function" && typeof onCancel === "function";
          function cleanup() {
            if (callbacks) {
              callbacks = null;
            }
            if (timer) {
              clearTimeout(timer);
              timer = 0;
            }
          }
          var _resolve = function(value) {
            cleanup();
            resolve(value);
          };
          var _reject = function(err) {
            cleanup();
            reject(err);
          };
          if (isCancelable) {
            executor(_resolve, _reject, onCancel);
          } else {
            callbacks = [function(reason) {
              _reject(reason || Error("canceled"));
            }];
            executor(_resolve, _reject, function(cb) {
              if (subscriptionClosed) {
                throw Error("Unable to subscribe on cancel event asynchronously");
              }
              if (typeof cb !== "function") {
                throw TypeError("onCancel callback must be a function");
              }
              callbacks.push(cb);
            });
            subscriptionClosed = true;
          }
          if (options.timeout > 0) {
            timer = setTimeout(function() {
              var reason = Error("timeout");
              reason.code = "ETIMEDOUT";
              timer = 0;
              promise.cancel(reason);
              reject(reason);
            }, options.timeout);
          }
        });
        if (!isCancelable) {
          promise.cancel = function(reason) {
            if (!callbacks) {
              return;
            }
            var length = callbacks.length;
            for (var i = 1; i < length; i++) {
              callbacks[i](reason);
            }
            callbacks[0](reason);
            callbacks = null;
          };
        }
        return promise;
      }
      function findTargetIndex(observer) {
        var observers = this._observers;
        if (!observers) {
          return -1;
        }
        var len = observers.length;
        for (var i = 0; i < len; i++) {
          if (observers[i]._target === observer)
            return i;
        }
        return -1;
      }
      function searchListenerTree(handlers, type, tree, i, typeLength) {
        if (!tree) {
          return null;
        }
        if (i === 0) {
          var kind = typeof type;
          if (kind === "string") {
            var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;
            if ((n = type.indexOf(delimiter)) !== -1) {
              ns = new Array(5);
              do {
                ns[l++] = type.slice(j, n);
                j = n + dl;
              } while ((n = type.indexOf(delimiter, j)) !== -1);
              ns[l++] = type.slice(j);
              type = ns;
              typeLength = l;
            } else {
              type = [type];
              typeLength = 1;
            }
          } else if (kind === "object") {
            typeLength = type.length;
          } else {
            type = [type];
            typeLength = 1;
          }
        }
        var listeners = null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i], nextType = type[i + 1], branches, _listeners;
        if (i === typeLength) {
          if (tree._listeners) {
            if (typeof tree._listeners === "function") {
              handlers && handlers.push(tree._listeners);
              listeners = [tree];
            } else {
              handlers && handlers.push.apply(handlers, tree._listeners);
              listeners = [tree];
            }
          }
        } else {
          if (currentType === "*") {
            branches = ownKeys(tree);
            n = branches.length;
            while (n-- > 0) {
              branch = branches[n];
              if (branch !== "_listeners") {
                _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (currentType === "**") {
            endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === "*";
            if (endReached && tree._listeners) {
              listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
            }
            branches = ownKeys(tree);
            n = branches.length;
            while (n-- > 0) {
              branch = branches[n];
              if (branch !== "_listeners") {
                if (branch === "*" || branch === "**") {
                  if (tree[branch]._listeners && !endReached) {
                    _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
                    if (_listeners) {
                      if (listeners) {
                        listeners.push.apply(listeners, _listeners);
                      } else {
                        listeners = _listeners;
                      }
                    }
                  }
                  _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
                } else if (branch === nextType) {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);
                } else {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
                }
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (tree[currentType]) {
            listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);
          }
        }
        xTree = tree["*"];
        if (xTree) {
          searchListenerTree(handlers, type, xTree, i + 1, typeLength);
        }
        xxTree = tree["**"];
        if (xxTree) {
          if (i < typeLength) {
            if (xxTree._listeners) {
              searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
            }
            branches = ownKeys(xxTree);
            n = branches.length;
            while (n-- > 0) {
              branch = branches[n];
              if (branch !== "_listeners") {
                if (branch === nextType) {
                  searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);
                } else if (branch === currentType) {
                  searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);
                } else {
                  isolatedBranch = {};
                  isolatedBranch[branch] = xxTree[branch];
                  searchListenerTree(handlers, type, { "**": isolatedBranch }, i + 1, typeLength);
                }
              }
            }
          } else if (xxTree._listeners) {
            searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
          } else if (xxTree["*"] && xxTree["*"]._listeners) {
            searchListenerTree(handlers, type, xxTree["*"], typeLength, typeLength);
          }
        }
        return listeners;
      }
      function growListenerTree(type, listener, prepend) {
        var len = 0, j = 0, i, delimiter = this.delimiter, dl = delimiter.length, ns;
        if (typeof type === "string") {
          if ((i = type.indexOf(delimiter)) !== -1) {
            ns = new Array(5);
            do {
              ns[len++] = type.slice(j, i);
              j = i + dl;
            } while ((i = type.indexOf(delimiter, j)) !== -1);
            ns[len++] = type.slice(j);
          } else {
            ns = [type];
            len = 1;
          }
        } else {
          ns = type;
          len = type.length;
        }
        if (len > 1) {
          for (i = 0; i + 1 < len; i++) {
            if (ns[i] === "**" && ns[i + 1] === "**") {
              return;
            }
          }
        }
        var tree = this.listenerTree, name;
        for (i = 0; i < len; i++) {
          name = ns[i];
          tree = tree[name] || (tree[name] = {});
          if (i === len - 1) {
            if (!tree._listeners) {
              tree._listeners = listener;
            } else {
              if (typeof tree._listeners === "function") {
                tree._listeners = [tree._listeners];
              }
              if (prepend) {
                tree._listeners.unshift(listener);
              } else {
                tree._listeners.push(listener);
              }
              if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
                tree._listeners.warned = true;
                logPossibleMemoryLeak.call(this, tree._listeners.length, name);
              }
            }
            return true;
          }
        }
        return true;
      }
      function collectTreeEvents(tree, events, root, asArray) {
        var branches = ownKeys(tree);
        var i = branches.length;
        var branch, branchName, path;
        var hasListeners = tree["_listeners"];
        var isArrayPath;
        while (i-- > 0) {
          branchName = branches[i];
          branch = tree[branchName];
          if (branchName === "_listeners") {
            path = root;
          } else {
            path = root ? root.concat(branchName) : [branchName];
          }
          isArrayPath = asArray || typeof branchName === "symbol";
          hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));
          if (typeof branch === "object") {
            collectTreeEvents.call(this, branch, events, path, isArrayPath);
          }
        }
        return events;
      }
      function recursivelyGarbageCollect(root) {
        var keys = ownKeys(root);
        var i = keys.length;
        var obj, key, flag;
        while (i-- > 0) {
          key = keys[i];
          obj = root[key];
          if (obj) {
            flag = true;
            if (key !== "_listeners" && !recursivelyGarbageCollect(obj)) {
              delete root[key];
            }
          }
        }
        return flag;
      }
      function Listener(emitter, event, listener) {
        this.emitter = emitter;
        this.event = event;
        this.listener = listener;
      }
      Listener.prototype.off = function() {
        this.emitter.off(this.event, this.listener);
        return this;
      };
      function setupListener(event, listener, options) {
        if (options === true) {
          promisify = true;
        } else if (options === false) {
          async = true;
        } else {
          if (!options || typeof options !== "object") {
            throw TypeError("options should be an object or true");
          }
          var async = options.async;
          var promisify = options.promisify;
          var nextTick = options.nextTick;
          var objectify = options.objectify;
        }
        if (async || nextTick || promisify) {
          var _listener = listener;
          var _origin = listener._origin || listener;
          if (nextTick && !nextTickSupported) {
            throw Error("process.nextTick is not supported");
          }
          if (promisify === undefined2) {
            promisify = listener.constructor.name === "AsyncFunction";
          }
          listener = function() {
            var args = arguments;
            var context = this;
            var event2 = this.event;
            return promisify ? nextTick ? Promise.resolve() : new Promise(function(resolve) {
              _setImmediate(resolve);
            }).then(function() {
              context.event = event2;
              return _listener.apply(context, args);
            }) : (nextTick ? process.nextTick : _setImmediate)(function() {
              context.event = event2;
              _listener.apply(context, args);
            });
          };
          listener._async = true;
          listener._origin = _origin;
        }
        return [listener, objectify ? new Listener(this, event, listener) : this];
      }
      function EventEmitter(conf) {
        this._events = {};
        this._newListener = false;
        this._removeListener = false;
        this.verboseMemoryLeak = false;
        configure.call(this, conf);
      }
      EventEmitter.EventEmitter2 = EventEmitter;
      EventEmitter.prototype.listenTo = function(target, events, options) {
        if (typeof target !== "object") {
          throw TypeError("target musts be an object");
        }
        var emitter = this;
        options = resolveOptions(options, {
          on: undefined2,
          off: undefined2,
          reducers: undefined2
        }, {
          on: functionReducer,
          off: functionReducer,
          reducers: objectFunctionReducer
        });
        function listen(events2) {
          if (typeof events2 !== "object") {
            throw TypeError("events must be an object");
          }
          var reducers = options.reducers;
          var index = findTargetIndex.call(emitter, target);
          var observer;
          if (index === -1) {
            observer = new TargetObserver(emitter, target, options);
          } else {
            observer = emitter._observers[index];
          }
          var keys = ownKeys(events2);
          var len = keys.length;
          var event;
          var isSingleReducer = typeof reducers === "function";
          for (var i = 0; i < len; i++) {
            event = keys[i];
            observer.subscribe(
              event,
              events2[event] || event,
              isSingleReducer ? reducers : reducers && reducers[event]
            );
          }
        }
        isArray2(events) ? listen(toObject(events)) : typeof events === "string" ? listen(toObject(events.split(/\s+/))) : listen(events);
        return this;
      };
      EventEmitter.prototype.stopListeningTo = function(target, event) {
        var observers = this._observers;
        if (!observers) {
          return false;
        }
        var i = observers.length;
        var observer;
        var matched = false;
        if (target && typeof target !== "object") {
          throw TypeError("target should be an object");
        }
        while (i-- > 0) {
          observer = observers[i];
          if (!target || observer._target === target) {
            observer.unsubscribe(event);
            matched = true;
          }
        }
        return matched;
      };
      EventEmitter.prototype.delimiter = ".";
      EventEmitter.prototype.setMaxListeners = function(n) {
        if (n !== undefined2) {
          this._maxListeners = n;
          if (!this._conf)
            this._conf = {};
          this._conf.maxListeners = n;
        }
      };
      EventEmitter.prototype.getMaxListeners = function() {
        return this._maxListeners;
      };
      EventEmitter.prototype.event = "";
      EventEmitter.prototype.once = function(event, fn2, options) {
        return this._once(event, fn2, false, options);
      };
      EventEmitter.prototype.prependOnceListener = function(event, fn2, options) {
        return this._once(event, fn2, true, options);
      };
      EventEmitter.prototype._once = function(event, fn2, prepend, options) {
        return this._many(event, 1, fn2, prepend, options);
      };
      EventEmitter.prototype.many = function(event, ttl, fn2, options) {
        return this._many(event, ttl, fn2, false, options);
      };
      EventEmitter.prototype.prependMany = function(event, ttl, fn2, options) {
        return this._many(event, ttl, fn2, true, options);
      };
      EventEmitter.prototype._many = function(event, ttl, fn2, prepend, options) {
        var self2 = this;
        if (typeof fn2 !== "function") {
          throw new Error("many only accepts instances of Function");
        }
        function listener() {
          if (--ttl === 0) {
            self2.off(event, listener);
          }
          return fn2.apply(this, arguments);
        }
        listener._origin = fn2;
        return this._on(event, listener, prepend, options);
      };
      EventEmitter.prototype.emit = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init.call(this);
        var type = arguments[0], ns, wildcard = this.wildcard;
        var args, l, i, j, containsSymbol;
        if (type === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return false;
          }
        }
        if (wildcard) {
          ns = type;
          if (type !== "newListener" && type !== "removeListener") {
            if (typeof type === "object") {
              l = type.length;
              if (symbolsSupported) {
                for (i = 0; i < l; i++) {
                  if (typeof type[i] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type = type.join(this.delimiter);
              }
            }
          }
        }
        var al = arguments.length;
        var handler;
        if (this._all && this._all.length) {
          handler = this._all.slice();
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                handler[i].call(this, type);
                break;
              case 2:
                handler[i].call(this, type, arguments[1]);
                break;
              case 3:
                handler[i].call(this, type, arguments[1], arguments[2]);
                break;
              default:
                handler[i].apply(this, arguments);
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);
        } else {
          handler = this._events[type];
          if (typeof handler === "function") {
            this.event = type;
            switch (al) {
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                args = new Array(al - 1);
                for (j = 1; j < al; j++)
                  args[j - 1] = arguments[j];
                handler.apply(this, args);
            }
            return true;
          } else if (handler) {
            handler = handler.slice();
          }
        }
        if (handler && handler.length) {
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++)
              args[j - 1] = arguments[j];
          }
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                handler[i].call(this);
                break;
              case 2:
                handler[i].call(this, arguments[1]);
                break;
              case 3:
                handler[i].call(this, arguments[1], arguments[2]);
                break;
              default:
                handler[i].apply(this, args);
            }
          }
          return true;
        } else if (!this.ignoreErrors && !this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            throw arguments[1];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
        }
        return !!this._all;
      };
      EventEmitter.prototype.emitAsync = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init.call(this);
        var type = arguments[0], wildcard = this.wildcard, ns, containsSymbol;
        var args, l, i, j;
        if (type === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return Promise.resolve([false]);
          }
        }
        if (wildcard) {
          ns = type;
          if (type !== "newListener" && type !== "removeListener") {
            if (typeof type === "object") {
              l = type.length;
              if (symbolsSupported) {
                for (i = 0; i < l; i++) {
                  if (typeof type[i] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type = type.join(this.delimiter);
              }
            }
          }
        }
        var promises = [];
        var al = arguments.length;
        var handler;
        if (this._all) {
          for (i = 0, l = this._all.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                promises.push(this._all[i].call(this, type));
                break;
              case 2:
                promises.push(this._all[i].call(this, type, arguments[1]));
                break;
              case 3:
                promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
                break;
              default:
                promises.push(this._all[i].apply(this, arguments));
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
        } else {
          handler = this._events[type];
        }
        if (typeof handler === "function") {
          this.event = type;
          switch (al) {
            case 1:
              promises.push(handler.call(this));
              break;
            case 2:
              promises.push(handler.call(this, arguments[1]));
              break;
            case 3:
              promises.push(handler.call(this, arguments[1], arguments[2]));
              break;
            default:
              args = new Array(al - 1);
              for (j = 1; j < al; j++)
                args[j - 1] = arguments[j];
              promises.push(handler.apply(this, args));
          }
        } else if (handler && handler.length) {
          handler = handler.slice();
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++)
              args[j - 1] = arguments[j];
          }
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                promises.push(handler[i].call(this));
                break;
              case 2:
                promises.push(handler[i].call(this, arguments[1]));
                break;
              case 3:
                promises.push(handler[i].call(this, arguments[1], arguments[2]));
                break;
              default:
                promises.push(handler[i].apply(this, args));
            }
          }
        } else if (!this.ignoreErrors && !this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            return Promise.reject(arguments[1]);
          } else {
            return Promise.reject("Uncaught, unspecified 'error' event.");
          }
        }
        return Promise.all(promises);
      };
      EventEmitter.prototype.on = function(type, listener, options) {
        return this._on(type, listener, false, options);
      };
      EventEmitter.prototype.prependListener = function(type, listener, options) {
        return this._on(type, listener, true, options);
      };
      EventEmitter.prototype.onAny = function(fn2) {
        return this._onAny(fn2, false);
      };
      EventEmitter.prototype.prependAny = function(fn2) {
        return this._onAny(fn2, true);
      };
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;
      EventEmitter.prototype._onAny = function(fn2, prepend) {
        if (typeof fn2 !== "function") {
          throw new Error("onAny only accepts instances of Function");
        }
        if (!this._all) {
          this._all = [];
        }
        if (prepend) {
          this._all.unshift(fn2);
        } else {
          this._all.push(fn2);
        }
        return this;
      };
      EventEmitter.prototype._on = function(type, listener, prepend, options) {
        if (typeof type === "function") {
          this._onAny(type, listener);
          return this;
        }
        if (typeof listener !== "function") {
          throw new Error("on only accepts instances of Function");
        }
        this._events || init.call(this);
        var returnValue = this, temp;
        if (options !== undefined2) {
          temp = setupListener.call(this, type, listener, options);
          listener = temp[0];
          returnValue = temp[1];
        }
        if (this._newListener) {
          this.emit("newListener", type, listener);
        }
        if (this.wildcard) {
          growListenerTree.call(this, type, listener, prepend);
          return returnValue;
        }
        if (!this._events[type]) {
          this._events[type] = listener;
        } else {
          if (typeof this._events[type] === "function") {
            this._events[type] = [this._events[type]];
          }
          if (prepend) {
            this._events[type].unshift(listener);
          } else {
            this._events[type].push(listener);
          }
          if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
            this._events[type].warned = true;
            logPossibleMemoryLeak.call(this, this._events[type].length, type);
          }
        }
        return returnValue;
      };
      EventEmitter.prototype.off = function(type, listener) {
        if (typeof listener !== "function") {
          throw new Error("removeListener only takes instances of Function");
        }
        var handlers, leafs = [];
        if (this.wildcard) {
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
          if (!leafs)
            return this;
        } else {
          if (!this._events[type])
            return this;
          handlers = this._events[type];
          leafs.push({ _listeners: handlers });
        }
        for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
          var leaf = leafs[iLeaf];
          handlers = leaf._listeners;
          if (isArray2(handlers)) {
            var position = -1;
            for (var i = 0, length = handlers.length; i < length; i++) {
              if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
                position = i;
                break;
              }
            }
            if (position < 0) {
              continue;
            }
            if (this.wildcard) {
              leaf._listeners.splice(position, 1);
            } else {
              this._events[type].splice(position, 1);
            }
            if (handlers.length === 0) {
              if (this.wildcard) {
                delete leaf._listeners;
              } else {
                delete this._events[type];
              }
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);
            return this;
          } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
            if (this.wildcard) {
              delete leaf._listeners;
            } else {
              delete this._events[type];
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);
          }
        }
        this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        return this;
      };
      EventEmitter.prototype.offAny = function(fn2) {
        var i = 0, l = 0, fns;
        if (fn2 && this._all && this._all.length > 0) {
          fns = this._all;
          for (i = 0, l = fns.length; i < l; i++) {
            if (fn2 === fns[i]) {
              fns.splice(i, 1);
              if (this._removeListener)
                this.emit("removeListenerAny", fn2);
              return this;
            }
          }
        } else {
          fns = this._all;
          if (this._removeListener) {
            for (i = 0, l = fns.length; i < l; i++)
              this.emit("removeListenerAny", fns[i]);
          }
          this._all = [];
        }
        return this;
      };
      EventEmitter.prototype.removeListener = EventEmitter.prototype.off;
      EventEmitter.prototype.removeAllListeners = function(type) {
        if (type === undefined2) {
          !this._events || init.call(this);
          return this;
        }
        if (this.wildcard) {
          var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;
          if (!leafs)
            return this;
          for (i = 0; i < leafs.length; i++) {
            leaf = leafs[i];
            leaf._listeners = null;
          }
          this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        } else if (this._events) {
          this._events[type] = null;
        }
        return this;
      };
      EventEmitter.prototype.listeners = function(type) {
        var _events = this._events;
        var keys, listeners, allListeners;
        var i;
        var listenerTree;
        if (type === undefined2) {
          if (this.wildcard) {
            throw Error("event name required for wildcard emitter");
          }
          if (!_events) {
            return [];
          }
          keys = ownKeys(_events);
          i = keys.length;
          allListeners = [];
          while (i-- > 0) {
            listeners = _events[keys[i]];
            if (typeof listeners === "function") {
              allListeners.push(listeners);
            } else {
              allListeners.push.apply(allListeners, listeners);
            }
          }
          return allListeners;
        } else {
          if (this.wildcard) {
            listenerTree = this.listenerTree;
            if (!listenerTree)
              return [];
            var handlers = [];
            var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
            searchListenerTree.call(this, handlers, ns, listenerTree, 0);
            return handlers;
          }
          if (!_events) {
            return [];
          }
          listeners = _events[type];
          if (!listeners) {
            return [];
          }
          return typeof listeners === "function" ? [listeners] : listeners;
        }
      };
      EventEmitter.prototype.eventNames = function(nsAsArray) {
        var _events = this._events;
        return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];
      };
      EventEmitter.prototype.listenerCount = function(type) {
        return this.listeners(type).length;
      };
      EventEmitter.prototype.hasListeners = function(type) {
        if (this.wildcard) {
          var handlers = [];
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
          return handlers.length > 0;
        }
        var _events = this._events;
        var _all = this._all;
        return !!(_all && _all.length || _events && (type === undefined2 ? ownKeys(_events).length : _events[type]));
      };
      EventEmitter.prototype.listenersAny = function() {
        if (this._all) {
          return this._all;
        } else {
          return [];
        }
      };
      EventEmitter.prototype.waitFor = function(event, options) {
        var self2 = this;
        var type = typeof options;
        if (type === "number") {
          options = { timeout: options };
        } else if (type === "function") {
          options = { filter: options };
        }
        options = resolveOptions(options, {
          timeout: 0,
          filter: undefined2,
          handleError: false,
          Promise,
          overload: false
        }, {
          filter: functionReducer,
          Promise: constructorReducer
        });
        return makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
          function listener() {
            var filter = options.filter;
            if (filter && !filter.apply(self2, arguments)) {
              return;
            }
            self2.off(event, listener);
            if (options.handleError) {
              var err = arguments[0];
              err ? reject(err) : resolve(toArray2.apply(null, arguments).slice(1));
            } else {
              resolve(toArray2.apply(null, arguments));
            }
          }
          onCancel(function() {
            self2.off(event, listener);
          });
          self2._on(event, listener, false);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      };
      function once(emitter, name, options) {
        options = resolveOptions(options, {
          Promise,
          timeout: 0,
          overload: false
        }, {
          Promise: constructorReducer
        });
        var _Promise = options.Promise;
        return makeCancelablePromise(_Promise, function(resolve, reject, onCancel) {
          var handler;
          if (typeof emitter.addEventListener === "function") {
            handler = function() {
              resolve(toArray2.apply(null, arguments));
            };
            onCancel(function() {
              emitter.removeEventListener(name, handler);
            });
            emitter.addEventListener(
              name,
              handler,
              { once: true }
            );
            return;
          }
          var eventListener = function() {
            errorListener && emitter.removeListener("error", errorListener);
            resolve(toArray2.apply(null, arguments));
          };
          var errorListener;
          if (name !== "error") {
            errorListener = function(err) {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          onCancel(function() {
            errorListener && emitter.removeListener("error", errorListener);
            emitter.removeListener(name, eventListener);
          });
          emitter.once(name, eventListener);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      }
      var prototype = EventEmitter.prototype;
      Object.defineProperties(EventEmitter, {
        defaultMaxListeners: {
          get: function() {
            return prototype._maxListeners;
          },
          set: function(n) {
            if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
              throw TypeError("n must be a non-negative number");
            }
            prototype._maxListeners = n;
          },
          enumerable: true
        },
        once: {
          value: once,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperties(prototype, {
        _maxListeners: {
          value: defaultMaxListeners,
          writable: true,
          configurable: true
        },
        _observers: { value: null, writable: true, configurable: true }
      });
      if (typeof define === "function" && define.amd) {
        define(function() {
          return EventEmitter;
        });
      } else if (typeof exports === "object") {
        module2.exports = EventEmitter;
      } else {
        var _global = new Function("", "return this")();
        _global.EventEmitter2 = EventEmitter;
      }
    }();
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TickTickSync
});
module.exports = __toCommonJS(main_exports);
var import_obsidian15 = require("obsidian");

// src/settings.ts
var import_obsidian6 = require("obsidian");

// src/modals/ConfirmFullSyncModal.ts
var import_obsidian = require("obsidian");
var ConfirmFullSyncModal = class extends import_obsidian.Modal {
  title = "Full Vault Task Sync Confirmation";
  message = 'Are you sure you want to Sync ALL tasks. \nTasks that are currently "Items" of tasks will be converted to "Sub Tasks" of the containing Tasks.\nThe "Items" will not be deleted.\nPlease proceed with Caution.';
  cancelLabel = "Cancel";
  confirmLabel = "Confirm Full Vault Task Sync";
  result;
  onSubmit;
  resolvePromise;
  constructor(app2, onSubmit) {
    super(app2);
    this.onSubmit = onSubmit;
  }
  /**
   * Called automatically by the Modal class when modal is opened.
   */
  onOpen() {
    const { titleEl, contentEl } = this;
    titleEl.setText(this.title);
    contentEl.createEl("p", { text: this.message });
    new import_obsidian.Setting(contentEl).addButton((cancelBtn) => {
      cancelBtn.setClass("ts_button");
      cancelBtn.setButtonText(this.cancelLabel);
      cancelBtn.onClick(() => {
        this.result = false;
        this.onSubmit(this.result);
        this.close();
      });
    }).addButton((confirmBtn) => {
      confirmBtn.setClass("ts_button");
      confirmBtn.setWarning();
      confirmBtn.setButtonText(this.confirmLabel);
      confirmBtn.onClick(() => {
        this.result = true;
        this.onSubmit(this.result);
        this.close();
      });
    });
  }
  /**
   * Called automatically by the Modal class when modal is closed.
   */
  onClose() {
    this.titleEl.empty();
    this.contentEl.empty();
    super.onClose();
    this.resolvePromise(this.result);
  }
  showModal() {
    this.open();
    return new Promise(
      (resolve) => this.resolvePromise = resolve
    );
  }
};

// src/utils/FolderSuggester.ts
var import_obsidian3 = require("obsidian");

// src/utils/suggest.ts
var import_obsidian2 = require("obsidian");

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// src/utils/suggest.ts
var wrapAround = (value, size) => {
  return (value % size + size) % size;
};
var Suggest = class {
  owner;
  values;
  suggestions;
  selectedItem;
  containerEl;
  constructor(owner, containerEl, scope) {
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on(
      "click",
      ".suggestion-item",
      this.onSuggestionClick.bind(this)
    );
    containerEl.on(
      "mousemove",
      ".suggestion-item",
      this.onSuggestionMouseover.bind(this)
    );
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - 1, true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + 1, true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
  }
  setSuggestions(values) {
    this.containerEl.empty();
    const suggestionEls = [];
    values.forEach((value) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values;
    this.suggestions = suggestionEls;
    this.setSelectedItem(0, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = wrapAround(
      selectedIndex,
      this.suggestions.length
    );
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion?.removeClass("is-selected");
    selectedSuggestion?.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
};
var TextInputSuggest = class {
  inputEl;
  popper;
  scope;
  suggestEl;
  suggest;
  constructor(inputEl) {
    this.inputEl = inputEl;
    this.scope = new import_obsidian2.Scope();
    this.suggestEl = createDiv("suggestion-container");
    const suggestion = this.suggestEl.createDiv("suggestion");
    this.suggest = new Suggest(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on(
      "mousedown",
      ".suggestion-container",
      (event) => {
        event.preventDefault();
      }
    );
  }
  onInputChanged() {
    const inputStr = this.inputEl.value;
    const suggestions = this.getSuggestions(inputStr);
    if (!suggestions) {
      this.close();
      return;
    }
    if (suggestions.length > 0) {
      this.suggest.setSuggestions(suggestions);
      this.open(app.dom.appContainerEl, this.inputEl);
    } else {
      this.close();
    }
  }
  open(container, inputEl) {
    app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance }) => {
            const targetWidth = `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            instance.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    if (this.popper)
      this.popper.destroy();
    this.suggestEl.detach();
  }
};

// src/utils/FolderSuggester.ts
var FolderSuggest = class extends TextInputSuggest {
  getSuggestions(inputStr) {
    const abstractFiles = app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian3.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/api/index.ts
var import_obsidian4 = require("obsidian");
var import_bson_objectid = __toESM(require_objectid());

// src/api/utils/get-api-endpoints.ts
var API_ENDPOINTS = {
  ticktickServer: "ticktick.com",
  protocol: "https://",
  apiProtocol: "https://api.",
  apiVersion: "/api/v2",
  signInEndPoint: "user/signon?wc=true&remember=true",
  userPreferencesEndPoint: "user/preferences/settings",
  allProjectsEndPoint: "projects",
  allHabitsEndPoint: "habits",
  allTagsEndPoint: "tags",
  allTasksEndPoint: "batch/check/",
  TaskEndPoint: "task",
  updateTaskEndPoint: "batch/task",
  //If this ever existed, it's gone now. use getSections. That's the only project detail anyway.
  //getProject: 'project/',
  getSections: "column/project/",
  getAllCompletedItems: "project/all/completedInAll/",
  exportData: "data/export",
  projectMove: "batch/taskProject",
  parentMove: `batch/taskParent`
};

// src/api/index.ts
var {
  ticktickServer,
  protocol,
  apiProtocol,
  apiVersion,
  TaskEndPoint,
  updateTaskEndPoint,
  allTagsEndPoint,
  allHabitsEndPoint,
  allProjectsEndPoint,
  allTasksEndPoint,
  signInEndPoint,
  userPreferencesEndPoint,
  getSections,
  getAllCompletedItems,
  exportData,
  projectMove,
  parentMove
} = API_ENDPOINTS;
var Tick = class {
  username;
  password;
  inboxProperties;
  token;
  apiUrl;
  loginUrl;
  originUrl;
  //Dear Future me: the check is a checkpoint based thing. As in: give me everything after a certain checkpoint
  //                0 behavior has become non-deterministic. It appears that checkpoint is a epoch number.
  //                I **think** it indicates the time of last fetch. This could be useful.
  //TODO: in the fullness of time, figure out checkpoint processing to reduce traffic.
  _checkpoint;
  constructor({ username, password, baseUrl, token, checkPoint }) {
    this.username = username;
    this.password = password;
    this.token = token;
    this.inboxProperties = {
      id: "",
      sortOrder: 0
    };
    if (baseUrl) {
      this.apiUrl = `${apiProtocol}${baseUrl}${apiVersion}`;
      this.loginUrl = `${protocol}${baseUrl}${apiVersion}`;
      this.originUrl = `${protocol}${baseUrl}`;
    } else {
      this.apiUrl = `${apiProtocol}${ticktickServer}${apiVersion}`;
      this.loginUrl = `${protocol}${ticktickServer}${apiVersion}`;
      this.originUrl = `${protocol}${ticktickServer}`;
    }
    if (checkPoint == 0) {
      let dtDate = new Date("2013-01-01T00:00:00.000+0000");
      console.log("Starting Checkpoint date: ", dtDate, "Checkpoint", dtDate.getTime());
      this._checkpoint = dtDate.getTime();
    } else {
      this._checkpoint = checkPoint;
    }
  }
  get inboxId() {
    return this.inboxProperties.id;
  }
  _lastError;
  get lastError() {
    return this._lastError;
  }
  set lastError(value) {
    this._lastError = value;
  }
  get checkpoint() {
    return this._checkpoint;
  }
  set checkpoint(value) {
    this._checkpoint = value;
  }
  // USER ======================================================================
  async login() {
    try {
      let ret = false;
      const url = `${this.loginUrl}/${signInEndPoint}`;
      const body = {
        username: this.username,
        password: this.password
      };
      const response = await this.makeRequest("Login", url, "POST", body);
      console.log("Signed in Response: ", response);
      if (response) {
        this.token = response.token;
        this.inboxProperties.id = response.inboxId;
        ret = await this.getInboxProperties();
      }
      return ret;
    } catch (e) {
      this.setError("Login", null, e);
      console.error(e);
      return false;
    }
  }
  async getUserSettings() {
    try {
      const url = `${this.apiUrl}/${userPreferencesEndPoint}`;
      const response = await this.makeRequest("Get User Settings", url, "GET", void 0);
      if (response) {
        return response;
      } else {
        return null;
      }
    } catch (e) {
      console.error("Get Inbox Properties failed: ", e);
      this.setError("Get Inbox Properties", null, e);
      return null;
    }
  }
  async getInboxProperties() {
    try {
      for (let i = 0; i < 10; i++) {
        const url = `${this.apiUrl}/${allTasksEndPoint}` + this._checkpoint;
        let response = await this.makeRequest("Get Inbox Properties", url, "GET");
        if (response) {
          response["syncTaskBean"].update.forEach((task) => {
            if (task.projectId == this.inboxProperties.id && task.sortOrder < this.inboxProperties.sortOrder) {
              this.inboxProperties.sortOrder = task.sortOrder;
            }
          });
          this.inboxProperties.sortOrder--;
          return true;
        } else {
          if (i < 10) {
            this._checkpoint = this.getNextCheckPoint();
          } else {
            return false;
          }
        }
      }
    } catch (e) {
      console.error("Get Inbox Properties failed: ", e);
      this.setError("Get Inbox Properties", null, e);
      return false;
    }
  }
  // FILTERS ===================================================================
  // TODO: If Filters required at some point, they come from allTasksEndPoint
  // TAGS ======================================================================
  // TODO: if Tags required, they come from allTagsEndPoint
  // HABITS ====================================================================
  //TODO: if Habits required, they come from allHabitsEndPoint
  // PROJECTS ==================================================================
  async getProjectGroups() {
    try {
      const url = `${this.apiUrl}/${allTasksEndPoint}` + this._checkpoint;
      const response = await this.makeRequest("Get Project Groups", url, "GET", void 0);
      if (response) {
        return response["projectGroups"];
      } else {
        return [];
      }
    } catch (e) {
      console.error("Get Project Groups failed: ", e);
      this.setError("Get Project Groups", null, e);
      return [];
    }
  }
  async getProjects() {
    try {
      const url = `${this.apiUrl}/${allProjectsEndPoint}`;
      const response = await this.makeRequest("Get Projects", url, "GET", void 0);
      if (response) {
        return response;
      } else {
        return [];
      }
    } catch (e) {
      console.error("Get Projects failed: ", e);
      this.setError("Get Projects", null, e);
      return [];
    }
  }
  async getProjectSections(projectId) {
    try {
      const url = `${this.apiUrl}/${getSections}/${projectId}`;
      const response = await this.makeRequest("Get Project Sections", url, "GET", void 0);
      if (response) {
        return response;
      } else {
        return [];
      }
    } catch (e) {
      console.error("Get Project Sections failed: ", e);
      this.setError("Get Project Sections", null, e);
      return [];
    }
  }
  // RESOURCES =================================================================
  async getAllResources() {
    try {
      const url = `${this.apiUrl}/${allTasksEndPoint}` + this._checkpoint;
      const response = await this.makeRequest("Get All Resources", url, "GET", void 0);
      if (response) {
        return response;
      } else {
        return [];
      }
    } catch (e) {
      console.error("Get All Resources failed: ", e);
      this.setError("Get All Resources", null, e);
      return [];
    }
  }
  // TASKS =====================================================================
  async getTaskDetails() {
    try {
      const url = `${this.apiUrl}/${allTasksEndPoint}` + this._checkpoint;
      const response = await this.makeRequest("Get Task Details", url, "GET", void 0);
      if (response) {
        return response["syncTaskBean"];
      } else {
        return [];
      }
    } catch (e) {
      console.error("Get Tasks Details failed: ", e);
      this.setError("Get Tasks", null, e);
      return [];
    }
  }
  async getTasks() {
    try {
      const url = `${this.apiUrl}/${allTasksEndPoint}` + this._checkpoint;
      ;
      const response = await this.makeRequest("Get Tasks", url, "GET", void 0);
      if (response) {
        return response["syncTaskBean"].update;
      } else {
        return [];
      }
    } catch (e) {
      console.error("Get Tasks failed: ", e);
      this.setError("Get Tasks", null, e);
      return [];
    }
  }
  async getTask(taskID, projectID) {
    try {
      let url = `${this.apiUrl}/${TaskEndPoint}/${taskID}`;
      const projectParam = `?projectID=${projectID}`;
      if (projectID) {
        url = url + projectParam;
      }
      const response = await this.makeRequest("Get Tasks", url, "GET", void 0);
      if (response) {
        return response;
      } else {
        return null;
      }
    } catch (e) {
      console.error("Get Tasks failed: ", e);
      this.setError("Get Tasks", null, e);
      return null;
    }
  }
  async getAllCompletedItems() {
    try {
      const url = `${this.apiUrl}/${getAllCompletedItems}`;
      const response = await this.makeRequest("Get All Completed Items", url, "GET", void 0);
      if (response) {
        return response["syncTaskBean"].update;
      } else {
        return [];
      }
    } catch (e) {
      console.error("Get All Completed Items failed: ", e);
      this.setError("Get All Completed Tasks", null, e);
      return [];
    }
  }
  async addTask(jsonOptions) {
    try {
      let bIsAllDay = true;
      if (jsonOptions.isAllDay == null) {
        bIsAllDay = true;
      } else {
        bIsAllDay = jsonOptions.isAllDay;
      }
      const thisTask = {
        id: jsonOptions.id ? jsonOptions.id : (0, import_bson_objectid.default)(),
        projectId: jsonOptions.projectId ? jsonOptions.projectId : this.inboxProperties.id,
        sortOrder: jsonOptions.sortOrder ? jsonOptions.sortOrder : this.inboxProperties.sortOrder,
        title: jsonOptions.title,
        content: jsonOptions.content ? jsonOptions.content : "",
        startDate: jsonOptions.startDate ? jsonOptions.startDate : null,
        dueDate: jsonOptions.dueDate ? jsonOptions.dueDate : null,
        timeZone: jsonOptions.timeZone ? jsonOptions.timeZone : "America/New_York",
        // This needs to be updated to grab dynamically
        isAllDay: bIsAllDay,
        reminder: jsonOptions.reminder ? jsonOptions.reminder : null,
        reminders: jsonOptions.reminders ? jsonOptions.reminders : [{
          id: (0, import_bson_objectid.default)(),
          trigger: "TRIGGER:PT0S"
        }],
        repeatFlag: jsonOptions.repeatFlag ? jsonOptions.repeatFlag : null,
        priority: jsonOptions.priority ? jsonOptions.priority : 0,
        status: jsonOptions.status ? jsonOptions.status : 0,
        items: jsonOptions.items ? jsonOptions.items : [],
        progress: jsonOptions.progress ? jsonOptions.progress : 0,
        modifiedTime: jsonOptions.modifiedTime ? jsonOptions.modifiedTime : new Date().toISOString().replace("Z", "+0000"),
        //"2017-08-12T17:04:51.982+0000",
        deleted: jsonOptions.deleted ? jsonOptions.deleted : 0,
        assignee: jsonOptions.assignee ? jsonOptions.assignee : null,
        isDirty: jsonOptions.isDirty ? jsonOptions.isDirty : true,
        local: jsonOptions.local ? jsonOptions.local : true,
        remindTime: jsonOptions.remindTime ? jsonOptions.remindTime : null,
        tags: jsonOptions.tags ? jsonOptions.tags : [],
        childIds: jsonOptions.childIds ? jsonOptions.childIds : [],
        parentId: jsonOptions.parentId ? jsonOptions.parentId : null
      };
      const url = `${this.apiUrl}/${TaskEndPoint}`;
      const response = await this.makeRequest("Add Task", url, "POST", thisTask);
      if (response) {
        let bodySortOrder;
        bodySortOrder = response.sortOrder;
        this.inboxProperties.sortOrder = bodySortOrder - 1;
        return response;
      } else {
        return [];
      }
    } catch (e) {
      console.error("Add Task failed: ", e);
      this.setError("Add Task", null, e);
      return [];
    }
  }
  async updateTask(jsonOptions) {
    try {
      let bIsAllDay = true;
      if (jsonOptions.isAllDay == null) {
        bIsAllDay = true;
      } else {
        bIsAllDay = jsonOptions.isAllDay;
      }
      const thisTask = {
        id: jsonOptions.id ? jsonOptions.id : (0, import_bson_objectid.default)(),
        projectId: jsonOptions.projectId ? jsonOptions.projectId : this.inboxProperties.id,
        sortOrder: jsonOptions.sortOrder ? jsonOptions.sortOrder : this.inboxProperties.sortOrder,
        title: jsonOptions.title,
        content: jsonOptions.content ? jsonOptions.content : "",
        startDate: jsonOptions.startDate ? jsonOptions.startDate : null,
        dueDate: jsonOptions.dueDate ? jsonOptions.dueDate : null,
        timeZone: jsonOptions.timeZone ? jsonOptions.timeZone : "America/New_York",
        // This needs to be updated to grab dynamically
        isAllDay: bIsAllDay,
        reminder: jsonOptions.reminder ? jsonOptions.reminder : null,
        reminders: jsonOptions.reminders ? jsonOptions.reminders : [{
          id: (0, import_bson_objectid.default)(),
          trigger: "TRIGGER:PT0S"
        }],
        repeatFlag: jsonOptions.repeatFlag ? jsonOptions.repeatFlag : null,
        priority: jsonOptions.priority ? jsonOptions.priority : 0,
        status: jsonOptions.status ? jsonOptions.status : 0,
        items: jsonOptions.items ? jsonOptions.items : [],
        progress: jsonOptions.progress ? jsonOptions.progress : 0,
        modifiedTime: jsonOptions.modifiedTime ? jsonOptions.modifiedTime : new Date().toISOString().replace("Z", "+0000"),
        //"2017-08-12T17:04:51.982+0000",
        deleted: jsonOptions.deleted ? jsonOptions.deleted : 0,
        assignee: jsonOptions.assignee ? jsonOptions.assignee : null,
        isDirty: jsonOptions.isDirty ? jsonOptions.isDirty : true,
        local: jsonOptions.local ? jsonOptions.local : true,
        remindTime: jsonOptions.remindTime ? jsonOptions.remindTime : null,
        tags: jsonOptions.tags ? jsonOptions.tags : [],
        childIds: jsonOptions.childIds ? jsonOptions.childIds : [],
        parentId: jsonOptions.parentId ? jsonOptions.parentId : null
      };
      let updatePayload;
      updatePayload = {
        add: [],
        addAttachments: [],
        delete: [],
        deleteAttachments: [],
        updateAttachments: [],
        update: [thisTask]
      };
      const url = `${this.apiUrl}/${updateTaskEndPoint}`;
      const response = await this.makeRequest("Update Task", url, "POST", updatePayload);
      if (response) {
        return response;
      } else {
        return null;
      }
    } catch (e) {
      console.error("Update Task failed: ", e);
      this.setError("Update Task", null, e);
      return null;
    }
  }
  async deleteTask(deleteTaskId, deletedTaskprojectId) {
    if (!deleteTaskId || !deletedTaskprojectId) {
      throw new Error("Both Task Id and Project ID are required for a delete, otherwise TickTick will fail silently.");
    }
    try {
      const taskToDelete = { taskId: deleteTaskId, projectId: deletedTaskprojectId };
      let deletePayload;
      deletePayload = {
        add: [],
        addAttachments: [],
        delete: [taskToDelete],
        deleteAttachments: [],
        updateAttachments: [],
        update: []
      };
      const url = `${this.apiUrl}/${updateTaskEndPoint}`;
      const response = await this.makeRequest("Delete Task", url, "POST", deletePayload);
      if (response) {
        this.inboxProperties.sortOrder = response.sortOrder - 1;
        return response;
      } else {
        return null;
      }
    } catch (e) {
      console.error("Delete Task  failed: ", e);
      this.setError("Delete Task Tasks", null, e);
      return null;
    }
  }
  async exportData() {
    try {
      const url = `${this.apiUrl}/${exportData}`;
      const response = await this.makeRequest("Export", url, "GET", void 0);
      if (response) {
        let body = response;
        body = body.substring(1);
        body = body.substring(0, body.length - 1);
        body = body.replace(/\\\"/g, '"');
        body = body.replace(/\\n/g, "\n");
        return body;
      } else {
        return null;
      }
    } catch (e) {
      console.error("Export failed: ", e);
      this.setError("Export", null, e);
      return null;
    }
  }
  async projectMove(taskId, fromProjectId, toProjectId) {
    try {
      const url = `${this.apiUrl}/${projectMove}`;
      const projectMovePayload = [{
        fromProjectId,
        toProjectId,
        taskId,
        sortOrder: this.inboxProperties.sortOrder
      }];
      const response = await this.makeRequest("Project Move", url, "POST", projectMovePayload);
      if (response) {
        this.inboxProperties.sortOrder = response.sortOrder - 1;
        return response;
      } else {
        return null;
      }
    } catch (e) {
      console.error("Project Move failed: ", e);
      this.setError("Project Move", null, e);
      return null;
    }
  }
  async parentMove(taskId, newParentId, projectId) {
    try {
      const url = `${this.apiUrl}/${parentMove}`;
      const parentMovePayLoad = [{
        parentId: newParentId,
        projectId,
        taskId
      }];
      const response = await this.makeRequest("Project Move", url, "POST", parentMovePayLoad);
      if (response) {
        this.inboxProperties.sortOrder = response.sortOrder - 1;
        return response;
      } else {
      }
    } catch (e) {
      console.error("Parent Move failed: ", e);
      this.setError("Parent Move", null, e);
      return null;
    }
  }
  async makeRequest(operation, url, method, body) {
    let error = "";
    this.lastError = void 0;
    try {
      let requestOptions = {};
      if (operation == "Login") {
        requestOptions = this.createLoginRequestOptions(url, body);
      } else {
        requestOptions = this.createRequestOptions(method, url, body);
      }
      const result = await (0, import_obsidian4.requestUrl)(requestOptions);
      if (result.status != 200) {
        this.setError(operation, result, null);
        return null;
      }
      return result.json;
    } catch (exception) {
      this.setError(operation, null, exception);
      console.error(exception);
      return null;
    }
  }
  createLoginRequestOptions(url, body) {
    const headers = {
      // 'origin': 'http://ticktick.com',
      "Content-Type": "application/json",
      "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0",
      "x-device": '{"platform":"web","os":"Windows 10","device":"Firefox 117.0","name":"","version":4576,"id":"64f9effe6edff918986b5f71","channel":"website","campaign":"","websocket":""}',
      "Cookie": `t=${this.token}; AWSALB=pSOIrwzvoncz4ZewmeDJ7PMpbA5nOrji5o1tcb1yXSzeEDKmqlk/maPqPiqTGaXJLQk0yokDm0WtcoxmwemccVHh+sFbA59Mx1MBjBFVV9vACQO5HGpv8eO5pXYL; AWSALBCORS=pSOIrwzvoncz4ZewmeDJ7PMpbA5nOrji5o1tcb1yXSzeEDKmqlk/maPqPiqTGaXJLQk0yokDm0WtcoxmwemccVHh+sFbA59Mx1MBjBFVV9vACQO5HGpv8eO5pXYL`
    };
    const options = {
      method: "POST",
      url,
      headers,
      contentType: "application/json",
      body: body ? JSON.stringify(body) : void 0,
      throw: false
    };
    return options;
  }
  createRequestOptions(method, url, body) {
    let headers = {
      //For the record, the bloody rules keep changin and we might have to the _csrf_token
      "Content-Type": "application/json",
      "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0",
      "x-device": '{"platform":"web","os":"Windows 10","device":"Firefox 117.0","name":"","version":4576,"id":"64f9effe6edff918986b5f71","channel":"website","campaign":"","websocket":""}',
      "Cookie": `t=${this.token}; AWSALB=pSOIrwzvoncz4ZewmeDJ7PMpbA5nOrji5o1tcb1yXSzeEDKmqlk/maPqPiqTGaXJLQk0yokDm0WtcoxmwemccVHh+sFbA59Mx1MBjBFVV9vACQO5HGpv8eO5pXYL; AWSALBCORS=pSOIrwzvoncz4ZewmeDJ7PMpbA5nOrji5o1tcb1yXSzeEDKmqlk/maPqPiqTGaXJLQk0yokDm0WtcoxmwemccVHh+sFbA59Mx1MBjBFVV9vACQO5HGpv8eO5pXYL`,
      "t": `${this.token}`
    };
    const options = {
      method,
      url,
      headers,
      contentType: "application/json",
      body: body ? JSON.stringify(body) : void 0,
      throw: false
    };
    return options;
  }
  setError(operation, response, error) {
    if (response) {
      const statusCode = response.status;
      let errorMessage;
      try {
        errorMessage = response.json;
      } catch (e) {
        console.log("Bad JSON response");
        console.log("Trying Text.");
        try {
          errorMessage = this.extractTitleContent(response.text);
          console.error("Error: ", errorMessage);
        } catch (e2) {
          console.log("Bad text response");
          console.log("No error message.");
          errorMessage = "No Error message received.";
        }
      }
      this._lastError = { operation, statusCode, errorMessage };
    } else {
      let errorMessage;
      let statusCode = 666;
      if (error) {
        errorMessage = error;
      } else {
        errorMessage = "Unknown Error";
      }
      console.error(operation, errorMessage);
      this._lastError = { operation, statusCode, errorMessage };
    }
  }
  //For now: we're not doing the checkpoint bump stuff. If we have more issues...
  getNextCheckPoint() {
    let dtDate = new Date(this._checkpoint);
    console.log("Date: ", dtDate);
    dtDate.setDate(dtDate.getDate() + 15);
    console.log("Date: ", dtDate);
    console.log("Attempted Checkpoint: ", dtDate.getTime());
    this._checkpoint = dtDate.getTime();
    console.warn("Check point has been changed.", this._checkpoint);
    return this._checkpoint;
  }
  extractTitleContent(inputString) {
    const startTag = "<title>";
    const endTag = "</title>";
    const startIndex = inputString.indexOf(startTag) + startTag.length;
    const endIndex = inputString.indexOf(endTag);
    return inputString.substring(startIndex, endIndex);
  }
};

// src/TicktickRestAPI.ts
var import_obsidian5 = require("obsidian");
var TickTickRestAPI = class {
  app;
  plugin;
  api;
  token;
  baseUrl;
  constructor(app2, plugin, api) {
    this.app = app2;
    this.plugin = plugin;
    this.token = this.plugin.settings.token;
    this.baseURL = this.plugin.settings.baseURL;
    if (!this.token || this.token === "") {
      new import_obsidian5.Notice("Please login from Settings.", 0);
      this.api = null;
      console.error("No Token");
      throw new Error("API Not Initialized.");
    } else {
      if (this.plugin.settings.debugMode) {
        console.log(JSON.stringify({
          baseUrl: this.baseURL,
          token: "[" + this.token.substring(0, 10) + "...] len: " + this.token.length
        }));
      }
      if (!api) {
        this.api = new Tick({
          baseUrl: this.plugin.settings.baseURL,
          token: this.token,
          checkPoint: this.plugin.settings.checkPoint
        });
        this.api.inboxProperties = { id: this.plugin.settings.inboxID, sortOrder: 0 };
        this.plugin.settings.checkPoint = this.api.checkpoint;
      } else {
        this.api = api;
      }
      this.plugin.settings.apiInitialized = false;
    }
  }
  async initializeAPI() {
    if (this.api === null || this.api === void 0) {
      throw new Error("API Not Initialized. Please restart Obsidian.");
    }
    let apiInitialized = this.plugin.settings.apiInitialized;
    if (!apiInitialized)
      try {
        const userSettings = await this.api?.getUserSettings();
        if (userSettings) {
          apiInitialized = true;
          await this.api?.getInboxProperties();
          let bSaveSettings = false;
          if (this.plugin.settings.inboxID != this.api?.inboxId) {
            bSaveSettings = true;
          }
          this.plugin.settings.inboxID = this.api?.inboxId;
          this.token = this.plugin.settings.token = this.api?.token;
          this.plugin.settings.inboxName = "Inbox";
          if (!this.plugin.settings.defaultProjectId) {
            this.plugin.settings.defaultProjectId = this.api?.inboxId;
            this.plugin.settings.defaultProjectName = "Inbox";
          }
          if (bSaveSettings) {
            await this.plugin.saveSettings();
          }
        } else {
          console.error(this.api?.lastError);
        }
        this.plugin.settings.apiInitialized = apiInitialized;
        if (apiInitialized) {
          if (this.plugin.settings.debugMode) {
            console.log(`Logged In: ${apiInitialized}`);
          }
        } else {
          new import_obsidian5.Notice("Login failed, please login through settings.");
          console.error("Login failed! ");
          this.plugin.settings.apiInitialized = false;
        }
      } catch (error) {
        console.error("Login failed! ", error);
        this.plugin.settings.apiInitialized = false;
        apiInitialized = false;
        new import_obsidian5.Notice(`Login failed: ${error}
Please login again`);
      } finally {
        this.plugin.saveSettings();
      }
  }
  async AddTask(taskToAdd) {
    await this.initializeAPI();
    try {
      taskToAdd.dueDate = "";
      const newTask = await this.api?.addTask(taskToAdd);
      return newTask;
    } catch (error) {
      throw new Error(`Error adding task: ${error.message}`);
    }
  }
  async deleteTask(deletedTaskId, deletedTaskProjectId) {
    await this.initializeAPI();
    try {
      const response = await this.api?.deleteTask(deletedTaskId, deletedTaskProjectId);
      return response;
    } catch (error) {
      throw new Error(`Error deleting task: ${error.message}`);
    }
  }
  async getProjectSections(projectId) {
    await this.initializeAPI();
    try {
      const response = await this.api?.getProjectSections(projectId);
      return response;
    } catch (error) {
      throw new Error(`Error getting Sections: ${error.message}`);
    }
  }
  //options:{ projectId?: string, section_id?: string, label?: string , filter?: string,lang?: string, ids?: Array<string>}
  // async GetActiveTasks(options:{ projectId?: string, section_id?: string, label?: string , filter?: string,lang?: string, ids?: Array<string>}) {
  async GetActiveTasks() {
    await this.initializeAPI();
    try {
      const result = await this.api?.getTasks();
      return result;
    } catch (error) {
      throw new Error(`Error get active tasks: ${error.message}`);
    }
  }
  //Also note that to remove the due date of a task completely, you should set the due_string parameter to no date or no due date.
  //api does not have a function to update task project id
  async UpdateTask(taskToUpdate) {
    await this.initializeAPI();
    try {
      taskToUpdate.dueDate = "";
      let updatedTask = {};
      const updateResult = await this.api?.updateTask(taskToUpdate);
      if (JSON.stringify(updateResult.id2error) === "{}") {
        updatedTask = this.getTaskById(taskToUpdate.id, taskToUpdate.projectId);
      }
      return updatedTask;
    } catch (error) {
      throw new Error(`Error updating task: ${error.message}`);
    }
  }
  async modifyTaskStatus(taskId, projectId, taskStatus) {
    await this.initializeAPI();
    try {
      let task = await this.api?.getTask(taskId, projectId);
      if (task) {
        task.status = taskStatus;
        const isSuccess = await this.api?.updateTask(task);
        return isSuccess;
      } else {
        return false;
      }
    } catch (error) {
      console.error("Error modifying task:", error);
      return;
    }
  }
  //open a task
  async OpenTask(taskId, projectId) {
    await this.initializeAPI();
    try {
      this.modifyTaskStatus(taskId, projectId, 0);
    } catch (error) {
      console.error("Error open a task:", error);
      return;
    }
  }
  // Close a task in TickTick API
  async CloseTask(taskId, projectId) {
    await this.initializeAPI();
    try {
      let result = this.modifyTaskStatus(taskId, projectId, 2);
      return result;
    } catch (error) {
      console.error("Error closing task:", error);
      throw error;
    }
  }
  // get a task by Id
  async getTaskById(taskId, projectId) {
    await this.initializeAPI();
    if (!taskId) {
      throw new Error("taskId is required");
    }
    try {
      const task = await this.api?.getTask(taskId, projectId);
      return task;
    } catch (error) {
      if (error.response && error.response.status) {
        const statusCode = error.response.status;
        throw new Error(`Error retrieving task. Status code: ${statusCode}`);
      } else {
        throw new Error(`Error retrieving task: ${error.message}`);
      }
    }
  }
  //get a task due by id
  async getTaskDueById(taskId) {
    await this.initializeAPI();
    if (!taskId) {
      throw new Error("taskId is required");
    }
    try {
      const task = await this.api?.getTask(taskId, null);
      const due = task?.dueDate ?? null;
      return due;
    } catch (error) {
      throw new Error(`Error get Task Due By ID: ${error.message}`);
    }
  }
  //get all projects
  async GetAllProjects() {
    await this.initializeAPI();
    try {
      const result = await this.api?.getProjects();
      return result;
    } catch (error) {
      console.error("Error get all projects", error);
      return [];
    }
  }
  //get project groups
  async GetProjectGroups() {
    await this.initializeAPI();
    try {
      const result = await this.api?.getProjectGroups();
      if (result?.length == 0 && this.api?.lastError) {
        if (this.api?.lastError.statusCode != 200) {
          let lastError = this.api?.lastError;
          console.error("Error: ", lastError.operation, lastError.statusCode, lastError.errorMessage);
          throw new Error(lastError.errorMessage);
        }
      }
      return result;
    } catch (error) {
      console.error("Error get project groups", error);
      new import_obsidian5.Notice("Unable to get Tasks: " + error, 0);
      return false;
    }
  }
  //TODO: Added for completeness. Evaluate use later.
  async getUserResources() {
    await this.initializeAPI();
    try {
      const result = await this.api?.getUserSettings();
      return result;
    } catch (error) {
      console.error("Error get user resources", error);
      return [];
    }
  }
  //TODO: Added for completeness. Evaluate use later.
  async getAllCompletedItems() {
    await this.initializeAPI();
    try {
      const result = await this.api?.getAllCompletedItems();
      return result;
    } catch (error) {
      console.error("Error get all completed items", error);
      return [];
    }
  }
  //TODO: Will need interpretation
  async getAllResources() {
    await this.initializeAPI();
    try {
      const result = await this.api?.getAllResources();
      return result;
    } catch (error) {
      console.error("Error get all resources", error);
      return [];
    }
  }
  //TODO: Will need interpretation
  async getAllTasks() {
    await this.initializeAPI();
    try {
      const result = await this.api?.getTaskDetails();
      if (!result || result.length === 0 && this.api?.lastError.statusCode != 200) {
        throw new Error("No Results.");
      }
      return result;
    } catch (error) {
      console.error("Error get all Tasks", error);
      return [];
    }
  }
  async exportData() {
    await this.initializeAPI();
    const result = await this.api?.exportData();
    if (!result) {
      let error = JSON.stringify(this.api?.lastError);
      error = error.replace(/{/g, "\n").replace(/,/g, "\n");
      throw new Error(`Back up failed ${error}`);
    }
    return result;
  }
  async moveTaskProject(task, fromProject, toProject) {
    await this.initializeAPI();
    let result = await this.api?.projectMove(task.id, fromProject, toProject);
    if (!result) {
      console.error("Project Moved Failed: ", this.api?.lastError);
    }
    await this.api?.updateTask(task);
  }
  async moveTaskParent(taskId, newParentId, projectId) {
    const task = await this.api?.getTask(taskId, projectId);
    if (task) {
      task.parentId = newParentId;
      let result = await this.api?.updateTask(task);
      result = await this.api?.parentMove(taskId, newParentId, projectId);
    }
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  defaultProjectId: "",
  token: "",
  initialized: false,
  apiInitialized: false,
  defaultProjectName: "Inbox",
  baseURL: "ticktick.com",
  automaticSynchronizationInterval: 300,
  //default aync interval 300s
  TickTickTasksData: { "projects": [], "tasks": [] },
  fileMetadata: {},
  enableFullVaultSync: false,
  statistics: {},
  debugMode: false,
  TickTickTasksFilePath: "/",
  inboxName: "",
  inboxID: "",
  SyncProject: "",
  SyncTag: "",
  syncLock: false,
  checkPoint: 0
};
var TickTickSyncSettingTab = class extends import_obsidian6.PluginSettingTab {
  plugin;
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  async display() {
    let bProjectsLoaded = false;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings" });
    if (this.plugin.settings.TickTickTasksData?.projects) {
      bProjectsLoaded = true;
    }
    const myProjectsOptions = this.plugin.settings.TickTickTasksData?.projects?.reduce((obj, item) => {
      try {
        obj[item.id.toString()] = item.name;
        return obj;
      } catch {
        console.error("Failed to Load", item.name);
      }
    }, {});
    const providerOptions = { "1": "ticktick.com", "2": "dida365.com" };
    const currentVal = Object.keys(providerOptions).find((key) => providerOptions[key] === this.plugin.settings.baseURL);
    containerEl.createEl("hr");
    containerEl.createEl("h1", { text: "Access Control" });
    let userName;
    let userPassword;
    let bDisplayLogin = !userName && !userPassword;
    new import_obsidian6.Setting(containerEl).setName("TickTick/Dida").setDesc("Select home server").setHeading().addDropdown(
      (component) => component.addOptions(providerOptions).setValue(currentVal).onChange(async (value) => {
        this.plugin.settings.baseURL = providerOptions[value];
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Username").setDesc("...").addText(
      (text) => text.setPlaceholder("User Name").setValue("").onChange(async (value) => {
        userName = value;
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Password").setDesc("...").addText(
      (text) => text.setPlaceholder("Password").setValue("").onChange(async (value) => {
        userPassword = value;
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Login").setDesc("Please login here.").setHeading().addButton((loginBtn) => {
      loginBtn.setClass("ts_login_button");
      loginBtn.setButtonText("Login");
      loginBtn.setTooltip("Click To Login");
      loginBtn.onClick(async () => {
        if (!userName || !userPassword) {
          new import_obsidian6.Notice("Please fill in both User Name and Password");
        } else {
          if (this.plugin.tickTickRestAPI) {
            delete this.plugin.tickTickRestAPI;
          }
          const api = new Tick({
            username: userName,
            password: userPassword,
            baseUrl: this.plugin.settings.baseURL,
            token: "",
            checkPoint: this.plugin.settings.checkPoint
          });
          const loggedIn = await api.login();
          if (loggedIn) {
            this.plugin.settings.token = api.token;
            this.plugin.tickTickRestAPI = new TickTickRestAPI(this.app, this.plugin, api);
            this.plugin.tickTickRestAPI.token = this.plugin.settings.token = api.token;
            this.plugin.settings.inboxID = api.inboxId;
            this.plugin.settings.inboxName = "Inbox";
            this.plugin.settings.apiInitialized = true;
            this.plugin.settings.checkPoint = api.checkpoint;
            await this.plugin.saveSettings();
            new import_obsidian6.Notice("Logged in! Fetching projects", 0);
            await this.plugin.cacheOperation?.saveProjectsToCache();
            new import_obsidian6.Notice("Project Fetch complete.", 0);
            await this.plugin.saveSettings();
            this.display();
          } else {
            this.plugin.settings.token = "";
            this.plugin.settings.apiInitialized = false;
            this.plugin.tickTickRestAPI = null;
            let errMsg = "Login Failed. ";
            if (api.lastError) {
              errMsg = errMsg + JSON.stringify(api.lastError);
              errMsg = errMsg.replace(/{/g, "\n").replace(/,/g, "\n");
            } else {
              errMsg = errMsg + "\nUnknown error occurred.";
            }
            new import_obsidian6.Notice(errMsg, 0);
          }
        }
      });
    });
    if (this.plugin.settings.apiInitialized && bProjectsLoaded) {
      containerEl.createEl("hr");
      containerEl.createEl("h1", { text: "Sync control" });
      this.add_default_folder_path();
      new import_obsidian6.Setting(containerEl).setName("Default project").setDesc("New tasks are automatically synced to the default project. You can modify the project here.").addDropdown(
        (component) => component.addOption(this.plugin.settings.defaultProjectId, this.plugin.settings.defaultProjectName).addOptions(myProjectsOptions).onChange(async (value) => {
          this.plugin.settings.defaultProjectId = value;
          this.plugin.settings.defaultProjectName = await this.plugin.cacheOperation?.getProjectNameByIdFromCache(value);
          const defaultProjectFileName = this.plugin.settings.defaultProjectName + ".md";
          const defaultProjectFile = await this.plugin.fileOperation?.getOrCreateDefaultFile(defaultProjectFileName);
          if (defaultProjectFile) {
            this.plugin.cacheOperation?.setDefaultProjectIdForFilepath(defaultProjectFile.path, this.plugin.settings.defaultProjectId);
          } else {
            new import_obsidian6.Notice("Unable to create file for selected default project " + this.plugin.settings.defaultProjectName);
          }
          await this.plugin.saveSettings();
        })
      );
      containerEl.createEl("hr");
      containerEl.createEl("h2", { text: "Limit synchronization" });
      new import_obsidian6.Setting(containerEl).setDesc("To limit the tasks TickTickSync will synchronize from TickTick to Obsidian select a tag or project(list) below. If a tag is entered, only tasks with that tag will be synchronized. If a project(list) is selected, only tasks in that project will be synchronized. If both are chosen only tasks with that tag in that project will be synchronized.");
      new import_obsidian6.Setting(containerEl).setName("Project").setDesc("Only tasks in this project will be synchronized.").addDropdown(
        (component) => component.addOption("", "").addOptions(myProjectsOptions).setValue(this.plugin.settings.SyncProject).onChange(async (value) => {
          this.plugin.settings.SyncProject = value;
          const fileMetaData = this.plugin.settings.fileMetadata;
          const defaultProjectFileEntry = Object.values(fileMetaData).find((obj) => obj.defaultProjectId === this.plugin.settings.SyncProject);
          if (!defaultProjectFileEntry) {
            const noticeMsg = "Did not find a default Project File for Project " + myProjectsOptions?.[value] + ". Please create a file and set it's default to this project, or select a file to be the default for this project.";
            new import_obsidian6.Notice(noticeMsg, 0);
          }
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian6.Setting(containerEl).setName("Tag").setDesc('Tag value, no "#"').addText(
        (text) => text.setValue(this.plugin.settings.SyncTag).onChange(async (value) => {
          this.plugin.settings.SyncTag = value;
          await this.plugin.saveSettings();
        })
      );
    }
    containerEl.createEl("hr");
    new import_obsidian6.Setting(containerEl).setName("Automatic sync interval time").setDesc("Please specify the desired interval time, with seconds as the default unit. The default setting is 300 seconds, which corresponds to syncing once every 5 minutes. You can customize it, but it cannot be lower than 20 seconds.").addText(
      (text) => text.setPlaceholder("Sync interval").setValue(this.plugin.settings.automaticSynchronizationInterval.toString()).onChange(async (value) => {
        const intervalNum = Number(value);
        if (isNaN(intervalNum)) {
          new import_obsidian6.Notice(`Wrong type,please enter a number.`);
          return;
        }
        if (intervalNum < 20) {
          new import_obsidian6.Notice(`The synchronization interval time cannot be less than 20 seconds.`);
          return;
        }
        if (!Number.isInteger(intervalNum)) {
          new import_obsidian6.Notice("The synchronization interval must be an integer.");
          return;
        }
        this.plugin.settings.automaticSynchronizationInterval = intervalNum;
        this.plugin.saveSettings();
        new import_obsidian6.Notice("Settings have been updated.");
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Full vault sync").setDesc("By default, only tasks marked with #TickTick are synchronized. If this option is turned on, all tasks in the vault will be synchronized.**NOTE: This includes all tasks that are currently Items of a task.**").addToggle(
      (component) => component.setValue(this.plugin.settings.enableFullVaultSync).onChange(async (value) => {
        if (!this.plugin.settings.enableFullVaultSync) {
          const bConfirmation = await this.confirmFullSync();
          if (bConfirmation) {
            this.plugin.settings.enableFullVaultSync = true;
            await this.plugin.saveSettings();
            new import_obsidian6.Notice("Full vault sync is enabled.");
          } else {
            this.plugin.settings.enableFullVaultSync = false;
            await this.plugin.saveSettings();
            new import_obsidian6.Notice("Full vault sync not enabled.");
          }
          this.display();
        } else {
          this.plugin.settings.enableFullVaultSync = value;
          await this.plugin.saveSettings();
          new import_obsidian6.Notice("Full vault sync is disabled.");
        }
      })
    );
    if (this.plugin.settings.apiInitialized) {
      containerEl.createEl("hr");
      containerEl.createEl("h1", { text: "Manual operations" });
      new import_obsidian6.Setting(containerEl).setName("Manual sync").setDesc("Manually perform a synchronization task.").addButton(
        (button) => button.setButtonText("Sync").onClick(async () => {
          if (!this.plugin.settings.apiInitialized) {
            new import_obsidian6.Notice(`Please log in from settings first`);
            return;
          }
          try {
            await this.plugin.scheduledSynchronization();
            await this.plugin.unlockSynclock();
            new import_obsidian6.Notice(`Sync completed..`);
          } catch (error) {
            new import_obsidian6.Notice(`An error occurred while syncing.:${error}`);
            await this.plugin.unlockSynclock();
          }
        })
      );
      new import_obsidian6.Setting(containerEl).setName("Check database").setDesc("Check for possible issues: sync error, file renaming not updated, or missed tasks not synchronized.").addButton(
        (button) => button.setButtonText("Check Database").onClick(async () => {
          await this.checkDataBase();
        })
      );
    }
    new import_obsidian6.Setting(containerEl).setName("Debug mode").setDesc("After enabling this option, all log information will be output to the console, which can help check for errors.").addToggle(
      (component) => component.setValue(this.plugin.settings.debugMode).onChange((value) => {
        this.plugin.settings.debugMode = value;
        this.plugin.saveSettings();
      })
    );
    if (this.plugin.settings.apiInitialized) {
      new import_obsidian6.Setting(containerEl).setName("Backup TickTick data").setDesc("Click to backup TickTick data, The backed-up files will be stored in the root directory of the Obsidian vault.").addButton(
        (button) => button.setButtonText("Backup").onClick(() => {
          if (!this.plugin.settings.apiInitialized) {
            new import_obsidian6.Notice(`Please log in from settings first`);
            return;
          }
          this.plugin.tickTickSync?.backupTickTickAllResources();
        })
      );
    }
  }
  async confirmFullSync() {
    const myModal = new ConfirmFullSyncModal(this.app, (result) => {
      this.ret = result;
    });
    const bConfirmation = await myModal.showModal();
    return bConfirmation;
  }
  async checkDataBase() {
    if (!this.plugin.settings.apiInitialized) {
      new import_obsidian6.Notice(`Please log in from settings first`);
      return;
    }
    console.log("checking file metadata");
    let fileNum = await this.plugin.cacheOperation?.checkFileMetadata();
    console.log("Number of files: ", fileNum);
    if (fileNum < 1) {
      console.log("File Metadata rebuild.");
      const allMDFiles = this.app.vault.getMarkdownFiles();
      allMDFiles.forEach((file) => {
        this.plugin.tickTickSync?.fullTextModifiedTaskCheck(file.path);
      });
    }
    this.plugin.saveSettings();
    const metadatas = await this.plugin.cacheOperation?.getFileMetadatas();
    if (!await this.plugin.checkAndHandleSyncLock())
      return;
    console.log("checking deleted tasks");
    for (const key in metadatas) {
      const value = metadatas[key];
      for (const taskDetails of value.TickTickTasks) {
        let taskObject;
        try {
          taskObject = await this.plugin.cacheOperation?.loadTaskFromCacheID(taskDetails.taskId);
        } catch (error) {
          console.error(`An error occurred while loading task cache: ${error.message}`);
        }
        if (!taskObject) {
          try {
            taskObject = await this.plugin.tickTickRestAPI?.getTaskById(taskDetails.taskId, null);
            if (taskObject && taskObject.deleted === 1) {
              await this.plugin.cacheOperation?.deleteTaskIdFromMetadata(key, taskDetails.taskId);
            }
          } catch (error) {
            if (error.message.includes("404")) {
              await this.plugin.cacheOperation?.deleteTaskIdFromMetadata(key, taskDetails.taskId);
              continue;
            } else {
              console.error(error);
              continue;
            }
          }
        }
      }
      ;
    }
    await this.plugin.saveSettings();
    console.log("checking renamed files -- This operation takes a while, please be patient.");
    try {
      for (const key in metadatas) {
        console.log("Checking Renamed: ", key);
        const value = metadatas[key];
        const obsidianURL = this.plugin.taskParser?.getObsidianUrlFromFilepath(key);
        for (const taskDetail of value.TickTickTasks) {
          let taskObject;
          try {
            taskObject = await this.plugin.cacheOperation?.loadTaskFromCacheID(taskDetail.taskId);
          } catch (error) {
            console.error(`An error occurred while loading task ${taskDetail.taskId} from cache: ${error.message}`);
          }
          if (!taskObject) {
            console.error(`Task ${taskDetail.id}: ${taskDetail.title} is not found.`);
            continue;
          }
          const oldTitle = taskObject?.title ?? "";
          if (!oldTitle.includes(obsidianURL)) {
            try {
              await this.plugin.tickTickSync?.updateTaskContent(key);
            } catch (error) {
              console.error(`An error occurred while updating task description: ${error.message}`);
            }
          }
        }
      }
      console.log("Done File Rename check.");
      try {
        console.log("checking unsynced tasks");
        const files = this.app.vault.getFiles();
        for (const v of files) {
          const i = files.indexOf(v);
          if (v.extension == "md") {
            console.log("Now looking at: ", v);
            try {
              console.log(`Scanning file ${v.path}`);
              await this.plugin.fileOperation?.addTickTickLinkToFile(v.path);
              if (this.plugin.settings.enableFullVaultSync) {
                await this.plugin.fileOperation?.addTickTickTagToFile(v.path);
              }
            } catch (error) {
              console.error(`An error occurred while check new tasks in the file: ${v.path}, ${error.message}`);
            }
          }
        }
        await this.plugin.unlockSynclock();
      } catch (Error2) {
        console.error(`An error occurred while checking for unsynced tasks.:${Error2}`);
        await this.plugin.unlockSynclock();
        return;
      }
      new import_obsidian6.Notice(`All files have been scanned.`);
    } catch (error) {
      console.error(`An error occurred while scanning the vault.:${error}`);
      await this.plugin.unlockSynclock();
    }
  }
  add_default_folder_path() {
    let folderSearch;
    new import_obsidian6.Setting(this.containerEl).setName("Default folder location").setDesc("Folder to be used for TickTick Tasks.").addSearch((cb) => {
      folderSearch = cb;
      new FolderSuggest(cb.inputEl);
      cb.setPlaceholder("Example: folder1/folder2").setValue(this.plugin.settings.TickTickTasksFilePath);
    }).addButton((cb) => {
      cb.setIcon("plus");
      cb.setTooltip("Add folder");
      cb.onClick(async () => {
        let new_folder = folderSearch?.getValue();
        const updatedFolder = await this.validateNewFolder(new_folder);
        if (this.plugin.settings.debugMode) {
          console.log("updated folder: ", updatedFolder);
        }
        if (updatedFolder) {
          folderSearch?.setValue(updatedFolder);
          this.plugin.settings.TickTickTasksFilePath = updatedFolder;
          await this.plugin.saveSettings();
        }
        this.display();
      });
    });
    ;
  }
  async validateNewFolder(new_folder) {
    if (new_folder && new_folder.length > 1 && /^[/\\]/.test(new_folder)) {
      new_folder = new_folder.substring(1);
    }
    let newFolderFile = this.app.vault.getAbstractFileByPath(new_folder);
    if (!newFolderFile) {
      try {
        newFolderFile = await this.app.vault.createFolder(new_folder);
        new import_obsidian6.Notice(`New folder ${newFolderFile.path} created.`);
        return newFolderFile?.path;
      } catch (error) {
        new import_obsidian6.Notice(`Folder ${new_folder} creation failed: ${error}. Please correct and try again.`, 0);
        return null;
      }
    } else {
      if (newFolderFile instanceof import_obsidian6.TFolder) {
        new import_obsidian6.Notice(`Default folder is now ${newFolderFile.path}.`);
        return newFolderFile.path;
      }
    }
  }
};

// src/TicktickSyncAPI.ts
var TickTickSyncAPI = class {
  app;
  plugin;
  constructor(app2, plugin) {
    this.app = app2;
    this.plugin = plugin;
  }
  //backup TickTick
  async getAllResources() {
    try {
      let data = this.plugin.tickTickRestAPI?.getAllResources();
      return data;
    } catch (error) {
      console.error(error);
      throw new Error("Failed to fetch all resources due to network error");
    }
  }
  async getUserResource() {
    try {
      let data = this.plugin.tickTickRestAPI?.getUserResources();
      return data;
    } catch (error) {
      console.error(error);
      throw new Error("Failed to fetch user resources due to network error");
    }
  }
  async getNonObsidianAllTasks() {
    try {
      const allActivity = await this.plugin.tickTickRestAPI?.GetActiveTasks();
      const filteredArray = allActivity;
      return filteredArray;
    } catch (err) {
      console.error("An error occurred:", err);
    }
  }
  filterActivityTasks(events, options) {
    return events.filter(
      (event) => (options.event_type ? event.event_type === options.event_type : true) && (options.object_type ? event.object_type === options.object_type : true)
    );
  }
  //get completed items activity
  //result {count:number,events:[]}
  async getCompletedItemsActivity() {
    const data = this.plugin.tickTickRestAPI?.getAllCompletedItems();
    return data;
  }
  catch(error) {
    console.error(error);
    throw new Error("Failed to fetch completed items due to network error");
  }
  //todo: this is getting all tasks
  //get uncompleted items activity
  //result {count:number,events:[]}
  async getUncompletedItemsActivity() {
    const data = this.plugin.tickTickRestAPI?.getTasks();
    return data;
  }
  //get non-obsidian completed event 
  //todo: this is getting all tasks
  async getNonObsidianCompletedItemsActivity() {
    const completedItemsActivity = await this.getCompletedItemsActivity();
    const completedItemsActivityEvents = completedItemsActivity.events;
    const filteredArray = completedItemsActivityEvents.filter((obj) => !obj.extra_data.client.includes("obsidian"));
    return filteredArray;
  }
  //get non-obsidian uncompleted event
  async getNonObsidianUncompletedItemsActivity() {
    const uncompletedItemsActivity = await this.getUncompletedItemsActivity();
    const uncompletedItemsActivityEvents = uncompletedItemsActivity.events;
    const filteredArray = uncompletedItemsActivityEvents.filter((obj) => !obj.extra_data.client.includes("obsidian"));
    return filteredArray;
  }
  async getUpdatedItemsActivity() {
    throw new Error("Updated Items call not implemented in TickTick. What do we need it for?");
  }
  // //get updated items activity
  // //result {count:number,events:[]}
  // async getUpdatedItemsActivity() {
  //     const accessToken = this.plugin.settings.TickTickAPIToken
  //     const url = 'https://api.TickTick.com/sync/v9/activity/get';
  //     const options = {
  //         method: 'POST',
  //         headers: {
  //             'Authorization': `Bearer ${accessToken}`,
  //             'Content-Type': 'application/x-www-form-urlencoded'
  //         },
  //         body: new URLSearchParams({
  //             'object_type': 'item',
  //             'event_type': 'updated'
  //         })
  //     };
  //     try {
  //         const response = await fetch(url, options);
  //         if (!response.ok) {
  //             throw new Error(`Failed to fetch updated items: ${response.status} ${response.statusText}`);
  //         }
  //         const data = await response.json();
  //         //console.log(data)
  //         return data;
  //     } catch (error) {
  //         console.error(error);
  //         throw new Error('Failed to fetch updated items due to network error');
  //     }
  // }
  //get non-obsidian updated event
  async getNonObsidianUpdatedItemsActivity() {
    const updatedItemsActivity = await this.getUpdatedItemsActivity();
    const updatedItemsActivityEvents = updatedItemsActivity.events;
    const filteredArray = updatedItemsActivityEvents.filter((obj) => {
      const client = obj.extra_data && obj.extra_data.client;
      return !client || !client.includes("obsidian");
    });
    return filteredArray;
  }
  async getProjectsActivity() {
    throw new Error("Project Activities no impmlemented in TickTick");
  }
  // //get completed items activity
  // //result {count:number,events:[]}
  // async getProjectsActivity() {
  //     const accessToken = this.plugin.settings.TickTickAPIToken
  //     const url = 'https://api.TickTick.com/sync/v9/activity/get';
  //     const options = {
  //         method: 'POST',
  //         headers: {
  //             'Authorization': `Bearer ${accessToken}`,
  //             'Content-Type': 'application/x-www-form-urlencoded'
  //         },
  //         body: new URLSearchParams({
  //             'object_type': 'project'
  //         })
  //     };
  //     try {
  //         const response = await fetch(url, options);
  //         if (!response.ok) {
  //             throw new Error(`Failed to fetch projects activities: ${response.status} ${response.statusText}`);
  //         }
  //         const data = await response.json();
  //         return data;
  //     } catch (error) {
  //         console.error(error);
  //         throw new Error('Failed to fetch projects activities due to network error');
  //     }
  // }
};

// node_modules/obsidian-task/src/Query/DateParser.ts
var chrono = __toESM(require_dist());

// node_modules/obsidian-task/src/Query/DateRange.ts
var DateRange = class {
  start;
  end;
  /**
   * Builds the date range. If start is after the end, the dates will be automatically reversed.
   * Start and end will be saved at 00:00 local time.
   * The stored values of are mutable.
   * Note that there is no validation of the start and end moment. They can be checked with start.isValid() and end.isValid().
   * @param start
   * @param end
   */
  constructor(start2, end2) {
    this.start = start2;
    this.end = end2;
    if (end2.isBefore(start2)) {
      this.start = end2;
      this.end = start2;
    }
    this.start = this.start.startOf("day");
    this.end = this.end.startOf("day");
  }
  /**
   * Builds a date range relative to today like this week/month/quarter/year.
   * @example <caption> construct a date range containing the current month.</caption>
   * const thisMonth = DateRange.buildRelative('month');
   * @param range one of 'week', 'month', 'quarter', 'year'
   * @returns
   */
  static buildRelative(range2) {
    const unitOfTime = range2 === "week" ? "isoWeek" : range2;
    return new DateRange(
      window.moment().startOf(unitOfTime).startOf("day"),
      window.moment().endOf(unitOfTime).startOf("day")
    );
  }
  /**
   * Builds an invalid date range with invalid momentks objects (https://momentjscom.readthedocs.io/en/latest/moment/09-utilities/02-invalid/).
   * For example if the parsing has gone wrong.
   * @returns
   */
  static buildInvalid() {
    return new DateRange(window.moment.invalid(), window.moment.invalid());
  }
  /**
   * Check if the both dates of the date range are valid in terms of momentjs.
   * @returns true if both dates are valid
   */
  isValid() {
    return this.start.isValid() && this.end.isValid();
  }
  /**
   * Move the date range to the previous week/month/quarter/year.
   * Make sure that the duration in the parameters matches the range size, for example subtracting a month from a week long range was not tested.
   * @param duration one of 'week'/'month'/'quarter'/'year'
   */
  moveToPrevious(duration) {
    const delta = window.moment.duration(1, duration);
    this.start.subtract(delta);
    this.end.subtract(delta);
    if (duration === "month" || duration === "quarter") {
      this.end = this.end.endOf(duration).startOf("day");
    }
  }
  /**
   * Move the date range to the next week/month/quarter/year.
   * Make sure that the duration in the parameters matches the range size, for example subtracting a month from a week long range was not tested.
   * @param duration one of 'week'/'month'/'quarter'/'year'
   */
  moveToNext(duration) {
    const delta = window.moment.duration(1, duration);
    this.start.add(delta);
    this.end.add(delta);
    if (duration === "month" || duration === "quarter") {
      this.end = this.end.endOf(duration).startOf("day");
    }
  }
};

// node_modules/obsidian-task/src/Query/DateParser.ts
var DateParser = class {
  static parseDate(input, forwardDate = false) {
    return window.moment(
      chrono.parseDate(input, void 0, {
        forwardDate
      })
    ).startOf("day");
  }
  /**
   * Parse a line and extract a pair of dates, returned in a tuple, sorted by date.
   * @param input - any pair of dates, separate by one or more spaces '17 August 2013 19 August 2013',
   *                or a single date.
   * @param forwardDate - if true, and date is ambiguous, chrono will return dates in the future
   * @return - A Tuple of dates. If both input dates are invalid, then both output dates will be invalid.
   */
  static parseDateRange(input, forwardDate = false) {
    const dateRangeParsers = [
      // Try parsing a relative date range like 'current month'
      DateParser.parseRelativeDateRange,
      // Try '2022-W10' otherwise
      DateParser.parseNumberedDateRange,
      // If previous failed, fallback on absolute date range with chrono
      DateParser.parseAbsoluteDateRange
    ];
    for (const parser of dateRangeParsers) {
      const parsedDateRange = parser(input, forwardDate);
      if (parsedDateRange.isValid()) {
        return parsedDateRange;
      }
    }
    return DateRange.buildInvalid();
  }
  static parseAbsoluteDateRange(input, forwardDate) {
    const result = chrono.parse(input, void 0, {
      forwardDate
    });
    if (result.length === 0) {
      return DateRange.buildInvalid();
    }
    const startDate = result[0].start;
    const endDate = result[1] && result[1].start ? result[1].start : startDate;
    const start2 = window.moment(startDate.date());
    const end2 = window.moment(endDate.date());
    return new DateRange(start2, end2);
  }
  static parseRelativeDateRange(input, _forwardDate) {
    const relativeDateRangeRegexp = /(last|this|next) (week|month|quarter|year)/;
    const relativeDateRangeMatch = input.match(relativeDateRangeRegexp);
    if (relativeDateRangeMatch && relativeDateRangeMatch.length === 3) {
      const lastThisNext = relativeDateRangeMatch[1];
      const range2 = relativeDateRangeMatch[2];
      const dateRange = DateRange.buildRelative(range2);
      switch (lastThisNext) {
        case "last":
          dateRange.moveToPrevious(range2);
          break;
        case "next":
          dateRange.moveToNext(range2);
          break;
      }
      return dateRange;
    }
    return DateRange.buildInvalid();
  }
  static parseNumberedDateRange(input, _forwardDate) {
    const parsingVectors = [
      [/^\s*[0-9]{4}\s*$/, "YYYY", "year"],
      [/^\s*[0-9]{4}-Q[1-4]\s*$/, "YYYY-Q", "quarter"],
      [/^\s*[0-9]{4}-[0-9]{2}\s*$/, "YYYY-MM", "month"],
      [/^\s*[0-9]{4}-W[0-9]{2}\s*$/, "YYYY-WW", "isoWeek"]
    ];
    for (const [regexp, dateFormat, range2] of parsingVectors) {
      const matched = input.match(regexp);
      if (matched) {
        const date = matched[0].trim();
        return new DateRange(
          window.moment(date, dateFormat).startOf(range2),
          window.moment(date, dateFormat).endOf(range2)
        );
      }
    }
    return DateRange.buildInvalid();
  }
};

// node_modules/obsidian-task/src/lib/DateAbbreviations.ts
var abbreviations = {
  td: "today",
  tm: "tomorrow",
  yd: "yesterday",
  tw: "this week",
  nw: "next week",
  weekend: "sat",
  we: "sat"
};
function doAutocomplete(date) {
  for (const [key, val] of Object.entries(abbreviations)) {
    date = date.replace(RegExp(`\\b${key}\\s`, "i"), val);
  }
  return date;
}

// node_modules/rrule/dist/esm/weekday.js
var ALL_WEEKDAYS = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
];
var Weekday = (
  /** @class */
  function() {
    function Weekday2(weekday, n) {
      if (n === 0)
        throw new Error("Can't create weekday with n == 0");
      this.weekday = weekday;
      this.n = n;
    }
    Weekday2.fromStr = function(str) {
      return new Weekday2(ALL_WEEKDAYS.indexOf(str));
    };
    Weekday2.prototype.nth = function(n) {
      return this.n === n ? this : new Weekday2(this.weekday, n);
    };
    Weekday2.prototype.equals = function(other) {
      return this.weekday === other.weekday && this.n === other.n;
    };
    Weekday2.prototype.toString = function() {
      var s = ALL_WEEKDAYS[this.weekday];
      if (this.n)
        s = (this.n > 0 ? "+" : "") + String(this.n) + s;
      return s;
    };
    Weekday2.prototype.getJsWeekday = function() {
      return this.weekday === 6 ? 0 : this.weekday + 1;
    };
    return Weekday2;
  }()
);

// node_modules/rrule/dist/esm/helpers.js
var isPresent = function(value) {
  return value !== null && value !== void 0;
};
var isNumber = function(value) {
  return typeof value === "number";
};
var isWeekdayStr = function(value) {
  return typeof value === "string" && ALL_WEEKDAYS.includes(value);
};
var isArray = Array.isArray;
var range = function(start2, end2) {
  if (end2 === void 0) {
    end2 = start2;
  }
  if (arguments.length === 1) {
    end2 = start2;
    start2 = 0;
  }
  var rang = [];
  for (var i = start2; i < end2; i++)
    rang.push(i);
  return rang;
};
var repeat = function(value, times) {
  var i = 0;
  var array = [];
  if (isArray(value)) {
    for (; i < times; i++)
      array[i] = [].concat(value);
  } else {
    for (; i < times; i++)
      array[i] = value;
  }
  return array;
};
var toArray = function(item) {
  if (isArray(item)) {
    return item;
  }
  return [item];
};
function padStart(item, targetLength, padString) {
  if (padString === void 0) {
    padString = " ";
  }
  var str = String(item);
  targetLength = targetLength >> 0;
  if (str.length > targetLength) {
    return String(str);
  }
  targetLength = targetLength - str.length;
  if (targetLength > padString.length) {
    padString += repeat(padString, targetLength / padString.length);
  }
  return padString.slice(0, targetLength) + String(str);
}
var split = function(str, sep, num) {
  var splits = str.split(sep);
  return num ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits;
};
var pymod = function(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
};
var divmod = function(a, b) {
  return { div: Math.floor(a / b), mod: pymod(a, b) };
};
var empty = function(obj) {
  return !isPresent(obj) || obj.length === 0;
};
var notEmpty = function(obj) {
  return !empty(obj);
};
var includes = function(arr, val) {
  return notEmpty(arr) && arr.indexOf(val) !== -1;
};

// node_modules/rrule/dist/esm/dateutil.js
var datetime = function(y, m, d, h, i, s) {
  if (h === void 0) {
    h = 0;
  }
  if (i === void 0) {
    i = 0;
  }
  if (s === void 0) {
    s = 0;
  }
  return new Date(Date.UTC(y, m - 1, d, h, i, s));
};
var MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var ONE_DAY = 1e3 * 60 * 60 * 24;
var MAXYEAR = 9999;
var ORDINAL_BASE = datetime(1970, 1, 1);
var PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5];
var isLeapYear = function(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var isDate = function(value) {
  return value instanceof Date;
};
var isValidDate = function(value) {
  return isDate(value) && !isNaN(value.getTime());
};
var daysBetween = function(date1, date2) {
  var date1ms = date1.getTime();
  var date2ms = date2.getTime();
  var differencems = date1ms - date2ms;
  return Math.round(differencems / ONE_DAY);
};
var toOrdinal = function(date) {
  return daysBetween(date, ORDINAL_BASE);
};
var fromOrdinal = function(ordinal) {
  return new Date(ORDINAL_BASE.getTime() + ordinal * ONE_DAY);
};
var getMonthDays = function(date) {
  var month = date.getUTCMonth();
  return month === 1 && isLeapYear(date.getUTCFullYear()) ? 29 : MONTH_DAYS[month];
};
var getWeekday = function(date) {
  return PY_WEEKDAYS[date.getUTCDay()];
};
var monthRange = function(year, month) {
  var date = datetime(year, month + 1, 1);
  return [getWeekday(date), getMonthDays(date)];
};
var combine = function(date, time) {
  time = time || date;
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()));
};
var clone = function(date) {
  var dolly = new Date(date.getTime());
  return dolly;
};
var cloneDates = function(dates) {
  var clones = [];
  for (var i = 0; i < dates.length; i++) {
    clones.push(clone(dates[i]));
  }
  return clones;
};
var sort = function(dates) {
  dates.sort(function(a, b) {
    return a.getTime() - b.getTime();
  });
};
var timeToUntilString = function(time, utc) {
  if (utc === void 0) {
    utc = true;
  }
  var date = new Date(time);
  return [
    padStart(date.getUTCFullYear().toString(), 4, "0"),
    padStart(date.getUTCMonth() + 1, 2, "0"),
    padStart(date.getUTCDate(), 2, "0"),
    "T",
    padStart(date.getUTCHours(), 2, "0"),
    padStart(date.getUTCMinutes(), 2, "0"),
    padStart(date.getUTCSeconds(), 2, "0"),
    utc ? "Z" : ""
  ].join("");
};
var untilStringToDate = function(until) {
  var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
  var bits = re.exec(until);
  if (!bits)
    throw new Error("Invalid UNTIL value: ".concat(until));
  return new Date(Date.UTC(parseInt(bits[1], 10), parseInt(bits[2], 10) - 1, parseInt(bits[3], 10), parseInt(bits[5], 10) || 0, parseInt(bits[6], 10) || 0, parseInt(bits[7], 10) || 0));
};
var dateTZtoISO8601 = function(date, timeZone) {
  var dateStr = date.toLocaleString("sv-SE", { timeZone });
  return dateStr.replace(" ", "T") + "Z";
};
var dateInTimeZone = function(date, timeZone) {
  var localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  var dateInLocalTZ = new Date(dateTZtoISO8601(date, localTimeZone));
  var dateInTargetTZ = new Date(dateTZtoISO8601(date, timeZone !== null && timeZone !== void 0 ? timeZone : "UTC"));
  var tzOffset = dateInTargetTZ.getTime() - dateInLocalTZ.getTime();
  return new Date(date.getTime() - tzOffset);
};

// node_modules/rrule/dist/esm/iterresult.js
var IterResult = (
  /** @class */
  function() {
    function IterResult2(method, args) {
      this.minDate = null;
      this.maxDate = null;
      this._result = [];
      this.total = 0;
      this.method = method;
      this.args = args;
      if (method === "between") {
        this.maxDate = args.inc ? args.before : new Date(args.before.getTime() - 1);
        this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
      } else if (method === "before") {
        this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
      } else if (method === "after") {
        this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
      }
    }
    IterResult2.prototype.accept = function(date) {
      ++this.total;
      var tooEarly = this.minDate && date < this.minDate;
      var tooLate = this.maxDate && date > this.maxDate;
      if (this.method === "between") {
        if (tooEarly)
          return true;
        if (tooLate)
          return false;
      } else if (this.method === "before") {
        if (tooLate)
          return false;
      } else if (this.method === "after") {
        if (tooEarly)
          return true;
        this.add(date);
        return false;
      }
      return this.add(date);
    };
    IterResult2.prototype.add = function(date) {
      this._result.push(date);
      return true;
    };
    IterResult2.prototype.getValue = function() {
      var res = this._result;
      switch (this.method) {
        case "all":
        case "between":
          return res;
        case "before":
        case "after":
        default:
          return res.length ? res[res.length - 1] : null;
      }
    };
    IterResult2.prototype.clone = function() {
      return new IterResult2(this.method, this.args);
    };
    return IterResult2;
  }()
);
var iterresult_default = IterResult;

// node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/rrule/dist/esm/callbackiterresult.js
var CallbackIterResult = (
  /** @class */
  function(_super) {
    __extends(CallbackIterResult2, _super);
    function CallbackIterResult2(method, args, iterator) {
      var _this = _super.call(this, method, args) || this;
      _this.iterator = iterator;
      return _this;
    }
    CallbackIterResult2.prototype.add = function(date) {
      if (this.iterator(date, this._result.length)) {
        this._result.push(date);
        return true;
      }
      return false;
    };
    return CallbackIterResult2;
  }(iterresult_default)
);
var callbackiterresult_default = CallbackIterResult;

// node_modules/rrule/dist/esm/nlp/i18n.js
var ENGLISH = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
};
var i18n_default = ENGLISH;

// node_modules/rrule/dist/esm/nlp/totext.js
var contains2 = function(arr, val) {
  return arr.indexOf(val) !== -1;
};
var defaultGetText = function(id) {
  return id.toString();
};
var defaultDateFormatter = function(year, month, day) {
  return "".concat(month, " ").concat(day, ", ").concat(year);
};
var ToText = (
  /** @class */
  function() {
    function ToText2(rrule, gettext, language, dateFormatter) {
      if (gettext === void 0) {
        gettext = defaultGetText;
      }
      if (language === void 0) {
        language = i18n_default;
      }
      if (dateFormatter === void 0) {
        dateFormatter = defaultDateFormatter;
      }
      this.text = [];
      this.language = language || i18n_default;
      this.gettext = gettext;
      this.dateFormatter = dateFormatter;
      this.rrule = rrule;
      this.options = rrule.options;
      this.origOptions = rrule.origOptions;
      if (this.origOptions.bymonthday) {
        var bymonthday = [].concat(this.options.bymonthday);
        var bynmonthday = [].concat(this.options.bynmonthday);
        bymonthday.sort(function(a, b) {
          return a - b;
        });
        bynmonthday.sort(function(a, b) {
          return b - a;
        });
        this.bymonthday = bymonthday.concat(bynmonthday);
        if (!this.bymonthday.length)
          this.bymonthday = null;
      }
      if (isPresent(this.origOptions.byweekday)) {
        var byweekday = !isArray(this.origOptions.byweekday) ? [this.origOptions.byweekday] : this.origOptions.byweekday;
        var days = String(byweekday);
        this.byweekday = {
          allWeeks: byweekday.filter(function(weekday) {
            return !weekday.n;
          }),
          someWeeks: byweekday.filter(function(weekday) {
            return Boolean(weekday.n);
          }),
          isWeekdays: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") === -1 && days.indexOf("SU") === -1,
          isEveryDay: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") !== -1 && days.indexOf("SU") !== -1
        };
        var sortWeekDays = function(a, b) {
          return a.weekday - b.weekday;
        };
        this.byweekday.allWeeks.sort(sortWeekDays);
        this.byweekday.someWeeks.sort(sortWeekDays);
        if (!this.byweekday.allWeeks.length)
          this.byweekday.allWeeks = null;
        if (!this.byweekday.someWeeks.length)
          this.byweekday.someWeeks = null;
      } else {
        this.byweekday = null;
      }
    }
    ToText2.isFullyConvertible = function(rrule) {
      var canConvert = true;
      if (!(rrule.options.freq in ToText2.IMPLEMENTED))
        return false;
      if (rrule.origOptions.until && rrule.origOptions.count)
        return false;
      for (var key in rrule.origOptions) {
        if (contains2(["dtstart", "tzid", "wkst", "freq"], key))
          return true;
        if (!contains2(ToText2.IMPLEMENTED[rrule.options.freq], key))
          return false;
      }
      return canConvert;
    };
    ToText2.prototype.isFullyConvertible = function() {
      return ToText2.isFullyConvertible(this.rrule);
    };
    ToText2.prototype.toString = function() {
      var gettext = this.gettext;
      if (!(this.options.freq in ToText2.IMPLEMENTED)) {
        return gettext("RRule error: Unable to fully convert this rrule to text");
      }
      this.text = [gettext("every")];
      this[RRule.FREQUENCIES[this.options.freq]]();
      if (this.options.until) {
        this.add(gettext("until"));
        var until = this.options.until;
        this.add(this.dateFormatter(until.getUTCFullYear(), this.language.monthNames[until.getUTCMonth()], until.getUTCDate()));
      } else if (this.options.count) {
        this.add(gettext("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? gettext("times") : gettext("time"));
      }
      if (!this.isFullyConvertible())
        this.add(gettext("(~ approximate)"));
      return this.text.join("");
    };
    ToText2.prototype.HOURLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("hours") : gettext("hour"));
    };
    ToText2.prototype.MINUTELY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("minutes") : gettext("minute"));
    };
    ToText2.prototype.DAILY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
      } else {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      }
      if (this.origOptions.bymonth) {
        this.add(gettext("in"));
        this._bymonth();
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      } else if (this.origOptions.byhour) {
        this._byhour();
      }
    };
    ToText2.prototype.WEEKLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? gettext("weeks") : gettext("week"));
      }
      if (this.byweekday && this.byweekday.isWeekdays) {
        if (this.options.interval === 1) {
          this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
        } else {
          this.add(gettext("on")).add(gettext("weekdays"));
        }
      } else if (this.byweekday && this.byweekday.isEveryDay) {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      } else {
        if (this.options.interval === 1)
          this.add(gettext("week"));
        if (this.origOptions.bymonth) {
          this.add(gettext("in"));
          this._bymonth();
        }
        if (this.bymonthday) {
          this._bymonthday();
        } else if (this.byweekday) {
          this._byweekday();
        }
        if (this.origOptions.byhour) {
          this._byhour();
        }
      }
    };
    ToText2.prototype.MONTHLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString()).add(gettext("months"));
          if (this.plural(this.options.interval))
            this.add(gettext("in"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("months") : gettext("month"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(gettext("weekdays"));
      } else if (this.byweekday) {
        this._byweekday();
      }
    };
    ToText2.prototype.YEARLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
          this.add(gettext("years"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("years") : gettext("year"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      }
      if (this.options.byyearday) {
        this.add(gettext("on the")).add(this.list(this.options.byyearday, this.nth, gettext("and"))).add(gettext("day"));
      }
      if (this.options.byweekno) {
        this.add(gettext("in")).add(this.plural(this.options.byweekno.length) ? gettext("weeks") : gettext("week")).add(this.list(this.options.byweekno, void 0, gettext("and")));
      }
    };
    ToText2.prototype._bymonthday = function() {
      var gettext = this.gettext;
      if (this.byweekday && this.byweekday.allWeeks) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext("or"))).add(gettext("the")).add(this.list(this.bymonthday, this.nth, gettext("or")));
      } else {
        this.add(gettext("on the")).add(this.list(this.bymonthday, this.nth, gettext("and")));
      }
    };
    ToText2.prototype._byweekday = function() {
      var gettext = this.gettext;
      if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
      }
      if (this.byweekday.someWeeks) {
        if (this.byweekday.allWeeks)
          this.add(gettext("and"));
        this.add(gettext("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext("and")));
      }
    };
    ToText2.prototype._byhour = function() {
      var gettext = this.gettext;
      this.add(gettext("at")).add(this.list(this.origOptions.byhour, void 0, gettext("and")));
    };
    ToText2.prototype._bymonth = function() {
      this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
    };
    ToText2.prototype.nth = function(n) {
      n = parseInt(n.toString(), 10);
      var nth;
      var gettext = this.gettext;
      if (n === -1)
        return gettext("last");
      var npos = Math.abs(n);
      switch (npos) {
        case 1:
        case 21:
        case 31:
          nth = npos + gettext("st");
          break;
        case 2:
        case 22:
          nth = npos + gettext("nd");
          break;
        case 3:
        case 23:
          nth = npos + gettext("rd");
          break;
        default:
          nth = npos + gettext("th");
      }
      return n < 0 ? nth + " " + gettext("last") : nth;
    };
    ToText2.prototype.monthtext = function(m) {
      return this.language.monthNames[m - 1];
    };
    ToText2.prototype.weekdaytext = function(wday) {
      var weekday = isNumber(wday) ? (wday + 1) % 7 : wday.getJsWeekday();
      return (wday.n ? this.nth(wday.n) + " " : "") + this.language.dayNames[weekday];
    };
    ToText2.prototype.plural = function(n) {
      return n % 100 !== 1;
    };
    ToText2.prototype.add = function(s) {
      this.text.push(" ");
      this.text.push(s);
      return this;
    };
    ToText2.prototype.list = function(arr, callback, finalDelim, delim) {
      var _this = this;
      if (delim === void 0) {
        delim = ",";
      }
      if (!isArray(arr)) {
        arr = [arr];
      }
      var delimJoin = function(array, delimiter, finalDelimiter) {
        var list = "";
        for (var i = 0; i < array.length; i++) {
          if (i !== 0) {
            if (i === array.length - 1) {
              list += " " + finalDelimiter + " ";
            } else {
              list += delimiter + " ";
            }
          }
          list += array[i];
        }
        return list;
      };
      callback = callback || function(o) {
        return o.toString();
      };
      var realCallback = function(arg) {
        return callback && callback.call(_this, arg);
      };
      if (finalDelim) {
        return delimJoin(arr.map(realCallback), delim, finalDelim);
      } else {
        return arr.map(realCallback).join(delim + " ");
      }
    };
    return ToText2;
  }()
);
var totext_default = ToText;

// node_modules/rrule/dist/esm/nlp/parsetext.js
var Parser = (
  /** @class */
  function() {
    function Parser2(rules) {
      this.done = true;
      this.rules = rules;
    }
    Parser2.prototype.start = function(text) {
      this.text = text;
      this.done = false;
      return this.nextSymbol();
    };
    Parser2.prototype.isDone = function() {
      return this.done && this.symbol === null;
    };
    Parser2.prototype.nextSymbol = function() {
      var best;
      var bestSymbol;
      this.symbol = null;
      this.value = null;
      do {
        if (this.done)
          return false;
        var rule = void 0;
        best = null;
        for (var name_1 in this.rules) {
          rule = this.rules[name_1];
          var match = rule.exec(this.text);
          if (match) {
            if (best === null || match[0].length > best[0].length) {
              best = match;
              bestSymbol = name_1;
            }
          }
        }
        if (best != null) {
          this.text = this.text.substr(best[0].length);
          if (this.text === "")
            this.done = true;
        }
        if (best == null) {
          this.done = true;
          this.symbol = null;
          this.value = null;
          return;
        }
      } while (bestSymbol === "SKIP");
      this.symbol = bestSymbol;
      this.value = best;
      return true;
    };
    Parser2.prototype.accept = function(name) {
      if (this.symbol === name) {
        if (this.value) {
          var v = this.value;
          this.nextSymbol();
          return v;
        }
        this.nextSymbol();
        return true;
      }
      return false;
    };
    Parser2.prototype.acceptNumber = function() {
      return this.accept("number");
    };
    Parser2.prototype.expect = function(name) {
      if (this.accept(name))
        return true;
      throw new Error("expected " + name + " but found " + this.symbol);
    };
    return Parser2;
  }()
);
function parseText(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  var options = {};
  var ttr = new Parser(language.tokens);
  if (!ttr.start(text))
    return null;
  S();
  return options;
  function S() {
    ttr.expect("every");
    var n = ttr.acceptNumber();
    if (n)
      options.interval = parseInt(n[0], 10);
    if (ttr.isDone())
      throw new Error("Unexpected end");
    switch (ttr.symbol) {
      case "day(s)":
        options.freq = RRule.DAILY;
        if (ttr.nextSymbol()) {
          AT();
          F();
        }
        break;
      case "weekday(s)":
        options.freq = RRule.WEEKLY;
        options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        ttr.nextSymbol();
        AT();
        F();
        break;
      case "week(s)":
        options.freq = RRule.WEEKLY;
        if (ttr.nextSymbol()) {
          ON();
          AT();
          F();
        }
        break;
      case "hour(s)":
        options.freq = RRule.HOURLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "minute(s)":
        options.freq = RRule.MINUTELY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "month(s)":
        options.freq = RRule.MONTHLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "year(s)":
        options.freq = RRule.YEARLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        options.freq = RRule.WEEKLY;
        var key = ttr.symbol.substr(0, 2).toUpperCase();
        options.byweekday = [RRule[key]];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var wkd = decodeWKD();
          if (!wkd) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected weekday");
          }
          options.byweekday.push(RRule[wkd]);
          ttr.nextSymbol();
        }
        AT();
        MDAYs();
        F();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        options.freq = RRule.YEARLY;
        options.bymonth = [decodeM()];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var m = decodeM();
          if (!m) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected month");
          }
          options.bymonth.push(m);
          ttr.nextSymbol();
        }
        ON();
        F();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function ON() {
    var on = ttr.accept("on");
    var the = ttr.accept("the");
    if (!(on || the))
      return;
    do {
      var nth = decodeNTH();
      var wkd = decodeWKD();
      var m = decodeM();
      if (nth) {
        if (wkd) {
          ttr.nextSymbol();
          if (!options.byweekday)
            options.byweekday = [];
          options.byweekday.push(RRule[wkd].nth(nth));
        } else {
          if (!options.bymonthday)
            options.bymonthday = [];
          options.bymonthday.push(nth);
          ttr.accept("day(s)");
        }
      } else if (wkd) {
        ttr.nextSymbol();
        if (!options.byweekday)
          options.byweekday = [];
        options.byweekday.push(RRule[wkd]);
      } else if (ttr.symbol === "weekday(s)") {
        ttr.nextSymbol();
        if (!options.byweekday) {
          options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        }
      } else if (ttr.symbol === "week(s)") {
        ttr.nextSymbol();
        var n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + ", expected week number");
        }
        options.byweekno = [parseInt(n[0], 10)];
        while (ttr.accept("comma")) {
          n = ttr.acceptNumber();
          if (!n) {
            throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
          }
          options.byweekno.push(parseInt(n[0], 10));
        }
      } else if (m) {
        ttr.nextSymbol();
        if (!options.bymonth)
          options.bymonth = [];
        options.bymonth.push(m);
      } else {
        return;
      }
    } while (ttr.accept("comma") || ttr.accept("the") || ttr.accept("on"));
  }
  function AT() {
    var at = ttr.accept("at");
    if (!at)
      return;
    do {
      var n = ttr.acceptNumber();
      if (!n) {
        throw new Error("Unexpected symbol " + ttr.symbol + ", expected hour");
      }
      options.byhour = [parseInt(n[0], 10)];
      while (ttr.accept("comma")) {
        n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + "; expected hour");
        }
        options.byhour.push(parseInt(n[0], 10));
      }
    } while (ttr.accept("comma") || ttr.accept("at"));
  }
  function decodeM() {
    switch (ttr.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return false;
    }
  }
  function decodeWKD() {
    switch (ttr.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return ttr.symbol.substr(0, 2).toUpperCase();
      default:
        return false;
    }
  }
  function decodeNTH() {
    switch (ttr.symbol) {
      case "last":
        ttr.nextSymbol();
        return -1;
      case "first":
        ttr.nextSymbol();
        return 1;
      case "second":
        ttr.nextSymbol();
        return ttr.accept("last") ? -2 : 2;
      case "third":
        ttr.nextSymbol();
        return ttr.accept("last") ? -3 : 3;
      case "nth":
        var v = parseInt(ttr.value[1], 10);
        if (v < -366 || v > 366)
          throw new Error("Nth out of range: " + v);
        ttr.nextSymbol();
        return ttr.accept("last") ? -v : v;
      default:
        return false;
    }
  }
  function MDAYs() {
    ttr.accept("on");
    ttr.accept("the");
    var nth = decodeNTH();
    if (!nth)
      return;
    options.bymonthday = [nth];
    ttr.nextSymbol();
    while (ttr.accept("comma")) {
      nth = decodeNTH();
      if (!nth) {
        throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
      }
      options.bymonthday.push(nth);
      ttr.nextSymbol();
    }
  }
  function F() {
    if (ttr.symbol === "until") {
      var date = Date.parse(ttr.text);
      if (!date)
        throw new Error("Cannot parse until date:" + ttr.text);
      options.until = new Date(date);
    } else if (ttr.accept("for")) {
      options.count = parseInt(ttr.value[0], 10);
      ttr.expect("number");
    }
  }
}

// node_modules/rrule/dist/esm/types.js
var Frequency;
(function(Frequency2) {
  Frequency2[Frequency2["YEARLY"] = 0] = "YEARLY";
  Frequency2[Frequency2["MONTHLY"] = 1] = "MONTHLY";
  Frequency2[Frequency2["WEEKLY"] = 2] = "WEEKLY";
  Frequency2[Frequency2["DAILY"] = 3] = "DAILY";
  Frequency2[Frequency2["HOURLY"] = 4] = "HOURLY";
  Frequency2[Frequency2["MINUTELY"] = 5] = "MINUTELY";
  Frequency2[Frequency2["SECONDLY"] = 6] = "SECONDLY";
})(Frequency || (Frequency = {}));
function freqIsDailyOrGreater(freq) {
  return freq < Frequency.HOURLY;
}

// node_modules/rrule/dist/esm/nlp/index.js
var fromText = function(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  return new RRule(parseText(text, language) || void 0);
};
var common = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
totext_default.IMPLEMENTED = [];
totext_default.IMPLEMENTED[Frequency.HOURLY] = common;
totext_default.IMPLEMENTED[Frequency.MINUTELY] = common;
totext_default.IMPLEMENTED[Frequency.DAILY] = ["byhour"].concat(common);
totext_default.IMPLEMENTED[Frequency.WEEKLY] = common;
totext_default.IMPLEMENTED[Frequency.MONTHLY] = common;
totext_default.IMPLEMENTED[Frequency.YEARLY] = ["byweekno", "byyearday"].concat(common);
var toText = function(rrule, gettext, language, dateFormatter) {
  return new totext_default(rrule, gettext, language, dateFormatter).toString();
};
var isFullyConvertible = totext_default.isFullyConvertible;

// node_modules/rrule/dist/esm/datetime.js
var Time = (
  /** @class */
  function() {
    function Time2(hour, minute, second, millisecond) {
      this.hour = hour;
      this.minute = minute;
      this.second = second;
      this.millisecond = millisecond || 0;
    }
    Time2.prototype.getHours = function() {
      return this.hour;
    };
    Time2.prototype.getMinutes = function() {
      return this.minute;
    };
    Time2.prototype.getSeconds = function() {
      return this.second;
    };
    Time2.prototype.getMilliseconds = function() {
      return this.millisecond;
    };
    Time2.prototype.getTime = function() {
      return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
    };
    return Time2;
  }()
);
var DateTime = (
  /** @class */
  function(_super) {
    __extends(DateTime2, _super);
    function DateTime2(year, month, day, hour, minute, second, millisecond) {
      var _this = _super.call(this, hour, minute, second, millisecond) || this;
      _this.year = year;
      _this.month = month;
      _this.day = day;
      return _this;
    }
    DateTime2.fromDate = function(date) {
      return new this(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.valueOf() % 1e3);
    };
    DateTime2.prototype.getWeekday = function() {
      return getWeekday(new Date(this.getTime()));
    };
    DateTime2.prototype.getTime = function() {
      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
    };
    DateTime2.prototype.getDay = function() {
      return this.day;
    };
    DateTime2.prototype.getMonth = function() {
      return this.month;
    };
    DateTime2.prototype.getYear = function() {
      return this.year;
    };
    DateTime2.prototype.addYears = function(years) {
      this.year += years;
    };
    DateTime2.prototype.addMonths = function(months) {
      this.month += months;
      if (this.month > 12) {
        var yearDiv = Math.floor(this.month / 12);
        var monthMod = pymod(this.month, 12);
        this.month = monthMod;
        this.year += yearDiv;
        if (this.month === 0) {
          this.month = 12;
          --this.year;
        }
      }
    };
    DateTime2.prototype.addWeekly = function(days, wkst) {
      if (wkst > this.getWeekday()) {
        this.day += -(this.getWeekday() + 1 + (6 - wkst)) + days * 7;
      } else {
        this.day += -(this.getWeekday() - wkst) + days * 7;
      }
      this.fixDay();
    };
    DateTime2.prototype.addDaily = function(days) {
      this.day += days;
      this.fixDay();
    };
    DateTime2.prototype.addHours = function(hours, filtered, byhour) {
      if (filtered) {
        this.hour += Math.floor((23 - this.hour) / hours) * hours;
      }
      for (; ; ) {
        this.hour += hours;
        var _a = divmod(this.hour, 24), dayDiv = _a.div, hourMod = _a.mod;
        if (dayDiv) {
          this.hour = hourMod;
          this.addDaily(dayDiv);
        }
        if (empty(byhour) || includes(byhour, this.hour))
          break;
      }
    };
    DateTime2.prototype.addMinutes = function(minutes, filtered, byhour, byminute) {
      if (filtered) {
        this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / minutes) * minutes;
      }
      for (; ; ) {
        this.minute += minutes;
        var _a = divmod(this.minute, 60), hourDiv = _a.div, minuteMod = _a.mod;
        if (hourDiv) {
          this.minute = minuteMod;
          this.addHours(hourDiv, false, byhour);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute))) {
          break;
        }
      }
    };
    DateTime2.prototype.addSeconds = function(seconds, filtered, byhour, byminute, bysecond) {
      if (filtered) {
        this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / seconds) * seconds;
      }
      for (; ; ) {
        this.second += seconds;
        var _a = divmod(this.second, 60), minuteDiv = _a.div, secondMod = _a.mod;
        if (minuteDiv) {
          this.second = secondMod;
          this.addMinutes(minuteDiv, false, byhour, byminute);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute)) && (empty(bysecond) || includes(bysecond, this.second))) {
          break;
        }
      }
    };
    DateTime2.prototype.fixDay = function() {
      if (this.day <= 28) {
        return;
      }
      var daysinmonth = monthRange(this.year, this.month - 1)[1];
      if (this.day <= daysinmonth) {
        return;
      }
      while (this.day > daysinmonth) {
        this.day -= daysinmonth;
        ++this.month;
        if (this.month === 13) {
          this.month = 1;
          ++this.year;
          if (this.year > MAXYEAR) {
            return;
          }
        }
        daysinmonth = monthRange(this.year, this.month - 1)[1];
      }
    };
    DateTime2.prototype.add = function(options, filtered) {
      var freq = options.freq, interval = options.interval, wkst = options.wkst, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
      switch (freq) {
        case Frequency.YEARLY:
          return this.addYears(interval);
        case Frequency.MONTHLY:
          return this.addMonths(interval);
        case Frequency.WEEKLY:
          return this.addWeekly(interval, wkst);
        case Frequency.DAILY:
          return this.addDaily(interval);
        case Frequency.HOURLY:
          return this.addHours(interval, filtered, byhour);
        case Frequency.MINUTELY:
          return this.addMinutes(interval, filtered, byhour, byminute);
        case Frequency.SECONDLY:
          return this.addSeconds(interval, filtered, byhour, byminute, bysecond);
      }
    };
    return DateTime2;
  }(Time)
);

// node_modules/rrule/dist/esm/parseoptions.js
function initializeOptions(options) {
  var invalid = [];
  var keys = Object.keys(options);
  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (!includes(defaultKeys, key))
      invalid.push(key);
    if (isDate(options[key]) && !isValidDate(options[key])) {
      invalid.push(key);
    }
  }
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign({}, options);
}
function parseOptions(options) {
  var opts = __assign(__assign({}, DEFAULT_OPTIONS2), initializeOptions(options));
  if (isPresent(opts.byeaster))
    opts.freq = RRule.YEARLY;
  if (!(isPresent(opts.freq) && RRule.FREQUENCIES[opts.freq])) {
    throw new Error("Invalid frequency: ".concat(opts.freq, " ").concat(options.freq));
  }
  if (!opts.dtstart)
    opts.dtstart = new Date(new Date().setMilliseconds(0));
  if (!isPresent(opts.wkst)) {
    opts.wkst = RRule.MO.weekday;
  } else if (isNumber(opts.wkst)) {
  } else {
    opts.wkst = opts.wkst.weekday;
  }
  if (isPresent(opts.bysetpos)) {
    if (isNumber(opts.bysetpos))
      opts.bysetpos = [opts.bysetpos];
    for (var i = 0; i < opts.bysetpos.length; i++) {
      var v = opts.bysetpos[i];
      if (v === 0 || !(v >= -366 && v <= 366)) {
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
      }
    }
  }
  if (!(Boolean(opts.byweekno) || notEmpty(opts.byweekno) || notEmpty(opts.byyearday) || Boolean(opts.bymonthday) || notEmpty(opts.bymonthday) || isPresent(opts.byweekday) || isPresent(opts.byeaster))) {
    switch (opts.freq) {
      case RRule.YEARLY:
        if (!opts.bymonth)
          opts.bymonth = opts.dtstart.getUTCMonth() + 1;
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.MONTHLY:
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.WEEKLY:
        opts.byweekday = [getWeekday(opts.dtstart)];
        break;
    }
  }
  if (isPresent(opts.bymonth) && !isArray(opts.bymonth)) {
    opts.bymonth = [opts.bymonth];
  }
  if (isPresent(opts.byyearday) && !isArray(opts.byyearday) && isNumber(opts.byyearday)) {
    opts.byyearday = [opts.byyearday];
  }
  if (!isPresent(opts.bymonthday)) {
    opts.bymonthday = [];
    opts.bynmonthday = [];
  } else if (isArray(opts.bymonthday)) {
    var bymonthday = [];
    var bynmonthday = [];
    for (var i = 0; i < opts.bymonthday.length; i++) {
      var v = opts.bymonthday[i];
      if (v > 0) {
        bymonthday.push(v);
      } else if (v < 0) {
        bynmonthday.push(v);
      }
    }
    opts.bymonthday = bymonthday;
    opts.bynmonthday = bynmonthday;
  } else if (opts.bymonthday < 0) {
    opts.bynmonthday = [opts.bymonthday];
    opts.bymonthday = [];
  } else {
    opts.bynmonthday = [];
    opts.bymonthday = [opts.bymonthday];
  }
  if (isPresent(opts.byweekno) && !isArray(opts.byweekno)) {
    opts.byweekno = [opts.byweekno];
  }
  if (!isPresent(opts.byweekday)) {
    opts.bynweekday = null;
  } else if (isNumber(opts.byweekday)) {
    opts.byweekday = [opts.byweekday];
    opts.bynweekday = null;
  } else if (isWeekdayStr(opts.byweekday)) {
    opts.byweekday = [Weekday.fromStr(opts.byweekday).weekday];
    opts.bynweekday = null;
  } else if (opts.byweekday instanceof Weekday) {
    if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
      opts.byweekday = [opts.byweekday.weekday];
      opts.bynweekday = null;
    } else {
      opts.bynweekday = [[opts.byweekday.weekday, opts.byweekday.n]];
      opts.byweekday = null;
    }
  } else {
    var byweekday = [];
    var bynweekday = [];
    for (var i = 0; i < opts.byweekday.length; i++) {
      var wday = opts.byweekday[i];
      if (isNumber(wday)) {
        byweekday.push(wday);
        continue;
      } else if (isWeekdayStr(wday)) {
        byweekday.push(Weekday.fromStr(wday).weekday);
        continue;
      }
      if (!wday.n || opts.freq > RRule.MONTHLY) {
        byweekday.push(wday.weekday);
      } else {
        bynweekday.push([wday.weekday, wday.n]);
      }
    }
    opts.byweekday = notEmpty(byweekday) ? byweekday : null;
    opts.bynweekday = notEmpty(bynweekday) ? bynweekday : null;
  }
  if (!isPresent(opts.byhour)) {
    opts.byhour = opts.freq < RRule.HOURLY ? [opts.dtstart.getUTCHours()] : null;
  } else if (isNumber(opts.byhour)) {
    opts.byhour = [opts.byhour];
  }
  if (!isPresent(opts.byminute)) {
    opts.byminute = opts.freq < RRule.MINUTELY ? [opts.dtstart.getUTCMinutes()] : null;
  } else if (isNumber(opts.byminute)) {
    opts.byminute = [opts.byminute];
  }
  if (!isPresent(opts.bysecond)) {
    opts.bysecond = opts.freq < RRule.SECONDLY ? [opts.dtstart.getUTCSeconds()] : null;
  } else if (isNumber(opts.bysecond)) {
    opts.bysecond = [opts.bysecond];
  }
  return { parsedOptions: opts };
}
function buildTimeset(opts) {
  var millisecondModulo = opts.dtstart.getTime() % 1e3;
  if (!freqIsDailyOrGreater(opts.freq)) {
    return [];
  }
  var timeset = [];
  opts.byhour.forEach(function(hour) {
    opts.byminute.forEach(function(minute) {
      opts.bysecond.forEach(function(second) {
        timeset.push(new Time(hour, minute, second, millisecondModulo));
      });
    });
  });
  return timeset;
}

// node_modules/rrule/dist/esm/parsestring.js
function parseString(rfcString) {
  var options = rfcString.split("\n").map(parseLine).filter(function(x) {
    return x !== null;
  });
  return __assign(__assign({}, options[0]), options[1]);
}
function parseDtstart(line) {
  var options = {};
  var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(line);
  if (!dtstartWithZone) {
    return options;
  }
  var tzid = dtstartWithZone[1], dtstart = dtstartWithZone[2];
  if (tzid) {
    options.tzid = tzid;
  }
  options.dtstart = untilStringToDate(dtstart);
  return options;
}
function parseLine(rfcString) {
  rfcString = rfcString.replace(/^\s+|\s+$/, "");
  if (!rfcString.length)
    return null;
  var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());
  if (!header) {
    return parseRrule(rfcString);
  }
  var key = header[1];
  switch (key.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return parseRrule(rfcString);
    case "DTSTART":
      return parseDtstart(rfcString);
    default:
      throw new Error("Unsupported RFC prop ".concat(key, " in ").concat(rfcString));
  }
}
function parseRrule(line) {
  var strippedLine = line.replace(/^RRULE:/i, "");
  var options = parseDtstart(strippedLine);
  var attrs = line.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  attrs.forEach(function(attr) {
    var _a = attr.split("="), key = _a[0], value = _a[1];
    switch (key.toUpperCase()) {
      case "FREQ":
        options.freq = Frequency[value.toUpperCase()];
        break;
      case "WKST":
        options.wkst = Days[value.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var num = parseNumber(value);
        var optionKey = key.toLowerCase();
        options[optionKey] = num;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        options.byweekday = parseWeekday(value);
        break;
      case "DTSTART":
      case "TZID":
        var dtstart = parseDtstart(line);
        options.tzid = dtstart.tzid;
        options.dtstart = dtstart.dtstart;
        break;
      case "UNTIL":
        options.until = untilStringToDate(value);
        break;
      case "BYEASTER":
        options.byeaster = Number(value);
        break;
      default:
        throw new Error("Unknown RRULE property '" + key + "'");
    }
  });
  return options;
}
function parseNumber(value) {
  if (value.indexOf(",") !== -1) {
    var values = value.split(",");
    return values.map(parseIndividualNumber);
  }
  return parseIndividualNumber(value);
}
function parseIndividualNumber(value) {
  if (/^[+-]?\d+$/.test(value)) {
    return Number(value);
  }
  return value;
}
function parseWeekday(value) {
  var days = value.split(",");
  return days.map(function(day) {
    if (day.length === 2) {
      return Days[day];
    }
    var parts = day.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!parts || parts.length < 3) {
      throw new SyntaxError("Invalid weekday string: ".concat(day));
    }
    var n = Number(parts[1]);
    var wdaypart = parts[2];
    var wday = Days[wdaypart].weekday;
    return new Weekday(wday, n);
  });
}

// node_modules/rrule/dist/esm/datewithzone.js
var DateWithZone = (
  /** @class */
  function() {
    function DateWithZone2(date, tzid) {
      if (isNaN(date.getTime())) {
        throw new RangeError("Invalid date passed to DateWithZone");
      }
      this.date = date;
      this.tzid = tzid;
    }
    Object.defineProperty(DateWithZone2.prototype, "isUTC", {
      get: function() {
        return !this.tzid || this.tzid.toUpperCase() === "UTC";
      },
      enumerable: false,
      configurable: true
    });
    DateWithZone2.prototype.toString = function() {
      var datestr = timeToUntilString(this.date.getTime(), this.isUTC);
      if (!this.isUTC) {
        return ";TZID=".concat(this.tzid, ":").concat(datestr);
      }
      return ":".concat(datestr);
    };
    DateWithZone2.prototype.getTime = function() {
      return this.date.getTime();
    };
    DateWithZone2.prototype.rezonedDate = function() {
      if (this.isUTC) {
        return this.date;
      }
      return dateInTimeZone(this.date, this.tzid);
    };
    return DateWithZone2;
  }()
);

// node_modules/rrule/dist/esm/optionstostring.js
function optionsToString(options) {
  var rrule = [];
  var dtstart = "";
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS2);
  for (var i = 0; i < keys.length; i++) {
    if (keys[i] === "tzid")
      continue;
    if (!includes(defaultKeys2, keys[i]))
      continue;
    var key = keys[i].toUpperCase();
    var value = options[keys[i]];
    var outValue = "";
    if (!isPresent(value) || isArray(value) && !value.length)
      continue;
    switch (key) {
      case "FREQ":
        outValue = RRule.FREQUENCIES[options.freq];
        break;
      case "WKST":
        if (isNumber(value)) {
          outValue = new Weekday(value).toString();
        } else {
          outValue = value.toString();
        }
        break;
      case "BYWEEKDAY":
        key = "BYDAY";
        outValue = toArray(value).map(function(wday) {
          if (wday instanceof Weekday) {
            return wday;
          }
          if (isArray(wday)) {
            return new Weekday(wday[0], wday[1]);
          }
          return new Weekday(wday);
        }).toString();
        break;
      case "DTSTART":
        dtstart = buildDtstart(value, options.tzid);
        break;
      case "UNTIL":
        outValue = timeToUntilString(value, !options.tzid);
        break;
      default:
        if (isArray(value)) {
          var strValues = [];
          for (var j = 0; j < value.length; j++) {
            strValues[j] = String(value[j]);
          }
          outValue = strValues.toString();
        } else {
          outValue = String(value);
        }
    }
    if (outValue) {
      rrule.push([key, outValue]);
    }
  }
  var rules = rrule.map(function(_a) {
    var key2 = _a[0], value2 = _a[1];
    return "".concat(key2, "=").concat(value2.toString());
  }).join(";");
  var ruleString = "";
  if (rules !== "") {
    ruleString = "RRULE:".concat(rules);
  }
  return [dtstart, ruleString].filter(function(x) {
    return !!x;
  }).join("\n");
}
function buildDtstart(dtstart, tzid) {
  if (!dtstart) {
    return "";
  }
  return "DTSTART" + new DateWithZone(new Date(dtstart), tzid).toString();
}

// node_modules/rrule/dist/esm/cache.js
function argsMatch(left2, right2) {
  if (Array.isArray(left2)) {
    if (!Array.isArray(right2))
      return false;
    if (left2.length !== right2.length)
      return false;
    return left2.every(function(date, i) {
      return date.getTime() === right2[i].getTime();
    });
  }
  if (left2 instanceof Date) {
    return right2 instanceof Date && left2.getTime() === right2.getTime();
  }
  return left2 === right2;
}
var Cache = (
  /** @class */
  function() {
    function Cache2() {
      this.all = false;
      this.before = [];
      this.after = [];
      this.between = [];
    }
    Cache2.prototype._cacheAdd = function(what, value, args) {
      if (value) {
        value = value instanceof Date ? clone(value) : cloneDates(value);
      }
      if (what === "all") {
        this.all = value;
      } else {
        args._value = value;
        this[what].push(args);
      }
    };
    Cache2.prototype._cacheGet = function(what, args) {
      var cached = false;
      var argsKeys = args ? Object.keys(args) : [];
      var findCacheDiff = function(item2) {
        for (var i2 = 0; i2 < argsKeys.length; i2++) {
          var key = argsKeys[i2];
          if (!argsMatch(args[key], item2[key])) {
            return true;
          }
        }
        return false;
      };
      var cachedObject = this[what];
      if (what === "all") {
        cached = this.all;
      } else if (isArray(cachedObject)) {
        for (var i = 0; i < cachedObject.length; i++) {
          var item = cachedObject[i];
          if (argsKeys.length && findCacheDiff(item))
            continue;
          cached = item._value;
          break;
        }
      }
      if (!cached && this.all) {
        var iterResult = new iterresult_default(what, args);
        for (var i = 0; i < this.all.length; i++) {
          if (!iterResult.accept(this.all[i]))
            break;
        }
        cached = iterResult.getValue();
        this._cacheAdd(what, cached, args);
      }
      return isArray(cached) ? cloneDates(cached) : cached instanceof Date ? clone(cached) : cached;
    };
    return Cache2;
  }()
);

// node_modules/rrule/dist/esm/masks.js
var M365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 28), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 29), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M28 = range(1, 29);
var M29 = range(1, 30);
var M30 = range(1, 31);
var M31 = range(1, 32);
var MDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M29, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var MDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M28, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var NM28 = range(-28, 0);
var NM29 = range(-29, 0);
var NM30 = range(-30, 0);
var NM31 = range(-31, 0);
var NMDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM29, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var NMDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM28, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
var WDAYMASK = function() {
  var wdaymask = [];
  for (var i = 0; i < 55; i++)
    wdaymask = wdaymask.concat(range(7));
  return wdaymask;
}();

// node_modules/rrule/dist/esm/iterinfo/yearinfo.js
function rebuildYear(year, options) {
  var firstyday = datetime(year, 1, 1);
  var yearlen = isLeapYear(year) ? 366 : 365;
  var nextyearlen = isLeapYear(year + 1) ? 366 : 365;
  var yearordinal = toOrdinal(firstyday);
  var yearweekday = getWeekday(firstyday);
  var result = __assign(__assign({ yearlen, nextyearlen, yearordinal, yearweekday }, baseYearMasks(year)), { wnomask: null });
  if (empty(options.byweekno)) {
    return result;
  }
  result.wnomask = repeat(0, yearlen + 7);
  var firstwkst;
  var wyearlen;
  var no1wkst = firstwkst = pymod(7 - yearweekday + options.wkst, 7);
  if (no1wkst >= 4) {
    no1wkst = 0;
    wyearlen = result.yearlen + pymod(yearweekday - options.wkst, 7);
  } else {
    wyearlen = yearlen - no1wkst;
  }
  var div = Math.floor(wyearlen / 7);
  var mod = pymod(wyearlen, 7);
  var numweeks = Math.floor(div + mod / 4);
  for (var j = 0; j < options.byweekno.length; j++) {
    var n = options.byweekno[j];
    if (n < 0) {
      n += numweeks + 1;
    }
    if (!(n > 0 && n <= numweeks)) {
      continue;
    }
    var i = void 0;
    if (n > 1) {
      i = no1wkst + (n - 1) * 7;
      if (no1wkst !== firstwkst) {
        i -= 7 - firstwkst;
      }
    } else {
      i = no1wkst;
    }
    for (var k = 0; k < 7; k++) {
      result.wnomask[i] = 1;
      i++;
      if (result.wdaymask[i] === options.wkst)
        break;
    }
  }
  if (includes(options.byweekno, 1)) {
    var i = no1wkst + numweeks * 7;
    if (no1wkst !== firstwkst)
      i -= 7 - firstwkst;
    if (i < yearlen) {
      for (var j = 0; j < 7; j++) {
        result.wnomask[i] = 1;
        i += 1;
        if (result.wdaymask[i] === options.wkst)
          break;
      }
    }
  }
  if (no1wkst) {
    var lnumweeks = void 0;
    if (!includes(options.byweekno, -1)) {
      var lyearweekday = getWeekday(datetime(year - 1, 1, 1));
      var lno1wkst = pymod(7 - lyearweekday.valueOf() + options.wkst, 7);
      var lyearlen = isLeapYear(year - 1) ? 366 : 365;
      var weekst = void 0;
      if (lno1wkst >= 4) {
        lno1wkst = 0;
        weekst = lyearlen + pymod(lyearweekday - options.wkst, 7);
      } else {
        weekst = yearlen - no1wkst;
      }
      lnumweeks = Math.floor(52 + pymod(weekst, 7) / 4);
    } else {
      lnumweeks = -1;
    }
    if (includes(options.byweekno, lnumweeks)) {
      for (var i = 0; i < no1wkst; i++)
        result.wnomask[i] = 1;
    }
  }
  return result;
}
function baseYearMasks(year) {
  var yearlen = isLeapYear(year) ? 366 : 365;
  var firstyday = datetime(year, 1, 1);
  var wday = getWeekday(firstyday);
  if (yearlen === 365) {
    return {
      mmask: M365MASK,
      mdaymask: MDAY365MASK,
      nmdaymask: NMDAY365MASK,
      wdaymask: WDAYMASK.slice(wday),
      mrange: M365RANGE
    };
  }
  return {
    mmask: M366MASK,
    mdaymask: MDAY366MASK,
    nmdaymask: NMDAY366MASK,
    wdaymask: WDAYMASK.slice(wday),
    mrange: M366RANGE
  };
}

// node_modules/rrule/dist/esm/iterinfo/monthinfo.js
function rebuildMonth(year, month, yearlen, mrange, wdaymask, options) {
  var result = {
    lastyear: year,
    lastmonth: month,
    nwdaymask: []
  };
  var ranges = [];
  if (options.freq === RRule.YEARLY) {
    if (empty(options.bymonth)) {
      ranges = [[0, yearlen]];
    } else {
      for (var j = 0; j < options.bymonth.length; j++) {
        month = options.bymonth[j];
        ranges.push(mrange.slice(month - 1, month + 1));
      }
    }
  } else if (options.freq === RRule.MONTHLY) {
    ranges = [mrange.slice(month - 1, month + 1)];
  }
  if (empty(ranges)) {
    return result;
  }
  result.nwdaymask = repeat(0, yearlen);
  for (var j = 0; j < ranges.length; j++) {
    var rang = ranges[j];
    var first = rang[0];
    var last = rang[1] - 1;
    for (var k = 0; k < options.bynweekday.length; k++) {
      var i = void 0;
      var _a = options.bynweekday[k], wday = _a[0], n = _a[1];
      if (n < 0) {
        i = last + (n + 1) * 7;
        i -= pymod(wdaymask[i] - wday, 7);
      } else {
        i = first + (n - 1) * 7;
        i += pymod(7 - wdaymask[i] + wday, 7);
      }
      if (first <= i && i <= last)
        result.nwdaymask[i] = 1;
    }
  }
  return result;
}

// node_modules/rrule/dist/esm/iterinfo/easter.js
function easter(y, offset2) {
  if (offset2 === void 0) {
    offset2 = 0;
  }
  var a = y % 19;
  var b = Math.floor(y / 100);
  var c = y % 100;
  var d = Math.floor(b / 4);
  var e = b % 4;
  var f = Math.floor((b + 8) / 25);
  var g = Math.floor((b - f + 1) / 3);
  var h = Math.floor(19 * a + b - d - g + 15) % 30;
  var i = Math.floor(c / 4);
  var k = c % 4;
  var l = Math.floor(32 + 2 * e + 2 * i - h - k) % 7;
  var m = Math.floor((a + 11 * h + 22 * l) / 451);
  var month = Math.floor((h + l - 7 * m + 114) / 31);
  var day = (h + l - 7 * m + 114) % 31 + 1;
  var date = Date.UTC(y, month - 1, day + offset2);
  var yearStart = Date.UTC(y, 0, 1);
  return [Math.ceil((date - yearStart) / (1e3 * 60 * 60 * 24))];
}

// node_modules/rrule/dist/esm/iterinfo/index.js
var Iterinfo = (
  /** @class */
  function() {
    function Iterinfo2(options) {
      this.options = options;
    }
    Iterinfo2.prototype.rebuild = function(year, month) {
      var options = this.options;
      if (year !== this.lastyear) {
        this.yearinfo = rebuildYear(year, options);
      }
      if (notEmpty(options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
        var _a = this.yearinfo, yearlen = _a.yearlen, mrange = _a.mrange, wdaymask = _a.wdaymask;
        this.monthinfo = rebuildMonth(year, month, yearlen, mrange, wdaymask, options);
      }
      if (isPresent(options.byeaster)) {
        this.eastermask = easter(year, options.byeaster);
      }
    };
    Object.defineProperty(Iterinfo2.prototype, "lastyear", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastyear : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "lastmonth", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastmonth : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearlen", {
      get: function() {
        return this.yearinfo.yearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearordinal", {
      get: function() {
        return this.yearinfo.yearordinal;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mrange", {
      get: function() {
        return this.yearinfo.mrange;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wdaymask", {
      get: function() {
        return this.yearinfo.wdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mmask", {
      get: function() {
        return this.yearinfo.mmask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wnomask", {
      get: function() {
        return this.yearinfo.wnomask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nwdaymask", {
      get: function() {
        return this.monthinfo ? this.monthinfo.nwdaymask : [];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nextyearlen", {
      get: function() {
        return this.yearinfo.nextyearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mdaymask", {
      get: function() {
        return this.yearinfo.mdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nmdaymask", {
      get: function() {
        return this.yearinfo.nmdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Iterinfo2.prototype.ydayset = function() {
      return [range(this.yearlen), 0, this.yearlen];
    };
    Iterinfo2.prototype.mdayset = function(_, month) {
      var start2 = this.mrange[month - 1];
      var end2 = this.mrange[month];
      var set = repeat(null, this.yearlen);
      for (var i = start2; i < end2; i++)
        set[i] = i;
      return [set, start2, end2];
    };
    Iterinfo2.prototype.wdayset = function(year, month, day) {
      var set = repeat(null, this.yearlen + 7);
      var i = toOrdinal(datetime(year, month, day)) - this.yearordinal;
      var start2 = i;
      for (var j = 0; j < 7; j++) {
        set[i] = i;
        ++i;
        if (this.wdaymask[i] === this.options.wkst)
          break;
      }
      return [set, start2, i];
    };
    Iterinfo2.prototype.ddayset = function(year, month, day) {
      var set = repeat(null, this.yearlen);
      var i = toOrdinal(datetime(year, month, day)) - this.yearordinal;
      set[i] = i;
      return [set, i, i + 1];
    };
    Iterinfo2.prototype.htimeset = function(hour, _, second, millisecond) {
      var _this = this;
      var set = [];
      this.options.byminute.forEach(function(minute) {
        set = set.concat(_this.mtimeset(hour, minute, second, millisecond));
      });
      sort(set);
      return set;
    };
    Iterinfo2.prototype.mtimeset = function(hour, minute, _, millisecond) {
      var set = this.options.bysecond.map(function(second) {
        return new Time(hour, minute, second, millisecond);
      });
      sort(set);
      return set;
    };
    Iterinfo2.prototype.stimeset = function(hour, minute, second, millisecond) {
      return [new Time(hour, minute, second, millisecond)];
    };
    Iterinfo2.prototype.getdayset = function(freq) {
      switch (freq) {
        case Frequency.YEARLY:
          return this.ydayset.bind(this);
        case Frequency.MONTHLY:
          return this.mdayset.bind(this);
        case Frequency.WEEKLY:
          return this.wdayset.bind(this);
        case Frequency.DAILY:
          return this.ddayset.bind(this);
        default:
          return this.ddayset.bind(this);
      }
    };
    Iterinfo2.prototype.gettimeset = function(freq) {
      switch (freq) {
        case Frequency.HOURLY:
          return this.htimeset.bind(this);
        case Frequency.MINUTELY:
          return this.mtimeset.bind(this);
        case Frequency.SECONDLY:
          return this.stimeset.bind(this);
      }
    };
    return Iterinfo2;
  }()
);
var iterinfo_default = Iterinfo;

// node_modules/rrule/dist/esm/iter/poslist.js
function buildPoslist(bysetpos, timeset, start2, end2, ii, dayset) {
  var poslist = [];
  for (var j = 0; j < bysetpos.length; j++) {
    var daypos = void 0;
    var timepos = void 0;
    var pos = bysetpos[j];
    if (pos < 0) {
      daypos = Math.floor(pos / timeset.length);
      timepos = pymod(pos, timeset.length);
    } else {
      daypos = Math.floor((pos - 1) / timeset.length);
      timepos = pymod(pos - 1, timeset.length);
    }
    var tmp = [];
    for (var k = start2; k < end2; k++) {
      var val = dayset[k];
      if (!isPresent(val))
        continue;
      tmp.push(val);
    }
    var i = void 0;
    if (daypos < 0) {
      i = tmp.slice(daypos)[0];
    } else {
      i = tmp[daypos];
    }
    var time = timeset[timepos];
    var date = fromOrdinal(ii.yearordinal + i);
    var res = combine(date, time);
    if (!includes(poslist, res))
      poslist.push(res);
  }
  sort(poslist);
  return poslist;
}

// node_modules/rrule/dist/esm/iter/index.js
function iter(iterResult, options) {
  var dtstart = options.dtstart, freq = options.freq, interval = options.interval, until = options.until, bysetpos = options.bysetpos;
  var count = options.count;
  if (count === 0 || interval === 0) {
    return emitResult(iterResult);
  }
  var counterDate = DateTime.fromDate(dtstart);
  var ii = new iterinfo_default(options);
  ii.rebuild(counterDate.year, counterDate.month);
  var timeset = makeTimeset(ii, counterDate, options);
  for (; ; ) {
    var _a = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day), dayset = _a[0], start2 = _a[1], end2 = _a[2];
    var filtered = removeFilteredDays(dayset, start2, end2, ii, options);
    if (notEmpty(bysetpos)) {
      var poslist = buildPoslist(bysetpos, timeset, start2, end2, ii, dayset);
      for (var j = 0; j < poslist.length; j++) {
        var res = poslist[j];
        if (until && res > until) {
          return emitResult(iterResult);
        }
        if (res >= dtstart) {
          var rezonedDate = rezoneIfNeeded(res, options);
          if (!iterResult.accept(rezonedDate)) {
            return emitResult(iterResult);
          }
          if (count) {
            --count;
            if (!count) {
              return emitResult(iterResult);
            }
          }
        }
      }
    } else {
      for (var j = start2; j < end2; j++) {
        var currentDay = dayset[j];
        if (!isPresent(currentDay)) {
          continue;
        }
        var date = fromOrdinal(ii.yearordinal + currentDay);
        for (var k = 0; k < timeset.length; k++) {
          var time = timeset[k];
          var res = combine(date, time);
          if (until && res > until) {
            return emitResult(iterResult);
          }
          if (res >= dtstart) {
            var rezonedDate = rezoneIfNeeded(res, options);
            if (!iterResult.accept(rezonedDate)) {
              return emitResult(iterResult);
            }
            if (count) {
              --count;
              if (!count) {
                return emitResult(iterResult);
              }
            }
          }
        }
      }
    }
    if (options.interval === 0) {
      return emitResult(iterResult);
    }
    counterDate.add(options, filtered);
    if (counterDate.year > MAXYEAR) {
      return emitResult(iterResult);
    }
    if (!freqIsDailyOrGreater(freq)) {
      timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);
    }
    ii.rebuild(counterDate.year, counterDate.month);
  }
}
function isFiltered(ii, currentDay, options) {
  var bymonth = options.bymonth, byweekno = options.byweekno, byweekday = options.byweekday, byeaster = options.byeaster, bymonthday = options.bymonthday, bynmonthday = options.bynmonthday, byyearday = options.byyearday;
  return notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay]) || notEmpty(byweekno) && !ii.wnomask[currentDay] || notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay]) || notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !includes(ii.eastermask, currentDay) || (notEmpty(bymonthday) || notEmpty(bynmonthday)) && !includes(bymonthday, ii.mdaymask[currentDay]) && !includes(bynmonthday, ii.nmdaymask[currentDay]) || notEmpty(byyearday) && (currentDay < ii.yearlen && !includes(byyearday, currentDay + 1) && !includes(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !includes(byyearday, currentDay + 1 - ii.yearlen) && !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));
}
function rezoneIfNeeded(date, options) {
  return new DateWithZone(date, options.tzid).rezonedDate();
}
function emitResult(iterResult) {
  return iterResult.getValue();
}
function removeFilteredDays(dayset, start2, end2, ii, options) {
  var filtered = false;
  for (var dayCounter = start2; dayCounter < end2; dayCounter++) {
    var currentDay = dayset[dayCounter];
    filtered = isFiltered(ii, currentDay, options);
    if (filtered)
      dayset[currentDay] = null;
  }
  return filtered;
}
function makeTimeset(ii, counterDate, options) {
  var freq = options.freq, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
  if (freqIsDailyOrGreater(freq)) {
    return buildTimeset(options);
  }
  if (freq >= RRule.HOURLY && notEmpty(byhour) && !includes(byhour, counterDate.hour) || freq >= RRule.MINUTELY && notEmpty(byminute) && !includes(byminute, counterDate.minute) || freq >= RRule.SECONDLY && notEmpty(bysecond) && !includes(bysecond, counterDate.second)) {
    return [];
  }
  return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);
}

// node_modules/rrule/dist/esm/rrule.js
var Days = {
  MO: new Weekday(0),
  TU: new Weekday(1),
  WE: new Weekday(2),
  TH: new Weekday(3),
  FR: new Weekday(4),
  SA: new Weekday(5),
  SU: new Weekday(6)
};
var DEFAULT_OPTIONS2 = {
  freq: Frequency.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: Days.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
};
var defaultKeys = Object.keys(DEFAULT_OPTIONS2);
var RRule = (
  /** @class */
  function() {
    function RRule2(options, noCache) {
      if (options === void 0) {
        options = {};
      }
      if (noCache === void 0) {
        noCache = false;
      }
      this._cache = noCache ? null : new Cache();
      this.origOptions = initializeOptions(options);
      var parsedOptions = parseOptions(options).parsedOptions;
      this.options = parsedOptions;
    }
    RRule2.parseText = function(text, language) {
      return parseText(text, language);
    };
    RRule2.fromText = function(text, language) {
      return fromText(text, language);
    };
    RRule2.fromString = function(str) {
      return new RRule2(RRule2.parseString(str) || void 0);
    };
    RRule2.prototype._iter = function(iterResult) {
      return iter(iterResult, this.options);
    };
    RRule2.prototype._cacheGet = function(what, args) {
      if (!this._cache)
        return false;
      return this._cache._cacheGet(what, args);
    };
    RRule2.prototype._cacheAdd = function(what, value, args) {
      if (!this._cache)
        return;
      return this._cache._cacheAdd(what, value, args);
    };
    RRule2.prototype.all = function(iterator) {
      if (iterator) {
        return this._iter(new callbackiterresult_default("all", {}, iterator));
      }
      var result = this._cacheGet("all");
      if (result === false) {
        result = this._iter(new iterresult_default("all", {}));
        this._cacheAdd("all", result);
      }
      return result;
    };
    RRule2.prototype.between = function(after, before, inc, iterator) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate(after) || !isValidDate(before)) {
        throw new Error("Invalid date passed in to RRule.between");
      }
      var args = {
        before,
        after,
        inc
      };
      if (iterator) {
        return this._iter(new callbackiterresult_default("between", args, iterator));
      }
      var result = this._cacheGet("between", args);
      if (result === false) {
        result = this._iter(new iterresult_default("between", args));
        this._cacheAdd("between", result, args);
      }
      return result;
    };
    RRule2.prototype.before = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate(dt)) {
        throw new Error("Invalid date passed in to RRule.before");
      }
      var args = { dt, inc };
      var result = this._cacheGet("before", args);
      if (result === false) {
        result = this._iter(new iterresult_default("before", args));
        this._cacheAdd("before", result, args);
      }
      return result;
    };
    RRule2.prototype.after = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate(dt)) {
        throw new Error("Invalid date passed in to RRule.after");
      }
      var args = { dt, inc };
      var result = this._cacheGet("after", args);
      if (result === false) {
        result = this._iter(new iterresult_default("after", args));
        this._cacheAdd("after", result, args);
      }
      return result;
    };
    RRule2.prototype.count = function() {
      return this.all().length;
    };
    RRule2.prototype.toString = function() {
      return optionsToString(this.origOptions);
    };
    RRule2.prototype.toText = function(gettext, language, dateFormatter) {
      return toText(this, gettext, language, dateFormatter);
    };
    RRule2.prototype.isFullyConvertibleToText = function() {
      return isFullyConvertible(this);
    };
    RRule2.prototype.clone = function() {
      return new RRule2(this.origOptions);
    };
    RRule2.FREQUENCIES = [
      "YEARLY",
      "MONTHLY",
      "WEEKLY",
      "DAILY",
      "HOURLY",
      "MINUTELY",
      "SECONDLY"
    ];
    RRule2.YEARLY = Frequency.YEARLY;
    RRule2.MONTHLY = Frequency.MONTHLY;
    RRule2.WEEKLY = Frequency.WEEKLY;
    RRule2.DAILY = Frequency.DAILY;
    RRule2.HOURLY = Frequency.HOURLY;
    RRule2.MINUTELY = Frequency.MINUTELY;
    RRule2.SECONDLY = Frequency.SECONDLY;
    RRule2.MO = Days.MO;
    RRule2.TU = Days.TU;
    RRule2.WE = Days.WE;
    RRule2.TH = Days.TH;
    RRule2.FR = Days.FR;
    RRule2.SA = Days.SA;
    RRule2.SU = Days.SU;
    RRule2.parseString = parseString;
    RRule2.optionsToString = optionsToString;
    return RRule2;
  }()
);

// node_modules/rrule/dist/esm/iterset.js
function iterSet(iterResult, _rrule, _exrule, _rdate, _exdate, tzid) {
  var _exdateHash = {};
  var _accept = iterResult.accept;
  function evalExdate(after, before) {
    _exrule.forEach(function(rrule) {
      rrule.between(after, before, true).forEach(function(date) {
        _exdateHash[Number(date)] = true;
      });
    });
  }
  _exdate.forEach(function(date) {
    var zonedDate2 = new DateWithZone(date, tzid).rezonedDate();
    _exdateHash[Number(zonedDate2)] = true;
  });
  iterResult.accept = function(date) {
    var dt = Number(date);
    if (isNaN(dt))
      return _accept.call(this, date);
    if (!_exdateHash[dt]) {
      evalExdate(new Date(dt - 1), new Date(dt + 1));
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
    }
    return true;
  };
  if (iterResult.method === "between") {
    evalExdate(iterResult.args.after, iterResult.args.before);
    iterResult.accept = function(date) {
      var dt = Number(date);
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
      return true;
    };
  }
  for (var i = 0; i < _rdate.length; i++) {
    var zonedDate = new DateWithZone(_rdate[i], tzid).rezonedDate();
    if (!iterResult.accept(new Date(zonedDate.getTime())))
      break;
  }
  _rrule.forEach(function(rrule) {
    iter(iterResult, rrule.options);
  });
  var res = iterResult._result;
  sort(res);
  switch (iterResult.method) {
    case "all":
    case "between":
      return res;
    case "before":
      return res.length && res[res.length - 1] || null;
    case "after":
    default:
      return res.length && res[0] || null;
  }
}

// node_modules/rrule/dist/esm/rrulestr.js
var DEFAULT_OPTIONS3 = {
  dtstart: null,
  cache: false,
  unfold: false,
  forceset: false,
  compatible: false,
  tzid: null
};
function parseInput(s, options) {
  var rrulevals = [];
  var rdatevals = [];
  var exrulevals = [];
  var exdatevals = [];
  var parsedDtstart = parseDtstart(s);
  var dtstart = parsedDtstart.dtstart;
  var tzid = parsedDtstart.tzid;
  var lines = splitIntoLines(s, options.unfold);
  lines.forEach(function(line) {
    var _a;
    if (!line)
      return;
    var _b = breakDownLine(line), name = _b.name, parms = _b.parms, value = _b.value;
    switch (name.toUpperCase()) {
      case "RRULE":
        if (parms.length) {
          throw new Error("unsupported RRULE parm: ".concat(parms.join(",")));
        }
        rrulevals.push(parseString(line));
        break;
      case "RDATE":
        var _c = (_a = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a !== void 0 ? _a : [], rdateTzid = _c[1];
        if (rdateTzid && !tzid) {
          tzid = rdateTzid;
        }
        rdatevals = rdatevals.concat(parseRDate(value, parms));
        break;
      case "EXRULE":
        if (parms.length) {
          throw new Error("unsupported EXRULE parm: ".concat(parms.join(",")));
        }
        exrulevals.push(parseString(value));
        break;
      case "EXDATE":
        exdatevals = exdatevals.concat(parseRDate(value, parms));
        break;
      case "DTSTART":
        break;
      default:
        throw new Error("unsupported property: " + name);
    }
  });
  return {
    dtstart,
    tzid,
    rrulevals,
    rdatevals,
    exrulevals,
    exdatevals
  };
}
function buildRule(s, options) {
  var _a = parseInput(s, options), rrulevals = _a.rrulevals, rdatevals = _a.rdatevals, exrulevals = _a.exrulevals, exdatevals = _a.exdatevals, dtstart = _a.dtstart, tzid = _a.tzid;
  var noCache = options.cache === false;
  if (options.compatible) {
    options.forceset = true;
    options.unfold = true;
  }
  if (options.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {
    var rset_1 = new RRuleSet(noCache);
    rset_1.dtstart(dtstart);
    rset_1.tzid(tzid || void 0);
    rrulevals.forEach(function(val2) {
      rset_1.rrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    rdatevals.forEach(function(date) {
      rset_1.rdate(date);
    });
    exrulevals.forEach(function(val2) {
      rset_1.exrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    exdatevals.forEach(function(date) {
      rset_1.exdate(date);
    });
    if (options.compatible && options.dtstart)
      rset_1.rdate(dtstart);
    return rset_1;
  }
  var val = rrulevals[0] || {};
  return new RRule(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);
}
function rrulestr(s, options) {
  if (options === void 0) {
    options = {};
  }
  return buildRule(s, initializeOptions2(options));
}
function groomRruleOptions(val, dtstart, tzid) {
  return __assign(__assign({}, val), { dtstart, tzid });
}
function initializeOptions2(options) {
  var invalid = [];
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS3);
  keys.forEach(function(key) {
    if (!includes(defaultKeys2, key))
      invalid.push(key);
  });
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign(__assign({}, DEFAULT_OPTIONS3), options);
}
function extractName(line) {
  if (line.indexOf(":") === -1) {
    return {
      name: "RRULE",
      value: line
    };
  }
  var _a = split(line, ":", 1), name = _a[0], value = _a[1];
  return {
    name,
    value
  };
}
function breakDownLine(line) {
  var _a = extractName(line), name = _a.name, value = _a.value;
  var parms = name.split(";");
  if (!parms)
    throw new Error("empty property name");
  return {
    name: parms[0].toUpperCase(),
    parms: parms.slice(1),
    value
  };
}
function splitIntoLines(s, unfold) {
  if (unfold === void 0) {
    unfold = false;
  }
  s = s && s.trim();
  if (!s)
    throw new Error("Invalid empty string");
  if (!unfold) {
    return s.split(/\s/);
  }
  var lines = s.split("\n");
  var i = 0;
  while (i < lines.length) {
    var line = lines[i] = lines[i].replace(/\s+$/g, "");
    if (!line) {
      lines.splice(i, 1);
    } else if (i > 0 && line[0] === " ") {
      lines[i - 1] += line.slice(1);
      lines.splice(i, 1);
    } else {
      i += 1;
    }
  }
  return lines;
}
function validateDateParm(parms) {
  parms.forEach(function(parm) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {
      throw new Error("unsupported RDATE/EXDATE parm: " + parm);
    }
  });
}
function parseRDate(rdateval, parms) {
  validateDateParm(parms);
  return rdateval.split(",").map(function(datestr) {
    return untilStringToDate(datestr);
  });
}

// node_modules/rrule/dist/esm/rruleset.js
function createGetterSetter(fieldName) {
  var _this = this;
  return function(field) {
    if (field !== void 0) {
      _this["_".concat(fieldName)] = field;
    }
    if (_this["_".concat(fieldName)] !== void 0) {
      return _this["_".concat(fieldName)];
    }
    for (var i = 0; i < _this._rrule.length; i++) {
      var field_1 = _this._rrule[i].origOptions[fieldName];
      if (field_1) {
        return field_1;
      }
    }
  };
}
var RRuleSet = (
  /** @class */
  function(_super) {
    __extends(RRuleSet2, _super);
    function RRuleSet2(noCache) {
      if (noCache === void 0) {
        noCache = false;
      }
      var _this = _super.call(this, {}, noCache) || this;
      _this.dtstart = createGetterSetter.apply(_this, ["dtstart"]);
      _this.tzid = createGetterSetter.apply(_this, ["tzid"]);
      _this._rrule = [];
      _this._rdate = [];
      _this._exrule = [];
      _this._exdate = [];
      return _this;
    }
    RRuleSet2.prototype._iter = function(iterResult) {
      return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
    };
    RRuleSet2.prototype.rrule = function(rrule) {
      _addRule(rrule, this._rrule);
    };
    RRuleSet2.prototype.exrule = function(rrule) {
      _addRule(rrule, this._exrule);
    };
    RRuleSet2.prototype.rdate = function(date) {
      _addDate(date, this._rdate);
    };
    RRuleSet2.prototype.exdate = function(date) {
      _addDate(date, this._exdate);
    };
    RRuleSet2.prototype.rrules = function() {
      return this._rrule.map(function(e) {
        return rrulestr(e.toString());
      });
    };
    RRuleSet2.prototype.exrules = function() {
      return this._exrule.map(function(e) {
        return rrulestr(e.toString());
      });
    };
    RRuleSet2.prototype.rdates = function() {
      return this._rdate.map(function(e) {
        return new Date(e.getTime());
      });
    };
    RRuleSet2.prototype.exdates = function() {
      return this._exdate.map(function(e) {
        return new Date(e.getTime());
      });
    };
    RRuleSet2.prototype.valueOf = function() {
      var result = [];
      if (!this._rrule.length && this._dtstart) {
        result = result.concat(optionsToString({ dtstart: this._dtstart }));
      }
      this._rrule.forEach(function(rrule) {
        result = result.concat(rrule.toString().split("\n"));
      });
      this._exrule.forEach(function(exrule) {
        result = result.concat(exrule.toString().split("\n").map(function(line) {
          return line.replace(/^RRULE:/, "EXRULE:");
        }).filter(function(line) {
          return !/^DTSTART/.test(line);
        }));
      });
      if (this._rdate.length) {
        result.push(rdatesToString("RDATE", this._rdate, this.tzid()));
      }
      if (this._exdate.length) {
        result.push(rdatesToString("EXDATE", this._exdate, this.tzid()));
      }
      return result;
    };
    RRuleSet2.prototype.toString = function() {
      return this.valueOf().join("\n");
    };
    RRuleSet2.prototype.clone = function() {
      var rrs = new RRuleSet2(!!this._cache);
      this._rrule.forEach(function(rule) {
        return rrs.rrule(rule.clone());
      });
      this._exrule.forEach(function(rule) {
        return rrs.exrule(rule.clone());
      });
      this._rdate.forEach(function(date) {
        return rrs.rdate(new Date(date.getTime()));
      });
      this._exdate.forEach(function(date) {
        return rrs.exdate(new Date(date.getTime()));
      });
      return rrs;
    };
    return RRuleSet2;
  }(RRule)
);
function _addRule(rrule, collection) {
  if (!(rrule instanceof RRule)) {
    throw new TypeError(String(rrule) + " is not RRule instance");
  }
  if (!includes(collection.map(String), String(rrule))) {
    collection.push(rrule);
  }
}
function _addDate(date, collection) {
  if (!(date instanceof Date)) {
    throw new TypeError(String(date) + " is not Date instance");
  }
  if (!includes(collection.map(Number), Number(date))) {
    collection.push(date);
    sort(collection);
  }
}
function rdatesToString(param, rdates, tzid) {
  var isUTC = !tzid || tzid.toUpperCase() === "UTC";
  var header = isUTC ? "".concat(param, ":") : "".concat(param, ";TZID=").concat(tzid, ":");
  var dateString = rdates.map(function(rdate) {
    return timeToUntilString(rdate.valueOf(), isUTC);
  }).join(",");
  return "".concat(header).concat(dateString);
}

// node_modules/obsidian-task/src/lib/DateTools.ts
function compareByDate(a, b) {
  if (a !== null && b === null) {
    return -1;
  }
  if (a === null && b !== null) {
    return 1;
  }
  if (!(a !== null && b !== null)) {
    return 0;
  }
  if (a.isValid() && !b.isValid()) {
    return 1;
  } else if (!a.isValid() && b.isValid()) {
    return -1;
  }
  if (a.isAfter(b)) {
    return 1;
  } else if (a.isBefore(b)) {
    return -1;
  } else {
    return 0;
  }
}

// node_modules/obsidian-task/src/Task/Recurrence.ts
var Recurrence = class {
  rrule;
  baseOnToday;
  startDate;
  scheduledDate;
  dueDate;
  /**
   * The reference date is used to calculate future occurrences.
   *
   * Future occurrences will recur based on the reference date.
   * The reference date is the due date, if it is given.
   * Otherwise the scheduled date, if it is given. And so on.
   *
   * Recurrence of all dates will be kept relative to the reference date.
   * For example: if the due date and the start date are given, the due date
   * is the reference date. Future occurrences will have a start date with the
   * same relative distance to the due date as the original task. For example
   * "starts one week before it is due".
   */
  referenceDate;
  constructor({
    rrule,
    baseOnToday,
    referenceDate,
    startDate,
    scheduledDate,
    dueDate
  }) {
    this.rrule = rrule;
    this.baseOnToday = baseOnToday;
    this.referenceDate = referenceDate;
    this.startDate = startDate;
    this.scheduledDate = scheduledDate;
    this.dueDate = dueDate;
  }
  static fromText({
    recurrenceRuleText,
    startDate,
    scheduledDate,
    dueDate
  }) {
    try {
      const match = recurrenceRuleText.match(/^([a-zA-Z0-9, !]+?)( when done)?$/i);
      if (match == null) {
        return null;
      }
      const isolatedRuleText = match[1].trim();
      const baseOnToday = match[2] !== void 0;
      const options = RRule.parseText(isolatedRuleText);
      if (options !== null) {
        let referenceDate = null;
        if (dueDate) {
          referenceDate = window.moment(dueDate);
        } else if (scheduledDate) {
          referenceDate = window.moment(scheduledDate);
        } else if (startDate) {
          referenceDate = window.moment(startDate);
        }
        if (!baseOnToday && referenceDate !== null) {
          options.dtstart = window.moment(referenceDate).startOf("day").utc(true).toDate();
        } else {
          options.dtstart = window.moment().startOf("day").utc(true).toDate();
        }
        const rrule = new RRule(options);
        return new Recurrence({
          rrule,
          baseOnToday,
          referenceDate,
          startDate,
          scheduledDate,
          dueDate
        });
      }
    } catch (e) {
      if (e instanceof Error) {
        console.log(e.message);
      }
    }
    return null;
  }
  toText() {
    let text = this.rrule.toText();
    if (this.baseOnToday) {
      text += " when done";
    }
    return text;
  }
  /**
   * Returns the dates of the next occurrence or null if there is no next occurrence.
   */
  next() {
    const next = this.nextReferenceDate();
    if (next !== null) {
      let startDate = null;
      let scheduledDate = null;
      let dueDate = null;
      if (this.referenceDate) {
        if (this.startDate) {
          const originalDifference = window.moment.duration(this.startDate.diff(this.referenceDate));
          startDate = window.moment(next);
          startDate.add(Math.round(originalDifference.asDays()), "days");
        }
        if (this.scheduledDate) {
          const originalDifference = window.moment.duration(this.scheduledDate.diff(this.referenceDate));
          scheduledDate = window.moment(next);
          scheduledDate.add(Math.round(originalDifference.asDays()), "days");
        }
        if (this.dueDate) {
          const originalDifference = window.moment.duration(this.dueDate.diff(this.referenceDate));
          dueDate = window.moment(next);
          dueDate.add(Math.round(originalDifference.asDays()), "days");
        }
      }
      return {
        startDate,
        scheduledDate,
        dueDate
      };
    }
    return null;
  }
  identicalTo(other) {
    if (this.baseOnToday !== other.baseOnToday) {
      return false;
    }
    if (compareByDate(this.startDate, other.startDate) !== 0) {
      return false;
    }
    if (compareByDate(this.scheduledDate, other.scheduledDate) !== 0) {
      return false;
    }
    if (compareByDate(this.dueDate, other.dueDate) !== 0) {
      return false;
    }
    return this.toText() === other.toText();
  }
  nextReferenceDate() {
    if (this.baseOnToday) {
      const today = window.moment();
      return this.nextReferenceDateFromToday(today).toDate();
    } else {
      return this.nextReferenceDateFromOriginalReferenceDate().toDate();
    }
  }
  nextReferenceDateFromToday(today) {
    const ruleBasedOnToday = new RRule({
      ...this.rrule.origOptions,
      dtstart: today.startOf("day").utc(true).toDate()
    });
    return this.nextAfter(today.endOf("day"), ruleBasedOnToday);
  }
  nextReferenceDateFromOriginalReferenceDate() {
    const after = window.moment(this.referenceDate ?? void 0).endOf("day");
    return this.nextAfter(after, this.rrule);
  }
  /**
   * nextAfter returns the next occurrence's date after `after`, based on the given rrule.
   *
   * The common case is that `rrule.after` calculates the next date and it
   * can be used as is.
   *
   * In the special cases of monthly and yearly recurrences, there exists an
   * edge case where an occurrence after the given number of months or years
   * is not possible. For example: A task is due on 2022-01-31 and has a
   * recurrence of `every month`. When marking the task as done, the next
   * occurrence will happen on 2022-03-31. The reason being that February
   * does not have 31 days, yet RRule sets `bymonthday` to `31` for lack of
   * having a better alternative.
   *
   * In order to fix this, `after` will move into the past day by day. Each
   * day, the next occurrence is checked to be after the given number of
   * months or years. By moving `after` into the past day by day, it will
   * eventually calculate the next occurrence based on `2022-01-28`, ending up
   * in February as the user would expect.
   */
  nextAfter(after, rrule) {
    after.utc(true);
    let next = window.moment(rrule.after(after.toDate()));
    const asText = this.toText();
    const monthMatch = asText.match(/every( \d+)? month(s)?(.*)?/);
    if (monthMatch !== null) {
      if (!asText.includes(" on ")) {
        next = Recurrence.nextAfterMonths(after, next, rrule, monthMatch[1]);
      }
    }
    const yearMatch = asText.match(/every( \d+)? year(s)?(.*)?/);
    if (yearMatch !== null) {
      next = Recurrence.nextAfterYears(after, next, rrule, yearMatch[1]);
    }
    return Recurrence.addTimezone(next);
  }
  /**
   * nextAfterMonths calculates the next date after `skippingMonths` months.
   *
   * `skippingMonths` defaults to `1` if undefined.
   */
  static nextAfterMonths(after, next, rrule, skippingMonths) {
    let parsedSkippingMonths = 1;
    if (skippingMonths !== void 0) {
      parsedSkippingMonths = Number.parseInt(skippingMonths.trim(), 10);
    }
    while (Recurrence.isSkippingTooManyMonths(after, next, parsedSkippingMonths)) {
      next = Recurrence.fromOneDayEarlier(after, rrule);
    }
    return next;
  }
  /**
   * isSkippingTooManyMonths returns true if `next` is more than `skippingMonths` months after `after`.
   */
  static isSkippingTooManyMonths(after, next, skippingMonths) {
    let diffMonths = next.month() - after.month();
    const diffYears = next.year() - after.year();
    diffMonths += diffYears * 12;
    return diffMonths > skippingMonths;
  }
  /**
   * nextAfterYears calculates the next date after `skippingYears` years.
   *
   * `skippingYears` defaults to `1` if undefined.
   */
  static nextAfterYears(after, next, rrule, skippingYears) {
    let parsedSkippingYears = 1;
    if (skippingYears !== void 0) {
      parsedSkippingYears = Number.parseInt(skippingYears.trim(), 10);
    }
    while (Recurrence.isSkippingTooManyYears(after, next, parsedSkippingYears)) {
      next = Recurrence.fromOneDayEarlier(after, rrule);
    }
    return next;
  }
  /**
   * isSkippingTooManyYears returns true if `next` is more than `skippingYears` years after `after`.
   */
  static isSkippingTooManyYears(after, next, skippingYears) {
    const diff = next.year() - after.year();
    return diff > skippingYears;
  }
  /**
   * fromOneDayEarlier returns the next occurrence after moving `after` one day into the past.
   *
   * WARNING: This method manipulates the given instance of `after`.
   */
  static fromOneDayEarlier(after, rrule) {
    after.subtract(1, "days").endOf("day");
    const options = rrule.origOptions;
    options.dtstart = after.startOf("day").toDate();
    rrule = new RRule(options);
    return window.moment(rrule.after(after.toDate()));
  }
  static addTimezone(date) {
    const localTimeZone = window.moment.utc(date).local(true);
    return localTimeZone.startOf("day");
  }
};

// node_modules/obsidian-task/src/lib/RegExpTools.ts
function escapeRegExp(s) {
  return s.replace(/([.*+?^${}()|[\]/\\])/g, "\\$1");
}

// node_modules/obsidian-task/src/Config/GlobalFilter.ts
var _GlobalFilter = class {
  _globalFilter = "";
  _removeGlobalFilter = false;
  /**
   * Provides access to the single global instance of GlobalFilter.
   * This should eventually only be used in the plugin code.
   */
  static getInstance() {
    if (!_GlobalFilter.instance) {
      _GlobalFilter.instance = new _GlobalFilter();
    }
    return _GlobalFilter.instance;
  }
  get() {
    return this._globalFilter;
  }
  set(value) {
    this._globalFilter = value;
  }
  reset() {
    this.set(_GlobalFilter.empty);
  }
  isEmpty() {
    return this.get() === _GlobalFilter.empty;
  }
  equals(tag) {
    return this.get() === tag;
  }
  includedIn(description) {
    const globalFilter = this.get();
    return description.includes(globalFilter);
  }
  prependTo(description) {
    return this.get() + " " + description;
  }
  removeAsWordFromDependingOnSettings(description) {
    const removeGlobalFilter = this.getRemoveGlobalFilter();
    if (removeGlobalFilter) {
      return this.removeAsWordFrom(description);
    }
    return description;
  }
  /**
   * @see setRemoveGlobalFilter
   */
  getRemoveGlobalFilter() {
    return this._removeGlobalFilter;
  }
  /**
   * @see getRemoveGlobalFilter
   */
  setRemoveGlobalFilter(removeGlobalFilter) {
    this._removeGlobalFilter = removeGlobalFilter;
  }
  /**
   * Search for the global filter for the purpose of removing it from the description, but do so only
   * if it is a separate word (preceding the beginning of line or a space and followed by the end of line
   * or a space), because we don't want to cut-off nested tags like #task/subtag.
   * If the global filter exists as part of a nested tag, we keep it untouched.
   */
  removeAsWordFrom(description) {
    if (this.isEmpty()) {
      return description;
    }
    const theRegExp = RegExp("(^|\\s)" + escapeRegExp(this.get()) + "($|\\s)", "ug");
    if (description.search(theRegExp) > -1) {
      description = description.replace(theRegExp, "$1$2").replace("  ", " ").trim();
    }
    return description;
  }
  removeAsSubstringFrom(description) {
    const globalFilter = this.get();
    return description.replace(globalFilter, "").trim();
  }
};
var GlobalFilter = _GlobalFilter;
__publicField(GlobalFilter, "instance");
__publicField(GlobalFilter, "empty", "");

// node_modules/obsidian-task/src/Task/TaskRegularExpressions.ts
var _TaskRegularExpressions = class {
};
var TaskRegularExpressions = _TaskRegularExpressions;
__publicField(TaskRegularExpressions, "dateFormat", "YYYY-MM-DD");
__publicField(TaskRegularExpressions, "dateTimeFormat", "YYYY-MM-DD HH:mm");
// Matches indentation before a list marker (including > for potentially nested blockquotes or Obsidian callouts)
__publicField(TaskRegularExpressions, "indentationRegex", /^([\s\t>]*)/);
// Matches - * and + list markers, or numbered list markers (eg 1.)
__publicField(TaskRegularExpressions, "listMarkerRegex", /([-*+]|[0-9]+\.)/);
// Matches a checkbox and saves the status character inside
__publicField(TaskRegularExpressions, "checkboxRegex", /\[(.)\]/u);
// Matches the rest of the task after the checkbox.
__publicField(TaskRegularExpressions, "afterCheckboxRegex", / *(.*)/u);
// Main regex for parsing a line. It matches the following:
// - Indentation
// - List marker
// - Status character
// - Rest of task after checkbox markdown
// See Task.extractTaskComponents() for abstraction around this regular expression.
// That is private for now, but could be made public in future if needed.
__publicField(TaskRegularExpressions, "taskRegex", new RegExp(
  _TaskRegularExpressions.indentationRegex.source + _TaskRegularExpressions.listMarkerRegex.source + " +" + _TaskRegularExpressions.checkboxRegex.source + _TaskRegularExpressions.afterCheckboxRegex.source,
  "u"
));
// Used with the "Create or Edit Task" command to parse indentation and status if present
__publicField(TaskRegularExpressions, "nonTaskRegex", new RegExp(
  _TaskRegularExpressions.indentationRegex.source + _TaskRegularExpressions.listMarkerRegex.source + "? *(" + _TaskRegularExpressions.checkboxRegex.source + ")?" + _TaskRegularExpressions.afterCheckboxRegex.source,
  "u"
));
// Used with "Toggle Done" command to detect a list item that can get a checkbox added to it.
__publicField(TaskRegularExpressions, "listItemRegex", new RegExp(
  _TaskRegularExpressions.indentationRegex.source + _TaskRegularExpressions.listMarkerRegex.source
));
// Match on block link at end.
__publicField(TaskRegularExpressions, "blockLinkRegex", / \^[a-zA-Z0-9-]+$/u);
// Regex to match all hash tags, basically hash followed by anything but the characters in the negation.
// To ensure URLs are not caught it is looking of beginning of string tag and any
// tag that has a space in front of it. Any # that has a character in front
// of it will be ignored.
// EXAMPLE:
// description: '#dog #car http://www/ddd#ere #house'
// matches: #dog, #car, #house
// MAINTENANCE NOTE:
//  If hashTags is modified, please update 'Recognising Tags' in Tags.md in the docs.
__publicField(TaskRegularExpressions, "hashTags", /(^|\s)#[^ !@#$%^&*(),.?":{}|<>]+/g);
__publicField(TaskRegularExpressions, "hashTagsFromEnd", new RegExp(_TaskRegularExpressions.hashTags.source + "$"));

// node_modules/obsidian-task/src/Suggestor/Suggestor.ts
var DEFAULT_MAX_GENERIC_SUGGESTIONS = 5;
function makeDefaultSuggestionBuilder(symbols, maxGenericSuggestions, dataviewMode) {
  const datePrefixRegex = [symbols.startDateSymbol, symbols.scheduledDateSymbol, symbols.dueDateSymbol].join("|");
  return (line, cursorPos, settings2) => {
    let suggestions = [];
    suggestions = suggestions.concat(
      addDatesSuggestions(line, cursorPos, settings2, datePrefixRegex, maxGenericSuggestions, dataviewMode)
    );
    suggestions = suggestions.concat(
      addRecurrenceSuggestions(line, cursorPos, settings2, symbols.recurrenceSymbol, dataviewMode)
    );
    suggestions = suggestions.concat(addTaskPropertySuggestions(line, cursorPos, settings2, symbols, dataviewMode));
    if (suggestions.length > 0 && !suggestions.some((value) => value.suggestionType === "match")) {
      if (!dataviewMode) {
        suggestions.unshift({
          suggestionType: "empty",
          displayText: "\u23CE",
          appendText: "\n"
        });
      }
    }
    suggestions = suggestions.slice(0, settings2.autoSuggestMaxItems);
    return suggestions;
  };
}
function getAdjusters(dataviewMode, line, cursorPos) {
  const closingBracket = lastOpenBracket(line.substring(0, cursorPos), [
    // TODO this array duplicates code in Settings.ts. Can we introduce an abstraction for this?
    ["(", ")"],
    ["[", "]"]
  ]) == "(" ? ")" : "]";
  const postfix = dataviewMode ? closingBracket + " " : " ";
  const insertSkip = dataviewMode && line.length > cursorPos && line.charAt(cursorPos) === closingBracket ? 1 : 0;
  return { postfix, insertSkip };
}
function addTaskPropertySuggestions(line, cursorPos, _settings, symbols, dataviewMode) {
  const hasPriority = (line2) => Object.values(symbols.prioritySymbols).some((value) => value.length > 0 && line2.includes(value));
  const genericSuggestions = [];
  const { postfix, insertSkip } = getAdjusters(dataviewMode, line, cursorPos);
  if (!line.includes(symbols.dueDateSymbol))
    genericSuggestions.push({
      displayText: `${symbols.dueDateSymbol} due date`,
      appendText: `${symbols.dueDateSymbol} `
    });
  if (!line.includes(symbols.startDateSymbol))
    genericSuggestions.push({
      displayText: `${symbols.startDateSymbol} start date`,
      appendText: `${symbols.startDateSymbol} `
    });
  if (!line.includes(symbols.scheduledDateSymbol))
    genericSuggestions.push({
      displayText: `${symbols.scheduledDateSymbol} scheduled date`,
      appendText: `${symbols.scheduledDateSymbol} `
    });
  if (!hasPriority(line)) {
    const prioritySymbols2 = symbols.prioritySymbols;
    const priorityTexts = ["High", "Medium", "Low", "Highest", "Lowest"];
    for (let i = 0; i < priorityTexts.length; i++) {
      const priorityText = priorityTexts[i];
      const prioritySymbol = prioritySymbols2[priorityText];
      genericSuggestions.push({
        displayText: dataviewMode ? `${prioritySymbol} priority` : `${prioritySymbol} ${priorityText.toLowerCase()} priority`,
        appendText: `${prioritySymbol}${postfix}`,
        insertSkip: dataviewMode ? insertSkip : void 0
      });
    }
  }
  if (!line.includes(symbols.recurrenceSymbol))
    genericSuggestions.push({
      displayText: `${symbols.recurrenceSymbol} recurring (repeat)`,
      appendText: `${symbols.recurrenceSymbol} `
    });
  if (!line.includes(symbols.createdDateSymbol)) {
    const parsedDate = DateParser.parseDate("today", true);
    const formattedDate = parsedDate.format(TaskRegularExpressions.dateFormat);
    genericSuggestions.push({
      // We don't want this to match when the user types "today"
      textToMatch: `${symbols.createdDateSymbol} created`,
      displayText: `${symbols.createdDateSymbol} created today (${formattedDate})`,
      appendText: `${symbols.createdDateSymbol} ${formattedDate}` + postfix,
      insertSkip: dataviewMode ? insertSkip : void 0
    });
  }
  const wordMatch = matchByPosition(line, /([a-zA-Z'_-]*)/g, cursorPos);
  const matchingSuggestions = [];
  if (wordMatch && wordMatch.length > 0) {
    const wordUnderCursor = wordMatch[0];
    if (wordUnderCursor.length >= Math.max(1, _settings.autoSuggestMinMatch)) {
      const filteredSuggestions = genericSuggestions.filter((suggestInfo) => {
        const textToMatch = suggestInfo.textToMatch || suggestInfo.displayText;
        return textToMatch.toLowerCase().includes(wordUnderCursor.toLowerCase());
      });
      for (const filtered of filteredSuggestions) {
        const insertSkipValue = dataviewMode && (filtered.displayText.includes("priority") || filtered.displayText.includes("created")) ? wordUnderCursor.length + insertSkip : wordUnderCursor.length;
        matchingSuggestions.push({
          suggestionType: "match",
          displayText: filtered.displayText,
          appendText: filtered.appendText,
          insertAt: wordMatch.index,
          insertSkip: insertSkipValue
        });
      }
    }
  }
  if (matchingSuggestions.length === 0 && _settings.autoSuggestMinMatch === 0)
    return genericSuggestions;
  return matchingSuggestions;
}
function addDatesSuggestions(line, cursorPos, settings2, datePrefixRegex, maxGenericSuggestions, dataviewMode) {
  const genericSuggestions = [
    "today",
    "tomorrow",
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "next week",
    "next month",
    "next year"
  ];
  const { postfix, insertSkip } = getAdjusters(dataviewMode, line, cursorPos);
  const results = [];
  const dateRegex = new RegExp(`(${datePrefixRegex})\\s*([0-9a-zA-Z ]*)`, "ug");
  const dateMatch = matchByPosition(line, dateRegex, cursorPos);
  if (dateMatch && dateMatch.length >= 2) {
    const datePrefix = dateMatch[1];
    const dateString = dateMatch[2];
    if (dateString.length < settings2.autoSuggestMinMatch) {
      return [];
    }
    const possibleDate = dateString && dateString.length > 1 ? DateParser.parseDate(doAutocomplete(dateString), true) : null;
    if (possibleDate && possibleDate.isValid()) {
      results.push({
        displayText: `${possibleDate.format(TaskRegularExpressions.dateFormat)}`,
        appendText: `${datePrefix} ${possibleDate.format(TaskRegularExpressions.dateFormat)} `,
        insertAt: dateMatch.index,
        insertSkip: dateMatch[0].length
      });
    }
    const minMatch = 1;
    let genericMatches = genericSuggestions.filter(
      (value) => dateString && dateString.length >= minMatch && value.toLowerCase().includes(dateString.toLowerCase())
    ).slice(0, maxGenericSuggestions);
    if (genericMatches.length === 0) {
      genericMatches = genericSuggestions.slice(0, maxGenericSuggestions);
    }
    for (const match of genericMatches) {
      const parsedDate = DateParser.parseDate(match, true);
      const formattedDate = `${parsedDate.format(TaskRegularExpressions.dateFormat)}`;
      const insertSkipValue = dataviewMode ? dateMatch[0].length + insertSkip : dateMatch[0].length;
      results.push({
        suggestionType: "match",
        displayText: `${match} (${formattedDate})`,
        appendText: `${datePrefix} ${formattedDate}` + postfix,
        insertAt: dateMatch.index,
        insertSkip: insertSkipValue
      });
    }
  }
  return results;
}
function addRecurrenceSuggestions(line, cursorPos, settings2, recurrenceSymbol, dataviewMode) {
  const genericSuggestions = [
    "every",
    "every day",
    "every week",
    "every month",
    "every month on the",
    "every year",
    "every week on Sunday",
    "every week on Monday",
    "every week on Tuesday",
    "every week on Wednesday",
    "every week on Thursday",
    "every week on Friday",
    "every week on Saturday"
  ];
  const { postfix, insertSkip } = getAdjusters(dataviewMode, line, cursorPos);
  const results = [];
  const recurrenceRegex = new RegExp(`(${recurrenceSymbol})\\s*([0-9a-zA-Z ]*)`, "ug");
  const recurrenceMatch = matchByPosition(line, recurrenceRegex, cursorPos);
  if (recurrenceMatch && recurrenceMatch.length >= 2) {
    const recurrencePrefix = recurrenceMatch[1];
    const recurrenceString = recurrenceMatch[2];
    if (recurrenceString.length < settings2.autoSuggestMinMatch)
      return [];
    if (recurrenceString.length > 0) {
      const parsedRecurrence = Recurrence.fromText({
        recurrenceRuleText: recurrenceString,
        startDate: null,
        scheduledDate: null,
        dueDate: null
      })?.toText();
      if (parsedRecurrence) {
        const appendedText = `${recurrencePrefix} ${parsedRecurrence}` + postfix;
        const insertSkipValue = dataviewMode ? recurrenceMatch[0].length + insertSkip : recurrenceMatch[0].length;
        results.push({
          suggestionType: "match",
          displayText: `\u2705 ${parsedRecurrence}`,
          appendText: appendedText,
          insertAt: recurrenceMatch.index,
          insertSkip: insertSkipValue
        });
        if (recurrenceMatch[0] == appendedText)
          return [];
      }
    }
    const minMatch = 1;
    const maxGenericDateSuggestions = settings2.autoSuggestMaxItems / 2;
    let genericMatches = genericSuggestions.filter(
      (value) => recurrenceString && recurrenceString.length >= minMatch && value.toLowerCase().includes(recurrenceString.toLowerCase())
    ).slice(0, maxGenericDateSuggestions);
    if (genericMatches.length === 0 && recurrenceString.trim().length === 0) {
      genericMatches = genericSuggestions.slice(0, maxGenericDateSuggestions);
    }
    for (const match of genericMatches) {
      results.push({
        suggestionType: "match",
        displayText: `${match}`,
        appendText: `${recurrencePrefix} ${match} `,
        insertAt: recurrenceMatch.index,
        insertSkip: recurrenceMatch[0].length
      });
    }
  }
  return results;
}
function matchByPosition(s, r, position) {
  const matches = s.matchAll(r);
  for (const match of matches) {
    if (match?.index && match.index <= position && position <= match.index + match[0].length)
      return match;
  }
}
function isAnyBracketOpen(line, brackets) {
  if (brackets.length === 0) {
    return false;
  }
  const numOpeningBrackets = Object.fromEntries(brackets.map(([open, _]) => [open, 0]));
  const openingOf = Object.fromEntries(brackets.map(([open, close]) => [close, open]));
  for (const c of line) {
    if (c in numOpeningBrackets) {
      numOpeningBrackets[c]++;
    } else if (c in openingOf) {
      numOpeningBrackets[openingOf[c]] = Math.max(0, numOpeningBrackets[openingOf[c]] - 1);
    }
  }
  return Object.values(numOpeningBrackets).some((n) => n > 0);
}
function lastOpenBracket(line, brackets) {
  if (brackets.length === 0) {
    return null;
  }
  const numOpeningBrackets = Object.fromEntries(brackets.map(([open, _]) => [open, 0]));
  const openingOf = Object.fromEntries(brackets.map(([open, close]) => [close, open]));
  const openBracketsStack = [];
  for (let i = 0; i < line.length; i++) {
    const c = line[i];
    if (c in numOpeningBrackets) {
      numOpeningBrackets[c]++;
      openBracketsStack.push({ bracket: c, idx: i });
    } else if (c in openingOf) {
      if (numOpeningBrackets[openingOf[c]] >= 1) {
        for (let idx = openBracketsStack.length - 1; idx >= 0; idx--) {
          if (openBracketsStack[idx].bracket == openingOf[c]) {
            openBracketsStack.splice(idx, 1);
            break;
          }
        }
      }
      numOpeningBrackets[openingOf[c]] = Math.max(0, numOpeningBrackets[openingOf[c]] - 1);
    }
  }
  return openBracketsStack.length > 0 ? openBracketsStack[openBracketsStack.length - 1].bracket : null;
}
function onlySuggestIfBracketOpen(fn2, brackets) {
  return (line, cursorPos, settings2) => {
    if (!isAnyBracketOpen(line.slice(0, cursorPos), brackets)) {
      return [];
    }
    return fn2(line, cursorPos, settings2);
  };
}

// node_modules/obsidian-task/src/Layout/TaskLayoutOptions.ts
var TaskLayoutComponent = /* @__PURE__ */ ((TaskLayoutComponent2) => {
  TaskLayoutComponent2["Description"] = "description";
  TaskLayoutComponent2["Id"] = "id";
  TaskLayoutComponent2["DependsOn"] = "dependsOn";
  TaskLayoutComponent2["Priority"] = "priority";
  TaskLayoutComponent2["RecurrenceRule"] = "recurrenceRule";
  TaskLayoutComponent2["CreatedDate"] = "createdDate";
  TaskLayoutComponent2["StartDate"] = "startDate";
  TaskLayoutComponent2["ScheduledDate"] = "scheduledDate";
  TaskLayoutComponent2["DueDate"] = "dueDate";
  TaskLayoutComponent2["CancelledDate"] = "cancelledDate";
  TaskLayoutComponent2["DoneDate"] = "doneDate";
  TaskLayoutComponent2["BlockLink"] = "blockLink";
  return TaskLayoutComponent2;
})(TaskLayoutComponent || {});
var taskLayoutComponents = Object.values(TaskLayoutComponent);
var TaskLayoutOptions = class {
  visible = {};
  tagsVisible = true;
  constructor() {
    taskLayoutComponents.forEach((component) => {
      this.visible[component] = true;
    });
  }
  isShown(component) {
    return this.visible[component];
  }
  areTagsShown() {
    return this.tagsVisible;
  }
  hide(component) {
    this.visible[component] = false;
  }
  setVisibility(component, visible) {
    this.visible[component] = visible;
  }
  setTagsVisibility(visibility) {
    this.tagsVisible = visibility;
  }
  get shownComponents() {
    return taskLayoutComponents.filter((component) => {
      return this.visible[component];
    });
  }
  get hiddenComponents() {
    return taskLayoutComponents.filter((component) => {
      return !this.visible[component];
    });
  }
  /**
   * These represent the existing task options, so some components (description & block link for now) are not
   * here because there are no layout options to remove them.
   */
  get toggleableComponents() {
    return taskLayoutComponents.filter((component) => {
      return component !== "description" /* Description */ && component !== "blockLink" /* BlockLink */;
    });
  }
  toggleVisibilityExceptDescriptionAndBlockLink() {
    this.toggleableComponents.forEach((component) => {
      this.visible[component] = !this.visible[component];
    });
    this.setTagsVisibility(!this.areTagsShown());
  }
};

// node_modules/obsidian-task/src/TaskSerializer/DefaultTaskSerializer.ts
var taskIdRegex = /[a-zA-Z0-9-_]+/;
var DEFAULT_SYMBOLS = {
  // NEW_TASK_FIELD_EDIT_REQUIRED
  prioritySymbols: {
    Highest: "\u{1F53A}",
    High: "\u23EB",
    Medium: "\u{1F53C}",
    Low: "\u{1F53D}",
    Lowest: "\u23EC",
    None: ""
  },
  startDateSymbol: "\u{1F6EB}",
  createdDateSymbol: "\u2795",
  scheduledDateSymbol: "\u23F3",
  dueDateSymbol: "\u{1F4C5}",
  doneDateSymbol: "\u2705",
  cancelledDateSymbol: "\u274C",
  recurrenceSymbol: "\u{1F501}",
  dependsOnSymbol: "\u26D4\uFE0F",
  idSymbol: "\u{1F194}",
  TaskFormatRegularExpressions: {
    // The following regex's end with `$` because they will be matched and
    // removed from the end until none are left.
    priorityRegex: /([🔺⏫🔼🔽⏬])$/u,
    startDateRegex: /🛫 *(\d{4}-\d{2}-\d{2})$/u,
    createdDateRegex: /➕ *(\d{4}-\d{2}-\d{2})$/u,
    scheduledDateRegex: /[⏳⌛] *(\d{4}-\d{2}-\d{2})$/u,
    dueDateRegex: /[📅📆🗓] *(\d{4}-\d{2}-\d{2})$/u,
    doneDateRegex: /✅ *(\d{4}-\d{2}-\d{2})$/u,
    cancelledDateRegex: /❌ *(\d{4}-\d{2}-\d{2})$/u,
    recurrenceRegex: /🔁 ?([a-zA-Z0-9, !]+)$/iu,
    dependsOnRegex: new RegExp("\u26D4\uFE0F *(" + taskIdRegex.source + "( *, *" + taskIdRegex.source + " *)*)$", "iu"),
    idRegex: new RegExp("\u{1F194} *(" + taskIdRegex.source + ")$", "iu")
  }
};
function symbolAndStringValue(shortMode, symbol, value) {
  if (!value)
    return "";
  return shortMode ? " " + symbol : ` ${symbol} ${value}`;
}
function symbolAndDateValue(shortMode, symbol, date) {
  if (!date)
    return "";
  return shortMode ? " " + symbol : ` ${symbol} ${date.format(TaskRegularExpressions.dateFormat)}`;
}
var DefaultTaskSerializer = class {
  constructor(symbols) {
    this.symbols = symbols;
  }
  /* Convert a task to its string representation
   *
   * @param task The task to serialize
   *
   * @return The string representation of the task
   */
  serialize(task) {
    const taskLayoutOptions = new TaskLayoutOptions();
    let taskString = "";
    const shortMode = false;
    for (const component of taskLayoutOptions.shownComponents) {
      taskString += this.componentToString(task, shortMode, component);
    }
    return taskString;
  }
  /**
   * Renders a specific TaskLayoutComponent of the task (its description, priority, etc) as a string.
   */
  componentToString(task, shortMode, component) {
    const {
      // NEW_TASK_FIELD_EDIT_REQUIRED
      prioritySymbols: prioritySymbols2,
      startDateSymbol,
      createdDateSymbol,
      scheduledDateSymbol,
      doneDateSymbol,
      cancelledDateSymbol,
      recurrenceSymbol,
      dueDateSymbol,
      dependsOnSymbol,
      idSymbol
    } = this.symbols;
    switch (component) {
      case "description" /* Description */:
        return task.description;
      case "priority" /* Priority */: {
        let priority = "";
        if (task.priority === "0" /* Highest */) {
          priority = " " + prioritySymbols2.Highest;
        } else if (task.priority === "1" /* High */) {
          priority = " " + prioritySymbols2.High;
        } else if (task.priority === "2" /* Medium */) {
          priority = " " + prioritySymbols2.Medium;
        } else if (task.priority === "4" /* Low */) {
          priority = " " + prioritySymbols2.Low;
        } else if (task.priority === "5" /* Lowest */) {
          priority = " " + prioritySymbols2.Lowest;
        }
        return priority;
      }
      case "startDate" /* StartDate */:
        return symbolAndDateValue(shortMode, startDateSymbol, task.startDate);
      case "createdDate" /* CreatedDate */:
        return symbolAndDateValue(shortMode, createdDateSymbol, task.createdDate);
      case "scheduledDate" /* ScheduledDate */:
        if (task.scheduledDateIsInferred)
          return "";
        return symbolAndDateValue(shortMode, scheduledDateSymbol, task.scheduledDate);
      case "doneDate" /* DoneDate */:
        return symbolAndDateValue(shortMode, doneDateSymbol, task.doneDate);
      case "cancelledDate" /* CancelledDate */:
        return symbolAndDateValue(shortMode, cancelledDateSymbol, task.cancelledDate);
      case "dueDate" /* DueDate */:
        return symbolAndDateValue(shortMode, dueDateSymbol, task.dueDate);
      case "recurrenceRule" /* RecurrenceRule */:
        if (!task.recurrence)
          return "";
        return symbolAndStringValue(shortMode, recurrenceSymbol, task.recurrence.toText());
      case "dependsOn" /* DependsOn */: {
        if (task.dependsOn.length === 0)
          return "";
        return symbolAndStringValue(shortMode, dependsOnSymbol, task.dependsOn.join(","));
      }
      case "id" /* Id */:
        return symbolAndStringValue(shortMode, idSymbol, task.id);
      case "blockLink" /* BlockLink */:
        return task.blockLink ?? "";
      default:
        throw new Error(`Don't know how to render task component of type '${component}'`);
    }
  }
  /**
   * Given the string captured in the first capture group of
   *    {@link DefaultTaskSerializerSymbols.TaskFormatRegularExpressions.priorityRegex},
   *    returns the corresponding Priority level.
   *
   * @param p String captured by priorityRegex
   * @returns Corresponding priority if parsing was successful, otherwise {@link Priority.None}
   */
  parsePriority(p) {
    const { prioritySymbols: prioritySymbols2 } = this.symbols;
    switch (p) {
      case prioritySymbols2.Lowest:
        return "5" /* Lowest */;
      case prioritySymbols2.Low:
        return "4" /* Low */;
      case prioritySymbols2.Medium:
        return "2" /* Medium */;
      case prioritySymbols2.High:
        return "1" /* High */;
      case prioritySymbols2.Highest:
        return "0" /* Highest */;
      default:
        return "3" /* None */;
    }
  }
  /* Parse TaskDetails from the textual description of a {@link Task}
   *
   * @param line The string to parse
   *
   * @return {TaskDetails}
   */
  deserialize(line) {
    const { TaskFormatRegularExpressions } = this.symbols;
    let matched;
    let priority = "3" /* None */;
    let startDate = null;
    let scheduledDate = null;
    let dueDate = null;
    let doneDate = null;
    let cancelledDate = null;
    let createdDate = null;
    let recurrenceRule = "";
    let recurrence = null;
    let id = "";
    let dependsOn = [];
    let trailingTags = "";
    const maxRuns = 20;
    let runs = 0;
    do {
      matched = false;
      const priorityMatch = line.match(TaskFormatRegularExpressions.priorityRegex);
      if (priorityMatch !== null) {
        priority = this.parsePriority(priorityMatch[1]);
        line = line.replace(TaskFormatRegularExpressions.priorityRegex, "").trim();
        matched = true;
      }
      const doneDateMatch = line.match(TaskFormatRegularExpressions.doneDateRegex);
      if (doneDateMatch !== null) {
        doneDate = window.moment(doneDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.doneDateRegex, "").trim();
        matched = true;
      }
      const cancelledDateMatch = line.match(TaskFormatRegularExpressions.cancelledDateRegex);
      if (cancelledDateMatch !== null) {
        cancelledDate = window.moment(cancelledDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.cancelledDateRegex, "").trim();
        matched = true;
      }
      const dueDateMatch = line.match(TaskFormatRegularExpressions.dueDateRegex);
      if (dueDateMatch !== null) {
        dueDate = window.moment(dueDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.dueDateRegex, "").trim();
        matched = true;
      }
      const scheduledDateMatch = line.match(TaskFormatRegularExpressions.scheduledDateRegex);
      if (scheduledDateMatch !== null) {
        scheduledDate = window.moment(scheduledDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.scheduledDateRegex, "").trim();
        matched = true;
      }
      const startDateMatch = line.match(TaskFormatRegularExpressions.startDateRegex);
      if (startDateMatch !== null) {
        startDate = window.moment(startDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.startDateRegex, "").trim();
        matched = true;
      }
      const createdDateMatch = line.match(TaskFormatRegularExpressions.createdDateRegex);
      if (createdDateMatch !== null) {
        createdDate = window.moment(createdDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.createdDateRegex, "").trim();
        matched = true;
      }
      const recurrenceMatch = line.match(TaskFormatRegularExpressions.recurrenceRegex);
      if (recurrenceMatch !== null) {
        recurrenceRule = recurrenceMatch[1].trim();
        line = line.replace(TaskFormatRegularExpressions.recurrenceRegex, "").trim();
        matched = true;
      }
      const tagsMatch = line.match(TaskRegularExpressions.hashTagsFromEnd);
      if (tagsMatch != null) {
        line = line.replace(TaskRegularExpressions.hashTagsFromEnd, "").trim();
        matched = true;
        const tagName = tagsMatch[0].trim();
        trailingTags = trailingTags.length > 0 ? [tagName, trailingTags].join(" ") : tagName;
      }
      const idMatch = line.match(TaskFormatRegularExpressions.idRegex);
      if (idMatch != null) {
        line = line.replace(TaskFormatRegularExpressions.idRegex, "").trim();
        id = idMatch[1].trim();
        matched = true;
      }
      const dependsOnMatch = line.match(TaskFormatRegularExpressions.dependsOnRegex);
      if (dependsOnMatch != null) {
        line = line.replace(TaskFormatRegularExpressions.dependsOnRegex, "").trim();
        dependsOn = dependsOnMatch[1].replace(/ /g, "").split(",").filter((item) => item !== "");
        matched = true;
      }
      runs++;
    } while (matched && runs <= maxRuns);
    if (recurrenceRule.length > 0) {
      recurrence = Recurrence.fromText({
        recurrenceRuleText: recurrenceRule,
        startDate,
        scheduledDate,
        dueDate
      });
    }
    if (trailingTags.length > 0)
      line += " " + trailingTags;
    return {
      description: line,
      priority,
      startDate,
      createdDate,
      scheduledDate,
      dueDate,
      doneDate,
      cancelledDate,
      recurrence,
      id,
      dependsOn,
      tags: Task.extractHashtags(line)
    };
  }
};

// node_modules/obsidian-task/src/TaskSerializer/DataviewTaskSerializer.ts
function toInlineFieldRegex(innerFieldRegex) {
  const fieldRegex = [
    "(?:",
    /*     */
    /(?=[^\]]+\])\[/,
    // Try to match '[' if there's a ']' later in the string
    /*    */
    "|",
    /*     */
    /(?=[^)]+\))\(/,
    // Otherwise, match '(' if there's a ')' later in the string
    ")",
    / */,
    innerFieldRegex,
    / */,
    /[)\]]/,
    /(?: *,)?/,
    // Allow trailing comma, enables workaround from #1913 for rendering issue
    /$/
    // Regexes are matched from the end of the string forwards
  ].map((val) => val instanceof RegExp ? val.source : val).join("");
  return new RegExp(fieldRegex, innerFieldRegex.flags);
}
var DATAVIEW_SYMBOLS = {
  // NEW_TASK_FIELD_EDIT_REQUIRED
  prioritySymbols: {
    Highest: "priority:: highest",
    High: "priority:: high",
    Medium: "priority:: medium",
    Low: "priority:: low",
    Lowest: "priority:: lowest",
    None: ""
  },
  startDateSymbol: "start::",
  createdDateSymbol: "created::",
  scheduledDateSymbol: "scheduled::",
  dueDateSymbol: "due::",
  doneDateSymbol: "completion::",
  cancelledDateSymbol: "cancelled::",
  recurrenceSymbol: "repeat::",
  idSymbol: "id::",
  dependsOnSymbol: "dependsOn::",
  TaskFormatRegularExpressions: {
    priorityRegex: toInlineFieldRegex(/priority:: *(highest|high|medium|low|lowest)/),
    startDateRegex: toInlineFieldRegex(/start:: *(\d{4}-\d{2}-\d{2})/),
    createdDateRegex: toInlineFieldRegex(/created:: *(\d{4}-\d{2}-\d{2})/),
    scheduledDateRegex: toInlineFieldRegex(/scheduled:: *(\d{4}-\d{2}-\d{2})/),
    dueDateRegex: toInlineFieldRegex(/due:: *(\d{4}-\d{2}-\d{2})/),
    doneDateRegex: toInlineFieldRegex(/completion:: *(\d{4}-\d{2}-\d{2})/),
    cancelledDateRegex: toInlineFieldRegex(/cancelled:: *(\d{4}-\d{2}-\d{2})/),
    recurrenceRegex: toInlineFieldRegex(/repeat:: *([a-zA-Z0-9, !]+)/),
    dependsOnRegex: toInlineFieldRegex(
      new RegExp("dependsOn:: *(" + taskIdRegex.source + "( *, *" + taskIdRegex.source + " *)*)")
    ),
    idRegex: toInlineFieldRegex(new RegExp("id:: *(" + taskIdRegex.source + ")"))
  }
};
var DataviewTaskSerializer = class extends DefaultTaskSerializer {
  constructor() {
    super(DATAVIEW_SYMBOLS);
  }
  parsePriority(p) {
    switch (p) {
      case "highest":
        return "0" /* Highest */;
      case "high":
        return "1" /* High */;
      case "medium":
        return "2" /* Medium */;
      case "low":
        return "4" /* Low */;
      case "lowest":
        return "5" /* Lowest */;
      default:
        return "3" /* None */;
    }
  }
  componentToString(task, shortMode, component) {
    const stringComponent = super.componentToString(task, shortMode, component);
    const notInlineFieldComponents = [
      "blockLink" /* BlockLink */,
      "description" /* Description */
    ];
    const shouldMakeInlineField = stringComponent !== "" && !notInlineFieldComponents.includes(component);
    return shouldMakeInlineField ? (
      // Having 2 (TWO) leading spaces avoids a rendering issues that makes every other
      // square-bracketed inline-field invisible.
      // See https://github.com/obsidian-tasks-group/obsidian-tasks/issues/1913
      `  [${stringComponent.trim()}]`
    ) : stringComponent;
  }
};

// node_modules/obsidian-task/src/Statuses/StatusConfiguration.ts
var StatusType = /* @__PURE__ */ ((StatusType2) => {
  StatusType2["TODO"] = "TODO";
  StatusType2["DONE"] = "DONE";
  StatusType2["IN_PROGRESS"] = "IN_PROGRESS";
  StatusType2["CANCELLED"] = "CANCELLED";
  StatusType2["NON_TASK"] = "NON_TASK";
  StatusType2["EMPTY"] = "EMPTY";
  return StatusType2;
})(StatusType || {});
var StatusConfiguration = class {
  /**
   * The character used between the two square brackets in the markdown task.
   *
   * @type {string}
   * @memberof Status
   */
  symbol;
  /**
   * Returns the name of the status for display purposes.
   *
   * @type {string}
   * @memberof Status
   */
  name;
  /**
   * Returns the next status for a task when toggled.
   *
   * @type {string}
   * @memberof Status
   */
  nextStatusSymbol;
  /**
   * If true then it is registered as a command that the user can map to.
   *
   * @type {boolean}
   * @memberof Status
   */
  availableAsCommand;
  /**
   * Returns the status type. See {@link StatusType} for details.
   */
  type;
  /**
   * Creates an instance of Status. The registry will be added later in the case
   * of the default statuses.
   *
   * @param {string} symbol
   * @param {string} name
   * @param {Status} nextStatusSymbol
   * @param {boolean} availableAsCommand
   * @param {StatusType} type
   * @memberof Status
   */
  constructor(symbol, name, nextStatusSymbol, availableAsCommand, type = "TODO" /* TODO */) {
    this.symbol = symbol;
    this.name = name;
    this.nextStatusSymbol = nextStatusSymbol;
    this.availableAsCommand = availableAsCommand;
    this.type = type;
  }
};

// node_modules/obsidian-task/src/Statuses/Status.ts
var _Status = class {
  /**
   * The configuration stored in the data.json file.
   *
   * @type {StatusConfiguration}
   * @memberof Status
   */
  configuration;
  /**
   * The symbol used between the two square brackets in the markdown task.
   *
   * @type {string}
   * @memberof Status
   */
  get symbol() {
    return this.configuration.symbol;
  }
  /**
   * Returns the name of the status for display purposes.
   *
   * @type {string}
   * @memberof Status
   */
  get name() {
    return this.configuration.name;
  }
  /**
   * Returns the next status for a task when toggled.
   *
   * @type {string}
   * @memberof Status
   * @see nextSymbol
   */
  get nextStatusSymbol() {
    return this.configuration.nextStatusSymbol;
  }
  /**
   * Returns the next status for a task when toggled.
   * This is an alias for {@link nextStatusSymbol} which is provided for brevity in user scripts.
   *
   * @type {string}
   * @memberof Status
   * @see nextStatusSymbol
   */
  get nextSymbol() {
    return this.configuration.nextStatusSymbol;
  }
  /**
   * If true then it is registered as a command that the user can map to.
   *
   * @type {boolean}
   * @memberof Status
   */
  get availableAsCommand() {
    return this.configuration.availableAsCommand;
  }
  /**
   * Returns the status type. See {@link StatusType} for details.
   */
  get type() {
    return this.configuration.type;
  }
  /**
   * Returns the text to be used to represent the {@link StatusType} in group headings.
   *
   * The status types are in the same order as given by 'group by status.type'.
   * This is provided as a convenience for use in custom grouping.
   */
  get typeGroupText() {
    const type = this.type;
    let prefix;
    switch (type) {
      case "IN_PROGRESS" /* IN_PROGRESS */:
        prefix = "1";
        break;
      case "TODO" /* TODO */:
        prefix = "2";
        break;
      case "DONE" /* DONE */:
        prefix = "3";
        break;
      case "CANCELLED" /* CANCELLED */:
        prefix = "4";
        break;
      case "NON_TASK" /* NON_TASK */:
        prefix = "5";
        break;
      case "EMPTY" /* EMPTY */:
        prefix = "6";
        break;
    }
    return `%%${prefix}%%${type}`;
  }
  /**
   * Creates an instance of Status. The registry will be added later in the case
   * of the default statuses.
   *
   * @param {StatusConfiguration} configuration
   * @memberof Status
   */
  constructor(configuration) {
    this.configuration = configuration;
  }
  /**
   * The default Done status. Goes to Todo when toggled.
   */
  static makeDone() {
    return new _Status(new StatusConfiguration("x", "Done", " ", true, "DONE" /* DONE */));
  }
  /**
   * A default status of empty, used when things go wrong.
   */
  static makeEmpty() {
    return new _Status(new StatusConfiguration("", "EMPTY", "", true, "EMPTY" /* EMPTY */));
  }
  /**
   * The default Todo status. Goes to Done when toggled.
   * User may later be able to override this to go to In Progress instead.
   */
  static makeTodo() {
    return new _Status(new StatusConfiguration(" ", "Todo", "x", true, "TODO" /* TODO */));
  }
  /**
   * The default Cancelled status. Goes to Todo when toggled.
   */
  static makeCancelled() {
    return new _Status(new StatusConfiguration("-", "Cancelled", " ", true, "CANCELLED" /* CANCELLED */));
  }
  /**
   * The default In Progress status. Goes to Done when toggled.
   */
  static makeInProgress() {
    return new _Status(new StatusConfiguration("/", "In Progress", "x", true, "IN_PROGRESS" /* IN_PROGRESS */));
  }
  /**
   * A sample Non-Task status. Goes to NON_TASK when toggled.
   */
  static makeNonTask() {
    return new _Status(new StatusConfiguration("Q", "Non-Task", "A", true, "NON_TASK" /* NON_TASK */));
  }
  /**
   * Return the StatusType to use for a symbol, if it is not in the StatusRegistry.
   * The core symbols are recognised.
   * Other symbols are treated as StatusType.TODO
   * @param symbol
   */
  static getTypeForUnknownSymbol(symbol) {
    switch (symbol) {
      case "x":
      case "X":
        return "DONE" /* DONE */;
      case "/":
        return "IN_PROGRESS" /* IN_PROGRESS */;
      case "-":
        return "CANCELLED" /* CANCELLED */;
      case "":
        return "EMPTY" /* EMPTY */;
      case " ":
      default:
        return "TODO" /* TODO */;
    }
  }
  /**
   * Convert text that was saved from a StatusType value back to a StatusType.
   * Returns StatusType.TODO if the string is not valid.
   * @param statusTypeAsString
   */
  static getTypeFromStatusTypeString(statusTypeAsString) {
    return StatusType[statusTypeAsString] || "TODO" /* TODO */;
  }
  /**
   * Create a Status representing the given, unknown symbol.
   *
   * This can be useful when StatusRegistry does not recognise a symbol,
   * and we do not want to expose the user's data to the Status.EMPTY status.
   *
   * The type is set to TODO.
   * @param unknownSymbol
   */
  static createUnknownStatus(unknownSymbol) {
    return new _Status(new StatusConfiguration(unknownSymbol, "Unknown", "x", false, "TODO" /* TODO */));
  }
  /**
   * Helper function for bulk-importing settings from arrays of strings.
   *
   * @param imported An array of symbol, name, next symbol, status type
   */
  static createFromImportedValue(imported) {
    const symbol = imported[0];
    const type = _Status.getTypeFromStatusTypeString(imported[3]);
    return new _Status(new StatusConfiguration(symbol, imported[1], imported[2], false, type));
  }
  /**
   * Returns the completion status for a task, this is only supported
   * when the task is done/x.
   *
   * @return {*}  {boolean}
   * @memberof Status
   */
  isCompleted() {
    return this.type === "DONE" /* DONE */;
  }
  /**
   * Whether the task status type is {@link CANCELLED}.
   */
  isCancelled() {
    return this.type === "CANCELLED" /* CANCELLED */;
  }
  /**
   * Compare all the fields in another Status, to detect any differences from this one.
   *
   * If any field is different in any way, it will return false.
   *
   * @param other
   */
  identicalTo(other) {
    const args = [
      "symbol",
      "name",
      "nextStatusSymbol",
      "availableAsCommand",
      "type"
    ];
    for (const el of args) {
      if (this[el] !== other[el])
        return false;
    }
    return true;
  }
  /**
   * Return a one-line summary of the status, for presentation to users.
   */
  previewText() {
    let commandNotice = "";
    if (_Status.tasksPluginCanCreateCommandsForStatuses() && this.availableAsCommand) {
      commandNotice = " Available as a command.";
    }
    return `- [${this.symbol}] => [${this.nextStatusSymbol}], name: '${this.name}', type: '${this.configuration.type}'.${commandNotice}`;
  }
  /**
   * Whether Tasks can yet create 'Toggle Status' commands for statuses
   *
   * This is not yet possible, and so some UI features are temporarily hidden.
   * See https://github.com/obsidian-tasks-group/obsidian-tasks/issues/1486
   * Once that issue is addressed, this method can be removed.
   */
  static tasksPluginCanCreateCommandsForStatuses() {
    return false;
  }
};
var Status = _Status;
/**
 * The default Done status. Goes to Todo when toggled.
 *
 * @static
 * @type {Status}
 * @memberof Status
 */
__publicField(Status, "DONE", _Status.makeDone());
/**
 * A default status of empty, used when things go wrong.
 *
 * @static
 * @memberof Status
 */
__publicField(Status, "EMPTY", _Status.makeEmpty());
/**
 * The default Todo status. Goes to Done when toggled.
 * User may later be able to override this to go to In Progress instead.
 *
 * @static
 * @type {Status}
 * @memberof Status
 */
__publicField(Status, "TODO", _Status.makeTodo());

// node_modules/obsidian-task/src/Config/DebugSettings.ts
var DebugSettings = class {
  constructor(ignoreSortInstructions = false, showTaskHiddenData = false) {
    this.ignoreSortInstructions = ignoreSortInstructions;
    this.showTaskHiddenData = showTaskHiddenData;
  }
  // Optionally disable all sorting of search results, so that tasks are
  // displayed in the order they appear in the file.
  ignoreSortInstructions;
  showTaskHiddenData;
};

// node_modules/obsidian-task/src/Config/StatusSettings.ts
var StatusSettings = class {
  constructor() {
    this.coreStatuses = [
      // The two statuses that do not need CSS styling
      Status.makeTodo().configuration,
      Status.makeDone().configuration
    ];
    this.customStatuses = [
      // Any statuses that are always supported, but need custom CSS styling
      Status.makeInProgress().configuration,
      Status.makeCancelled().configuration
    ];
  }
  coreStatuses;
  customStatuses;
  /**
   * Add a new custom status.
   *
   * This is static so that it can be called from modal onClick() call-backs.
   *
   * - Currently, duplicates are allowed.
   * - Allows empty StatusConfiguration objects - where every string is empty
   * @param statuses
   * @param newStatus
   */
  static addStatus(statuses, newStatus) {
    statuses.push(newStatus);
  }
  /**
   * Replace the given status, to effectively edit it.
   * Returns true if the settings were changed.
   *
   * This is static so that it can be called from modal onClick() call-backs.
   *
   * - Does not currently check whether the status character is the same
   * - If the status character is different, does not check whether the new one is already used in another status
   * @param statuses
   * @param originalStatus
   * @param newStatus
   */
  static replaceStatus(statuses, originalStatus, newStatus) {
    const index = this.findStatusIndex(originalStatus, statuses);
    if (index <= -1) {
      return false;
    }
    statuses.splice(index, 1, newStatus);
    return true;
  }
  /**
   * This is a workaround for the fact that statusSettings.customStatusTypes.indexOf(statusConfiguration)
   * stopped finding identical statuses since the addition of StatusConfiguration.type.
   * @param statusConfiguration
   * @param statuses
   * @private
   */
  static findStatusIndex(statusConfiguration, statuses) {
    const originalStatusAsStatus = new Status(statusConfiguration);
    return statuses.findIndex((s) => {
      return new Status(s).previewText() == originalStatusAsStatus.previewText();
    });
  }
  /**
   * Delete the given status.
   * Returns true if deleted, and false if not.
   *
   * This is static so that it can be called from modal onClick() call-backs.
   *
   * @param statuses
   * @param status
   */
  static deleteStatus(statuses, status) {
    const index = this.findStatusIndex(status, statuses);
    if (index <= -1) {
      return false;
    }
    statuses.splice(index, 1);
    return true;
  }
  /**
   * Delete all custom statuses.
   *
   * This is static so that it can be called from modal onClick() call-backs.
   *
   * @param statusSettings
   */
  static deleteAllCustomStatuses(statusSettings) {
    statusSettings.customStatuses.splice(0);
  }
  /**
   * Restore the default custom statuses.
   *
   * @param statusSettings
   */
  static resetAllCustomStatuses(statusSettings) {
    StatusSettings.deleteAllCustomStatuses(statusSettings);
    const defaultSettings2 = new StatusSettings();
    defaultSettings2.customStatuses.forEach((s) => {
      StatusSettings.addStatus(statusSettings.customStatuses, s);
    });
  }
  /**
   * Add a collection of custom supported statuses to a StatusSettings.
   * This can be used to quickly populate the user's settings.
   * If there are any exact duplicates already present, they are skipped, and noted in the returned value.
   *
   * This is static so that it can be called from modal onClick() call-backs.
   *
   * @param statusSettings a StatusSettings
   * @param supportedStatuses - an array of status specifications, for example `['b', 'Bookmark', 'x']`
   * @return An array of warning messages to show the user, one for each rejected exact duplicate status.
   *
   * @see {@link minimalSupportedStatuses}, {@link itsSupportedStatuses}
   */
  static bulkAddStatusCollection(statusSettings, supportedStatuses) {
    const notices = [];
    supportedStatuses.forEach((importedStatus) => {
      const hasStatus = statusSettings.customStatuses.find((element) => {
        return element.symbol == importedStatus[0] && element.name == importedStatus[1] && element.nextStatusSymbol == importedStatus[2];
      });
      if (!hasStatus) {
        StatusSettings.addStatus(statusSettings.customStatuses, Status.createFromImportedValue(importedStatus));
      } else {
        notices.push(`The status ${importedStatus[1]} (${importedStatus[0]}) is already added.`);
      }
    });
    return notices;
  }
  /**
   * Retun a list of all the statuses in the settings - first the core ones, then the custom ones.
   * @param statusSettings
   */
  static allStatuses(statusSettings) {
    return statusSettings.coreStatuses.concat(statusSettings.customStatuses);
  }
  /**
   * Apply the custom statuses in the statusSettings object to the statusRegistry.
   * @param statusSettings
   * @param statusRegistry
   */
  static applyToStatusRegistry(statusSettings, statusRegistry) {
    statusRegistry.clearStatuses();
    StatusSettings.allStatuses(statusSettings).forEach((statusType) => {
      statusRegistry.add(statusType);
    });
  }
};

// node_modules/obsidian-task/src/Config/featureConfiguration.json
var featureConfiguration_default = [
  {
    index: 9999,
    internalName: "INTERNAL_TESTING_ENABLED_BY_DEFAULT",
    displayName: "Test Item. Used to validate the Feature Framework.",
    description: "Description",
    enabledByDefault: true,
    stable: false
  }
];

// node_modules/obsidian-task/src/Config/Feature.ts
var Feature = class {
  constructor(internalName, index, description, displayName, enabledByDefault, stable) {
    this.internalName = internalName;
    this.index = index;
    this.description = description;
    this.displayName = displayName;
    this.enabledByDefault = enabledByDefault;
    this.stable = stable;
  }
  /**
   * Returns the list of all available features.
   *
   * @readonly
   * @static
   * @type {Feature[]}
   * @memberof Feature
   */
  static get values() {
    let availableFeatures = [];
    featureConfiguration_default.forEach((feature) => {
      availableFeatures = [
        ...availableFeatures,
        new Feature(
          feature.internalName,
          feature.index,
          feature.description,
          feature.displayName,
          feature.enabledByDefault,
          feature.stable
        )
      ];
    });
    return availableFeatures;
  }
  /**
   * Returns the enabled state of the feature.
   *
   * @readonly
   * @static
   * @type {FeatureFlag}
   * @memberof Feature
   */
  static get settingsFlags() {
    const featureFlags = {};
    Feature.values.forEach((feature) => {
      featureFlags[feature.internalName] = feature.enabledByDefault;
    });
    return featureFlags;
  }
  /**
   * Converts a name to its corresponding default Feature instance.
   *
   * @param name the name to convert to Feature
   * @throws RangeError, if a string that has no corresponding Feature value was passed.
   * @returns the matching Feature
   */
  static fromString(name) {
    for (const feature of Feature.values) {
      if (name === feature.internalName) {
        return feature;
      }
    }
    throw new RangeError(
      `Illegal argument passed to fromString(): ${name} does not correspond to any available Feature ${this.prototype.constructor.name}`
    );
  }
};

// node_modules/obsidian-task/src/Config/Settings.ts
var TASK_FORMATS = {
  tasksPluginEmoji: {
    displayName: "Tasks Emoji Format",
    taskSerializer: new DefaultTaskSerializer(DEFAULT_SYMBOLS),
    buildSuggestions: makeDefaultSuggestionBuilder(DEFAULT_SYMBOLS, DEFAULT_MAX_GENERIC_SUGGESTIONS, false)
  },
  dataview: {
    displayName: "Dataview",
    taskSerializer: new DataviewTaskSerializer(),
    buildSuggestions: onlySuggestIfBracketOpen(
      makeDefaultSuggestionBuilder(DATAVIEW_SYMBOLS, DEFAULT_MAX_GENERIC_SUGGESTIONS, true),
      [
        ["(", ")"],
        ["[", "]"]
      ]
    )
  }
};
var defaultSettings = {
  globalQuery: "",
  globalFilter: "",
  removeGlobalFilter: false,
  taskFormat: "tasksPluginEmoji",
  setCreatedDate: false,
  setDoneDate: true,
  setCancelledDate: true,
  autoSuggestInEditor: true,
  autoSuggestMinMatch: 0,
  autoSuggestMaxItems: 6,
  provideAccessKeys: true,
  useFilenameAsScheduledDate: false,
  filenameAsDateFolders: [],
  recurrenceOnNextLine: false,
  statusSettings: new StatusSettings(),
  features: Feature.settingsFlags,
  generalSettings: {
    /* Prevent duplicate values in user settings for now,
       at least until I start porting the pre-1.23.0 settings
       code to be generated from settingsConfiguration.json.
     */
    // globalFilter: '',
    // removeGlobalFilter: false,
    // setDoneDate: true,
  },
  headingOpened: {},
  debugSettings: new DebugSettings(),
  /*
  `loggingOptions` is a property in the `Settings` interface that defines the logging options for
  the application. It is an object that contains a `minLevels` property, which is a map of logger
  names to their minimum logging levels. This allows the application to control the amount of
  logging output based on the logger name and the minimum logging level. For example, the logger
  name `tasks` might have a minimum logging level of `debug`, while the root logger might have a
  minimum logging level of `info`.
  */
  loggingOptions: {
    minLevels: {
      "": "info",
      tasks: "info",
      "tasks.Cache": "info",
      // Cache.ts
      "tasks.Events": "info",
      // TasksEvents.ts
      "tasks.File": "info",
      // File.ts
      "tasks.Query": "info",
      // Query.ts & QueryRenderer.ts
      "tasks.Task": "info"
      // Task.ts
    }
  }
};
var settings = { ...defaultSettings };
function addNewOptionsToUserSettings(defaultValues, userValues) {
  for (const flag in defaultValues) {
    if (userValues[flag] === void 0) {
      userValues[flag] = defaultValues[flag];
    }
  }
}
var getSettings = () => {
  addNewOptionsToUserSettings(Feature.settingsFlags, settings.features);
  addNewOptionsToUserSettings(defaultSettings.loggingOptions.minLevels, settings.loggingOptions.minLevels);
  settings.statusSettings.customStatuses.forEach((s, index, array) => {
    const newType = Status.getTypeFromStatusTypeString(s.type);
    array[index] = new StatusConfiguration(
      s.symbol ?? " ",
      s.name,
      s.nextStatusSymbol ?? "x",
      s.availableAsCommand,
      newType
    );
  });
  return { ...settings };
};
function getUserSelectedTaskFormat() {
  return TASK_FORMATS[getSettings().taskFormat];
}

// node_modules/obsidian-task/src/lib/HTMLCharacterEntities.ts
function htmlEncodeCharacter(character) {
  const charactersToEntityNames = {
    "<": "&lt;",
    ">": "&gt;",
    "&": "&amp;",
    '"': "&quot;"
  };
  const candidateEntityName = charactersToEntityNames[character];
  if (candidateEntityName !== void 0) {
    return candidateEntityName;
  }
  return character;
}
function htmlEncodeString(characters) {
  const chars = [...characters];
  let result = "";
  chars.forEach((c) => {
    result += htmlEncodeCharacter(c);
  });
  return result;
}

// node_modules/obsidian-task/src/Statuses/StatusRegistry.ts
var _StatusRegistry = class {
  _registeredStatuses = [];
  /**
   * Creates an instance of Status and registers it for use. It will also check to see
   * if the default todo and done are registered and if not handle it internally.
   *
   * Code in the plugin should use {@link getInstance} to use and modify the global
   * StatusRegistry.
   *
   * @memberof StatusRegistry
   */
  constructor() {
    this.addDefaultStatusTypes();
  }
  /**
   * Reset this instance to contain only the given status list, in the supplied order.
   *
   * Duplicate status symbols are ignored.
   * @param statuses
   */
  set(statuses) {
    this.clearStatuses();
    statuses.forEach((status) => {
      this.add(status);
    });
  }
  /**
   * Returns all the registered statuses minus the empty status.
   *
   * @readonly
   * @type {Status[]}
   * @memberof StatusRegistry
   */
  get registeredStatuses() {
    return this._registeredStatuses.filter(({ symbol }) => symbol !== Status.EMPTY.symbol);
  }
  /**
   * The static method that controls the access to the StatusRegistry instance.
   *
   * @static
   * @return {*}  {StatusRegistry}
   * @memberof StatusRegistry
   */
  static getInstance() {
    if (!_StatusRegistry.instance) {
      _StatusRegistry.instance = new _StatusRegistry();
    }
    return _StatusRegistry.instance;
  }
  /**
   * Adds a new Status to the registry if not already registered.
   *
   * @param {StatusConfiguration | Status} status
   * @memberof StatusRegistry
   */
  add(status) {
    if (!this.hasSymbol(status.symbol)) {
      if (status instanceof Status) {
        this._registeredStatuses.push(status);
      } else {
        this._registeredStatuses.push(new Status(status));
      }
    }
  }
  /**
   * Returns the registered status by the symbol between the
   * square braces in the markdown task.
   * Returns an EMPTY status if symbol is unknown.
   *
   * @see bySymbolOrCreate
   *
   * @param {string} symbol
   * @return {*}  {Status}
   * @memberof StatusRegistry
   */
  bySymbol(symbol) {
    if (this.hasSymbol(symbol)) {
      return this.getSymbol(symbol);
    }
    return Status.EMPTY;
  }
  /**
   * Returns the registered status by the symbol between the
   * square braces in the markdown task.
   *
   * Creates a usable new Status with this given symbol if symbol is unknown.
   * Note: An unknown symbol is not added to the registry.
   *
   * @see hasSymbol
   *
   * @param {string} symbol
   * @return {*}  {Status}
   * @memberof StatusRegistry
   */
  bySymbolOrCreate(symbol) {
    if (this.hasSymbol(symbol)) {
      return this.getSymbol(symbol);
    }
    return Status.createUnknownStatus(symbol);
  }
  /**
   * Returns the registered status by the name assigned by the user.
   *
   * @param {string} nameToFind
   * @return {*}  {Status}
   * @memberof StatusRegistry
   */
  byName(nameToFind) {
    if (this._registeredStatuses.filter(({ name }) => name === nameToFind).length > 0) {
      return this._registeredStatuses.filter(({ name }) => name === nameToFind)[0];
    }
    return Status.EMPTY;
  }
  /**
   * Resets the array of Status types to the default statuses.
   *
   * @memberof StatusRegistry
   */
  resetToDefaultStatuses() {
    this.clearStatuses();
    this.addDefaultStatusTypes();
  }
  /**
   * Clears the array of Status types to be empty.
   */
  clearStatuses() {
    this._registeredStatuses = [];
  }
  /**
   * To allow custom progression of task status each status knows
   * which status can come after it as a state transition.
   *
   * @return {*}  {Status}
   * @memberof StatusRegistry
   * @see getNextStatusOrCreate
   */
  getNextStatus(status) {
    if (status.nextStatusSymbol !== "") {
      const nextStatus = this.bySymbol(status.nextStatusSymbol);
      if (nextStatus !== null) {
        return nextStatus;
      }
    }
    return Status.EMPTY;
  }
  /**
   * Return the next status if it exists, and if not, create a new
   * TODO status using the requested next symbol.
   *
   * @return {*}  {Status}
   * @memberof StatusRegistry
   * @see getNextStatus
   */
  getNextStatusOrCreate(status) {
    const nextStatus = this.getNextStatus(status);
    if (nextStatus.type !== "EMPTY" /* EMPTY */) {
      return nextStatus;
    }
    return Status.createUnknownStatus(status.nextStatusSymbol);
  }
  /**
   * Return the status to use for a recurring task that has just been completed.
   *
   * If the next status is not TODO:
   *   - it first advances through the next statuses until it finds a {@link StatusType.TODO} status - which it returns
   *   - or it then advances through the next statuses until it finds an {@link StatusType.IN_PROGRESS} status - which it returns
   *   - otherwise, it uses the status with symbol 'space', which is the default 'TODO' status.
   *
   * @param newStatus - the new status of the task that has just been toggled, which
   *                    is expected to be of type {@link StatusType.DONE}, but this is not checked.
   */
  getNextRecurrenceStatusOrCreate(newStatus) {
    const nextStatus = this.getNextStatusOrCreate(newStatus);
    const result1 = this.getNextRecurrenceStatusOfType(nextStatus, "TODO" /* TODO */);
    if (result1) {
      return result1;
    }
    const result2 = this.getNextRecurrenceStatusOfType(nextStatus, "IN_PROGRESS" /* IN_PROGRESS */);
    if (result2) {
      return result2;
    }
    return this.bySymbolOrCreate(" ");
  }
  getNextRecurrenceStatusOfType(nextStatus, wanted) {
    if (nextStatus.type === wanted) {
      return nextStatus;
    }
    let searchStatus = nextStatus;
    for (let i = 0; i < this.registeredStatuses.length - 1; i++) {
      searchStatus = this.getNextStatusOrCreate(searchStatus);
      if (searchStatus.type === wanted) {
        return searchStatus;
      }
    }
    return void 0;
  }
  /**
   * Find any statuses in the given list that are not known to this registry.
   * This can be used to add all unknown status types to the settings,
   * to save users from having to do that manually.
   *
   * Statuses are returned in the order that they are first found in the
   * supplied list.
   * @param allStatuses
   */
  findUnknownStatuses(allStatuses) {
    const unknownStatuses = allStatuses.filter((s) => {
      return !this.hasSymbol(s.symbol);
    });
    const newStatusRegistry = new _StatusRegistry();
    const namedUniqueStatuses = [];
    unknownStatuses.forEach((s) => {
      if (newStatusRegistry.hasSymbol(s.symbol)) {
        return;
      }
      const newStatus = _StatusRegistry.copyStatusWithNewName(s, `Unknown (${s.symbol})`);
      namedUniqueStatuses.push(newStatus);
      newStatusRegistry.add(newStatus);
    });
    return namedUniqueStatuses.sort((status1, status2) => {
      return status1.symbol.localeCompare(status2.symbol, void 0, { numeric: true });
    });
  }
  static copyStatusWithNewName(s, newName) {
    const statusConfiguration = new StatusConfiguration(
      s.symbol,
      newName,
      s.nextStatusSymbol,
      s.availableAsCommand,
      s.type
    );
    return new Status(statusConfiguration);
  }
  /**
   * Filters the Status types by the symbol and returns the first one found.
   *
   * @private
   * @param {string} symbolToFind
   * @return {*}  {Status}
   * @memberof StatusRegistry
   */
  getSymbol(symbolToFind) {
    return this._registeredStatuses.filter(({ symbol }) => symbol === symbolToFind)[0];
  }
  /**
   * Filters all the Status types by the symbol and returns true if found.
   *
   * @private
   * @param {string} symbolToFind
   * @return {*}  {boolean}
   * @memberof StatusRegistry
   */
  hasSymbol(symbolToFind) {
    return this._registeredStatuses.find((element) => {
      return element.symbol === symbolToFind;
    }) !== void 0;
  }
  /**
   * Checks the registry and adds the default status types.
   *
   * @private
   * @memberof StatusRegistry
   */
  addDefaultStatusTypes() {
    const defaultStatuses = [Status.makeTodo(), Status.makeInProgress(), Status.makeDone(), Status.makeCancelled()];
    defaultStatuses.forEach((status) => {
      this.add(status);
    });
  }
  /**
   * Create a Mermaid diagram from the statuses in this registry.
   *
   * The text can be pasted in to an Obsidian note to visualise the transitions between
   * statuses.
   *
   * Note: Any of the 'next status symbols' that are not in the registry are ignored, and invisible.
   *
   * @param {boolean} includeDetails - whether to include the status symbols and types in the diagram. Defaults to false.
   */
  mermaidDiagram(includeDetails = false) {
    const uniqueStatuses = this.registeredStatuses;
    const language = "mermaid";
    const nodes = [];
    const edges = [];
    uniqueStatuses.forEach((status, index) => {
      const label = this.getMermaidNodeLabel(status, includeDetails);
      nodes.push(`${index + 1}${label}`);
      const nextStatus = this.getNextStatus(status);
      this.addEdgeIfNotToInternal(uniqueStatuses, nextStatus, edges, index, false);
      if (status.type === "DONE" /* DONE */) {
        const nextRecurringStatus = this.getNextRecurrenceStatusOrCreate(status);
        const nextRecurringTypeDiffers = nextRecurringStatus.symbol !== nextStatus.symbol;
        if (nextRecurringTypeDiffers) {
          this.addEdgeIfNotToInternal(uniqueStatuses, nextRecurringStatus, edges, index, true);
        }
      }
    });
    return `
\`\`\`${language}
flowchart LR

classDef TODO        stroke:#f33,stroke-width:3px;
classDef DONE        stroke:#0c0,stroke-width:3px;
classDef IN_PROGRESS stroke:#fa0,stroke-width:3px;
classDef CANCELLED   stroke:#ddd,stroke-width:3px;
classDef NON_TASK    stroke:#99e,stroke-width:3px;

${nodes.join("\n")}
${edges.join("\n")}

linkStyle default stroke:gray
\`\`\`
`;
  }
  addEdgeIfNotToInternal(uniqueStatuses, nextStatus, edges, index, isForReccurenceOverride) {
    const nextStatusIndex = uniqueStatuses.findIndex((status) => status.symbol === nextStatus.symbol);
    const nextStatusIsKnown = nextStatusIndex !== -1;
    const nextStatusIsNotInternal = nextStatus.type !== "EMPTY" /* EMPTY */;
    if (nextStatusIsKnown && nextStatusIsNotInternal) {
      let joiner;
      if (isForReccurenceOverride) {
        joiner = '-. "\u{1F501}" .-> ';
      } else {
        joiner = " --> ";
      }
      const line = `${index + 1}${joiner}${nextStatusIndex + 1}`;
      edges.push(line);
    }
  }
  getMermaidNodeLabel(status, includeDetails) {
    const statusName = htmlEncodeString(status.name);
    const statusType = status.type;
    if (includeDetails) {
      const statusSymbol = htmlEncodeCharacter(status.symbol);
      const statusNextStatusSymbol = htmlEncodeCharacter(status.nextStatusSymbol);
      const transitionText = `[${statusSymbol}] -> [${statusNextStatusSymbol}]`;
      const statusNameText = `'${statusName}'`;
      const statusTypeText = `(${statusType})`;
      return `["${statusNameText}<br>${transitionText}<br>${statusTypeText}"]:::${statusType}`;
    } else {
      return `["${statusName}"]:::${statusType}`;
    }
  }
};
var StatusRegistry = _StatusRegistry;
__publicField(StatusRegistry, "instance");

// node_modules/obsidian-task/src/Scripting/TasksDate.ts
var import_obsidian7 = require("obsidian");

// node_modules/obsidian-task/src/lib/PropertyCategory.ts
var PropertyCategory = class {
  name;
  sortOrder;
  /**
   * Constructor
   *
   * @param name The name of the category. This is typically the text that will be displayed in a group heading.
   * @param sortOrder A numeric sort order for this heading. Lower numbers are displayed before higher ones.
   */
  // Pass in an empty name if you want groupText to be ''
  constructor(name, sortOrder) {
    this.name = name;
    this.sortOrder = sortOrder;
  }
  /**
   * Return the group heading for this category.
   *
   * It prefixes the name with a comment that will ensure the groups sort in the desired order.
   *
   * This works because the commented-out sortOrder will be hidden when Obsidian
   * renders the group heading.
   */
  get groupText() {
    if (this.name !== "") {
      return `%%${this.sortOrder}%% ${this.name}`;
    } else {
      return "";
    }
  }
};

// node_modules/obsidian-task/src/Scripting/TasksDate.ts
var TasksDate = class {
  _date = null;
  constructor(date) {
    this._date = date;
  }
  /**
   * Return the raw underlying moment (or null, if there is no date)
   */
  get moment() {
    return this._date;
  }
  /**
   * Return the date formatted as YYYY-MM-DD, or {@link fallBackText} if there is no date.
   @param fallBackText - the string to use if the date is null. Defaults to empty string.
   */
  formatAsDate(fallBackText = "") {
    return this.format(TaskRegularExpressions.dateFormat, fallBackText);
  }
  /**
   * Return the date formatted as YYYY-MM-DD HH:mm, or {@link fallBackText} if there is no date.
   @param fallBackText - the string to use if the date is null. Defaults to empty string.
   */
  formatAsDateAndTime(fallBackText = "") {
    return this.format(TaskRegularExpressions.dateTimeFormat, fallBackText);
  }
  /**
   * Return the date formatted with the given format string, or {@link fallBackText} if there is no date.
   * See https://momentjs.com/docs/#/displaying/ for all the available formatting options.
   * @param format
   * @param fallBackText - the string to use if the date is null. Defaults to empty string.
   */
  format(format, fallBackText = "") {
    return this._date ? this._date.format(format) : fallBackText;
  }
  /**
   * Return the date as an ISO string, for example '2023-10-13T00:00:00.000Z'.
   * @param keepOffset
   * @returns - The date as an ISO string, for example: '2023-10-13T00:00:00.000Z',
   *            OR an empty string if no date, OR null for an invalid date.
   */
  toISOString(keepOffset) {
    return this._date ? this._date.toISOString(keepOffset) : "";
  }
  get category() {
    const today = window.moment();
    const date = this.moment;
    if (!date) {
      return new PropertyCategory("Undated", 4);
    }
    if (date.isBefore(today, "day")) {
      return new PropertyCategory("Overdue", 1);
    }
    if (date.isSame(today, "day")) {
      return new PropertyCategory("Today", 2);
    }
    if (!date.isValid()) {
      return new PropertyCategory("Invalid date", 0);
    }
    return new PropertyCategory("Future", 3);
  }
  get fromNow() {
    const date = this.moment;
    if (!date) {
      return new PropertyCategory("", 0);
    }
    const order2 = this.fromNowOrder(date);
    return new PropertyCategory(date.fromNow(), order2);
  }
  fromNowOrder(date) {
    if (!date.isValid()) {
      return 0;
    }
    const now = window.moment();
    const earlier = date.isSameOrBefore(now, "day");
    const startDateOfThisGroup = this.fromNowStartDateOfGroup(date, earlier, now);
    const splitPastAndFutureDates = earlier ? 1 : 3;
    return Number(splitPastAndFutureDates + startDateOfThisGroup.format("YYYYMMDD"));
  }
  fromNowStartDateOfGroup(date, earlier, now) {
    const words = date.fromNow(true).split(" ");
    let multiplier;
    const word0AsNumber = Number(words[0]);
    if (isNaN(word0AsNumber)) {
      multiplier = 1;
    } else {
      multiplier = word0AsNumber;
    }
    const unit = words[1];
    return earlier ? now.subtract(multiplier, unit) : now.add(multiplier, unit);
  }
  postpone(unitOfTime = "days", amount = 1) {
    if (!this._date)
      throw new import_obsidian7.Notice("Cannot postpone a null date");
    const today = window.moment().startOf("day");
    const isDateBeforeToday = !this._date.isSameOrAfter(today, "day");
    if (isDateBeforeToday) {
      return today.add(amount, unitOfTime);
    }
    return this._date.clone().add(amount, unitOfTime);
  }
};

// node_modules/obsidian-task/src/Scripting/TasksFile.ts
var TasksFile = class {
  _path;
  constructor(path) {
    this._path = path;
  }
  /**
   * Return the path to the file.
   */
  get path() {
    return this._path;
  }
  /**
   * Return the path to the file, with the filename extension removed.
   */
  get pathWithoutExtension() {
    return this.withoutExtension(this.path);
  }
  withoutExtension(value) {
    return value.replace(/\.md$/, "");
  }
  /**
   * Return the root to the file.
   */
  get root() {
    let path = this.path.replace(/\\/g, "/");
    if (path.charAt(0) === "/") {
      path = path.substring(1);
    }
    const separatorIndex = path.indexOf("/");
    if (separatorIndex == -1) {
      return "/";
    }
    return path.substring(0, separatorIndex + 1);
  }
  get folder() {
    const path = this.path;
    const fileNameWithExtension = this.filename;
    const folder = path.substring(0, path.lastIndexOf(fileNameWithExtension));
    if (folder === "") {
      return "/";
    }
    return folder;
  }
  /**
   * Return the filename including the extension.
   */
  get filename() {
    const fileNameMatch = this.path.match(/([^/]+)$/);
    if (fileNameMatch !== null) {
      return fileNameMatch[1];
    } else {
      return "";
    }
  }
  get filenameWithoutExtension() {
    return this.withoutExtension(this.filename);
  }
};

// node_modules/obsidian-task/src/lib/PriorityTools.ts
var PriorityTools = class {
  /**
   * Get the name of a {@link Priority} value, returning 'None' for {@link Priority.None}
   * @param priority
   * @see priorityNameUsingNormal
   */
  static priorityNameUsingNone(priority) {
    let priorityName = "ERROR";
    switch (priority) {
      case "1" /* High */:
        priorityName = "High";
        break;
      case "0" /* Highest */:
        priorityName = "Highest";
        break;
      case "2" /* Medium */:
        priorityName = "Medium";
        break;
      case "3" /* None */:
        priorityName = "None";
        break;
      case "4" /* Low */:
        priorityName = "Low";
        break;
      case "5" /* Lowest */:
        priorityName = "Lowest";
        break;
    }
    return priorityName;
  }
  /**
   * Get the name of a {@link Priority} value, returning 'Normal' for {@link Priority.None}
   * @param priority
   * @see priorityNameUsingNone
   */
  static priorityNameUsingNormal(priority) {
    return PriorityTools.priorityNameUsingNone(priority).replace("None", "Normal");
  }
};

// node_modules/obsidian-task/src/lib/logging.ts
var import_obsidian8 = require("obsidian");
var import_eventemitter2 = __toESM(require_eventemitter2());
var LogManager = class extends import_eventemitter2.EventEmitter2 {
  options = {
    minLevels: {
      "": "info",
      tasks: "info"
    }
  };
  // Prevent the console logger from being added twice
  consoleLoggerRegistered = false;
  /**
   * Set the minimum log levels for the module name or global.
   *
   * @param {LogOptions} options
   * @return {*}  {LogManager}
   * @memberof LogManager
   */
  configure(options) {
    this.options = Object.assign({}, this.options, options);
    return this;
  }
  /**
   * Returns a logger instance for the given module name.
   *
   * @param {string} module
   * @return {*}  {Logger}
   * @memberof LogManager
   */
  getLogger(module2) {
    let minLevel = "none";
    let match = "";
    for (const key in this.options.minLevels) {
      if (module2.startsWith(key) && key.length >= match.length) {
        minLevel = this.options.minLevels[key];
        match = key;
      }
    }
    return new Logger(this, module2, minLevel);
  }
  /**
   *
   *
   * @param {(logEntry: LogEntry) => void} listener
   * @return {*}  {LogManager}
   * @memberof LogManager
   */
  onLogEntry(listener) {
    this.on("log", listener);
    return this;
  }
  // private period: number = 0;
  arrAvg = (arr) => arr.reduce((a, b) => a + b, 0) / arr.length;
  /**
   * Registers a logger that write to the console.
   *
   * @return {*}  {LogManager}
   * @memberof LogManager
   */
  registerConsoleLogger() {
    if (this.consoleLoggerRegistered)
      return this;
    this.onLogEntry((logEntry) => {
      let msg = `[${window.moment().format("YYYY-MM-DD-HH:mm:ss.SSS")}][${logEntry.level}][${logEntry.module}]`;
      if (logEntry.traceId) {
        msg += `[${logEntry.traceId}]`;
      }
      msg += ` ${logEntry.message}`;
      if (logEntry.objects === void 0) {
        logEntry.objects = "";
      }
      switch (logEntry.level) {
        case "trace":
          console.trace(msg, logEntry.objects);
          break;
        case "debug":
          console.debug(msg, logEntry.objects);
          break;
        case "info":
          console.info(msg, logEntry.objects);
          break;
        case "warn":
          console.warn(msg, logEntry.objects);
          break;
        case "error":
          console.error(msg, logEntry.objects);
          break;
        default:
          console.log(`{${logEntry.level}} ${msg}`, logEntry.objects);
      }
    });
    this.consoleLoggerRegistered = true;
    return this;
  }
};
var logging = new LogManager();
var Logger = class {
  logManager;
  minLevel;
  module;
  levels = {
    trace: 1,
    debug: 2,
    info: 3,
    warn: 4,
    error: 5
  };
  /**
   * Creates an instance of Logger.
   * @param {EventEmitter2} logManager
   * @param {string} module
   * @param {string} minLevel
   * @memberof Logger
   */
  constructor(logManager, module2, minLevel) {
    this.logManager = logManager;
    this.module = module2;
    this.minLevel = this.levelToInt(minLevel);
  }
  /**
   * Converts a string level (trace/debug/info/warn/error) into a number
   *
   * @param minLevel
   */
  levelToInt(minLevel) {
    if (minLevel.toLowerCase() in this.levels)
      return this.levels[minLevel.toLowerCase()];
    else
      return 99;
  }
  /**
   * Central logging method.
   * @param logLevel
   * @param message
   */
  log(logLevel, message, objects) {
    const level = this.levelToInt(logLevel);
    if (level < this.minLevel)
      return;
    const logEntry = {
      level: logLevel,
      module: this.module,
      message,
      objects,
      traceId: void 0
    };
    this.logManager.emit("log", logEntry);
  }
  trace(message, objects) {
    this.log("trace", message, objects);
  }
  debug(message, objects) {
    this.log("debug", message, objects);
  }
  info(message, objects) {
    this.log("info", message, objects);
  }
  warn(message, objects) {
    this.log("warn", message, objects);
  }
  error(message, objects) {
    this.log("error", message, objects);
  }
  /**
   * Central logging method with a trace ID to track calls between modules/components.
   * @param logLevel
   * @param message
   */
  logWithId(logLevel, traceId, message, objects) {
    const level = this.levelToInt(logLevel);
    if (level < this.minLevel)
      return;
    const logEntry = {
      level: logLevel,
      module: this.module,
      message,
      objects,
      traceId
    };
    this.logManager.emit("log", logEntry);
  }
  traceWithId(traceId, message, objects) {
    this.logWithId("trace", traceId, message, objects);
  }
  debugWithId(traceId, message, objects) {
    this.logWithId("debug", traceId, message, objects);
  }
  infoWithId(traceId, message, objects) {
    this.logWithId("info", traceId, message, objects);
  }
  warnWithId(traceId, message, objects) {
    this.logWithId("warn", traceId, message, objects);
  }
  errorWithId(traceId, message, objects) {
    this.logWithId("error", traceId, message, objects);
  }
};

// node_modules/obsidian-task/src/lib/LogTasksHelper.ts
function logStartOfTaskEdit(logger, codeLocation, originalTask) {
  logger.debug(
    `${codeLocation}: task line number: ${originalTask.taskLocation.lineNumber}. file path: "${originalTask.path}"`
  );
  logger.debug(`${codeLocation} original: ${originalTask.originalMarkdown}`);
}
function logEndOfTaskEdit(logger, codeLocation, newTasks) {
  newTasks.map((task, index) => {
    logger.debug(`${codeLocation} ==> ${index + 1}   : ${task.toFileLineString()}`);
  });
}

// node_modules/obsidian-task/src/Task/DateFallback.ts
var DateFallback = class {
  /**
   * Attempt to parse the filename to extract a date taking user settings into account. If date inference is not
   * enabled parsing is bypassed and null is returned.
   * @param path the full path of the file
   * @return a Moment or null if no date was found.
   */
  static fromPath(path) {
    const { useFilenameAsScheduledDate, filenameAsDateFolders } = getSettings();
    if (!useFilenameAsScheduledDate) {
      return null;
    }
    if (!this.matchesAnyFolder(filenameAsDateFolders, path)) {
      return null;
    }
    return this.extractDateFromPath(path);
  }
  static matchesAnyFolder(folders, path) {
    if (folders.length === 0) {
      return true;
    }
    return folders.some((folder) => path.startsWith(folder + "/"));
  }
  static extractDateFromPath(path) {
    const firstPos = Math.max(0, path.lastIndexOf("/") + 1);
    const lastPos = path.lastIndexOf(".");
    const basename = path.substring(firstPos, lastPos);
    let dateMatch = /(\d{4})-(\d{2})-(\d{2})/.exec(basename);
    if (!dateMatch)
      dateMatch = /(\d{4})(\d{2})(\d{2})/.exec(basename);
    if (dateMatch) {
      const date = window.moment([parseInt(dateMatch[1]), parseInt(dateMatch[2]) - 1, parseInt(dateMatch[3])]);
      if (date.isValid()) {
        return date;
      }
    }
    return null;
  }
  /**
   * Return true iff a fallback can be set
   **/
  static canApplyFallback({
    startDate,
    scheduledDate,
    dueDate
  }) {
    return startDate === null && dueDate === null && scheduledDate === null;
  }
  /**
   * Implement the logic to update the fields related to date fallback of a task when its file has moved
   * @param task         - task to update
   * @param newPath      - new location
   * @param fallbackDate - fallback date from new location, for efficiency. Can be null
   */
  static updateTaskPath(task, newPath, fallbackDate) {
    let scheduledDate = task.scheduledDate;
    let scheduledDateIsInferred = task.scheduledDateIsInferred;
    if (fallbackDate === null) {
      if (scheduledDateIsInferred) {
        scheduledDateIsInferred = false;
        scheduledDate = null;
      } else {
      }
    } else {
      if (scheduledDateIsInferred) {
        scheduledDate = fallbackDate;
      } else if (this.canApplyFallback(task)) {
        scheduledDate = fallbackDate;
        scheduledDateIsInferred = true;
      } else {
      }
    }
    return new Task({
      ...task,
      taskLocation: task.taskLocation.fromRenamedFile(newPath),
      scheduledDate,
      scheduledDateIsInferred
    });
  }
  /**
   * Update an array of updated tasks to remove the inferred scheduled date status if the scheduled date has been
   * modified as compared to the original date
   */
  static removeInferredStatusIfNeeded(originalTask, updatedTasks) {
    const inferredScheduledDate = originalTask.scheduledDateIsInferred ? originalTask.scheduledDate : null;
    return updatedTasks.map((task) => {
      if (inferredScheduledDate !== null && !inferredScheduledDate.isSame(task.scheduledDate, "day")) {
        task = new Task({ ...task, scheduledDateIsInferred: false });
      }
      return task;
    });
  }
};

// node_modules/obsidian-task/src/Task/Urgency.ts
var _Urgency = class {
  static calculate(task) {
    let urgency = 0;
    if (task.dueDate?.isValid()) {
      const startOfToday = window.moment().startOf("day");
      const daysOverdue = Math.round(startOfToday.diff(task.dueDate) / _Urgency.milliSecondsPerDay);
      let dueMultiplier;
      if (daysOverdue >= 7) {
        dueMultiplier = 1;
      } else if (daysOverdue >= -14) {
        dueMultiplier = (daysOverdue + 14) * 0.8 / 21 + 0.2;
      } else {
        dueMultiplier = 0.2;
      }
      urgency += dueMultiplier * _Urgency.dueCoefficient;
    }
    if (task.scheduledDate?.isValid()) {
      if (window.moment().isSameOrAfter(task.scheduledDate)) {
        urgency += 1 * _Urgency.scheduledCoefficient;
      }
    }
    if (task.startDate?.isValid()) {
      if (window.moment().isBefore(task.startDate)) {
        urgency += 1 * _Urgency.startedCoefficient;
      }
    }
    switch (task.priority) {
      case "0":
        urgency += 1.5 * _Urgency.priorityCoefficient;
        break;
      case "1":
        urgency += 1 * _Urgency.priorityCoefficient;
        break;
      case "2":
        urgency += 0.65 * _Urgency.priorityCoefficient;
        break;
      case "3":
        urgency += 0.325 * _Urgency.priorityCoefficient;
        break;
      case "5":
        urgency -= 0.3 * _Urgency.priorityCoefficient;
        break;
    }
    return urgency;
  }
};
var Urgency = _Urgency;
__publicField(Urgency, "dueCoefficient", 12);
__publicField(Urgency, "scheduledCoefficient", 5);
__publicField(Urgency, "startedCoefficient", -3);
__publicField(Urgency, "priorityCoefficient", 6);
__publicField(Urgency, "milliSecondsPerDay", 1e3 * 60 * 60 * 24);

// node_modules/obsidian-task/src/Task/Task.ts
var Task = class {
  // NEW_TASK_FIELD_EDIT_REQUIRED
  status;
  description;
  indentation;
  listMarker;
  taskLocation;
  tags;
  priority;
  createdDate;
  startDate;
  scheduledDate;
  dueDate;
  doneDate;
  cancelledDate;
  recurrence;
  dependsOn;
  id;
  /** The blockLink is a "^" annotation after the dates/recurrence rules.
   * Any non-empty value must begin with ' ^'. */
  blockLink;
  /** The original line read from file.
   *
   * Will be empty if Task was created programmatically
   * (for example, by Create or Edit Task, or in tests, including via {@link TaskBuilder}). */
  originalMarkdown;
  scheduledDateIsInferred;
  _urgency = null;
  constructor({
    // NEW_TASK_FIELD_EDIT_REQUIRED
    status,
    description,
    taskLocation,
    indentation,
    listMarker,
    priority,
    createdDate,
    startDate,
    scheduledDate,
    dueDate,
    doneDate,
    cancelledDate,
    recurrence,
    dependsOn,
    id,
    blockLink,
    tags,
    originalMarkdown,
    scheduledDateIsInferred
  }) {
    this.status = status;
    this.description = description;
    this.indentation = indentation;
    this.listMarker = listMarker;
    this.taskLocation = taskLocation;
    this.tags = tags;
    this.priority = priority;
    this.createdDate = createdDate;
    this.startDate = startDate;
    this.scheduledDate = scheduledDate;
    this.dueDate = dueDate;
    this.doneDate = doneDate;
    this.cancelledDate = cancelledDate;
    this.recurrence = recurrence;
    this.dependsOn = dependsOn;
    this.id = id;
    this.blockLink = blockLink;
    this.originalMarkdown = originalMarkdown;
    this.scheduledDateIsInferred = scheduledDateIsInferred;
  }
  /**
   * Takes the given line from an Obsidian note and returns a Task object.
   * Will check if Global Filter is present in the line.
   *
   * @static
   * @param {string} line - The full line in the note to parse.
   * @param {TaskLocation} taskLocation - The location of the task line
   * @param {(Moment | null)} fallbackDate - The date to use as the scheduled date if no other date is set
   * @return {*}  {(Task | null)}
   * @memberof Task
   * @see parseTaskSignifiers
   */
  static fromLine({
    line,
    taskLocation,
    fallbackDate
  }) {
    const taskComponents = Task.extractTaskComponents(line);
    if (taskComponents === null) {
      return null;
    }
    if (!GlobalFilter.getInstance().includedIn(taskComponents.body)) {
      return null;
    }
    return Task.parseTaskSignifiers(line, taskLocation, fallbackDate);
  }
  /**
   * Parses the line in attempt to get the task details.
   *
   * This reads the task even if the Global Filter is missing.
   * If a Global Filter check is needed, use {@link Task.fromLine}.
   *
   * Task is returned regardless if Global Filter is present or not.
   * However, if it is, it will be removed from the tags.
   *
   * @param line - the full line to parse
   * @param taskLocation - The location of the task line
   * @param fallbackDate - The date to use as the scheduled date if no other date is set
   * @returns {*} {(Task | null)}
   * @see fromLine
   */
  static parseTaskSignifiers(line, taskLocation, fallbackDate) {
    const taskComponents = Task.extractTaskComponents(line);
    if (taskComponents === null) {
      return null;
    }
    const { taskSerializer } = getUserSelectedTaskFormat();
    const taskInfo = taskSerializer.deserialize(taskComponents.body);
    let scheduledDateIsInferred = false;
    if (DateFallback.canApplyFallback(taskInfo) && fallbackDate !== null) {
      taskInfo.scheduledDate = fallbackDate;
      scheduledDateIsInferred = true;
    }
    taskInfo.tags = taskInfo.tags.map((tag) => tag.trim());
    taskInfo.tags = taskInfo.tags.filter((tag) => !GlobalFilter.getInstance().equals(tag));
    return new Task({
      ...taskComponents,
      ...taskInfo,
      taskLocation,
      originalMarkdown: line,
      scheduledDateIsInferred
    });
  }
  /**
   * Extract the component parts of the task line.
   * @param line
   * @returns a {@link TaskComponents} object containing the component parts of the task line
   */
  static extractTaskComponents(line) {
    const regexMatch = line.match(TaskRegularExpressions.taskRegex);
    if (regexMatch === null) {
      return null;
    }
    const indentation = regexMatch[1];
    const listMarker = regexMatch[2];
    const statusString = regexMatch[3];
    const status = StatusRegistry.getInstance().bySymbolOrCreate(statusString);
    let body = regexMatch[4].trim();
    const blockLinkMatch = body.match(TaskRegularExpressions.blockLinkRegex);
    const blockLink = blockLinkMatch !== null ? blockLinkMatch[0] : "";
    if (blockLink !== "") {
      body = body.replace(TaskRegularExpressions.blockLinkRegex, "").trim();
    }
    return { indentation, listMarker, status, body, blockLink };
  }
  /**
   * Flatten the task as a string that includes all its components.
   *
   * @note Output depends on {@link Settings.taskFormat}
   * @return {*}  {string}
   * @memberof Task
   */
  toString() {
    return getUserSelectedTaskFormat().taskSerializer.serialize(this);
  }
  /**
   * Returns the Task as a list item with a checkbox.
   *
   * @note Output depends on {@link Settings.taskFormat}
   * @return {*}  {string}
   * @memberof Task
   */
  toFileLineString() {
    return `${this.indentation}${this.listMarker} [${this.status.symbol}] ${this.toString()}`;
  }
  /**
   * Toggles this task and returns the resulting task(s).
   *
   * Use this method if you need to know which is the original (completed)
   * task and which is the new recurrence.
   *
   * If the task is not recurring, it will return `[toggled]`.
   *
   * Toggling can result in more than one returned task in the case of
   * recurrence. In this case, the toggled task will be returned
   * together with the next occurrence in the order `[next, toggled]`.
   *
   * There is a possibility to use user set order `[next, toggled]`
   * or `[toggled, next]` - {@link toggleWithRecurrenceInUsersOrder}.
   *
   */
  toggle() {
    const logger = logging.getLogger("tasks.Task");
    const codeLocation = "toggle()";
    logStartOfTaskEdit(logger, codeLocation, this);
    const newStatus = StatusRegistry.getInstance().getNextStatusOrCreate(this.status);
    const newTasks = this.handleNewStatus(newStatus);
    logEndOfTaskEdit(logger, codeLocation, newTasks);
    return newTasks;
  }
  handleNewStatus(newStatus) {
    if (newStatus.identicalTo(this.status)) {
      return [this];
    }
    const { setDoneDate } = getSettings();
    const newDoneDate = this.newDate(newStatus, "DONE" /* DONE */, this.doneDate, setDoneDate);
    const { setCancelledDate } = getSettings();
    const newCancelledDate = this.newDate(newStatus, "CANCELLED" /* CANCELLED */, this.cancelledDate, setCancelledDate);
    let nextOccurrence = null;
    if (newStatus.isCompleted()) {
      if (!this.status.isCompleted() && this.recurrence !== null) {
        nextOccurrence = this.recurrence.next();
      }
    }
    const toggledTask = new Task({
      ...this,
      status: newStatus,
      doneDate: newDoneDate,
      cancelledDate: newCancelledDate
    });
    const newTasks = [];
    if (nextOccurrence !== null) {
      const nextTask = this.createNextOccurrence(newStatus, nextOccurrence);
      newTasks.push(nextTask);
    }
    newTasks.push(toggledTask);
    return newTasks;
  }
  /**
   * Returns the new value to use for a date that tracks progress on tasks upon transition to a different
   * {@link StatusType}.
   *
   * Currently, this is used to calculate the new Done Date or Cancelled Date,
   */
  newDate(newStatus, statusType, oldDate, dateEnabledInSettings) {
    let newDate = null;
    if (newStatus.type === statusType) {
      if (this.status.type !== statusType) {
        if (dateEnabledInSettings) {
          newDate = window.moment();
        }
      } else {
        newDate = oldDate;
      }
    }
    return newDate;
  }
  createNextOccurrence(newStatus, nextOccurrence) {
    const { setCreatedDate } = getSettings();
    let createdDate = null;
    if (setCreatedDate) {
      createdDate = window.moment();
    }
    const cancelledDate = null;
    const statusRegistry = StatusRegistry.getInstance();
    const nextStatus = statusRegistry.getNextRecurrenceStatusOrCreate(newStatus);
    return new Task({
      ...this,
      ...nextOccurrence,
      status: nextStatus,
      // New occurrences cannot have the same block link.
      // And random block links don't help.
      blockLink: "",
      // New occurrences also cannot have the same dependency fields. See #2654.
      id: "",
      dependsOn: [],
      // add new createdDate on recurring tasks
      createdDate,
      cancelledDate
    });
  }
  /**
   * Toggles this task and returns the resulting task(s).
   *
   * Use this method if the updated task(s) are to be saved,
   * as this honours the user setting to control the order
   * the tasks should be saved in.
   *
   * If the task is not recurring, it will return `[toggled]`.
   *
   * Toggling can result in more than one returned task in the case of
   * recurrence. In this case, the toggled task will be returned in
   * user set order `[next, toggled]` or `[toggled, next]` depending
   * on {@link Settings}.
   *
   * If there is no need to consider user settings call {@link toggle}.
   *
   */
  toggleWithRecurrenceInUsersOrder() {
    const newTasks = this.toggle();
    return this.putRecurrenceInUsersOrder(newTasks);
  }
  handleNewStatusWithRecurrenceInUsersOrder(newStatus) {
    const logger = logging.getLogger("tasks.Task");
    logger.debug(
      `changed task ${this.taskLocation.path} ${this.taskLocation.lineNumber} ${this.originalMarkdown} status to '${newStatus.symbol}'`
    );
    const newTasks = this.handleNewStatus(newStatus);
    return this.putRecurrenceInUsersOrder(newTasks);
  }
  putRecurrenceInUsersOrder(newTasks) {
    const { recurrenceOnNextLine } = getSettings();
    return recurrenceOnNextLine ? newTasks.reverse() : newTasks;
  }
  /**
   * Return whether the task is considered done.
   * @returns true if the status type is {@link StatusType.DONE}, {@link StatusType.CANCELLED} or {@link StatusType.NON_TASK}, and false otherwise.
   */
  get isDone() {
    return this.status.type === "DONE" /* DONE */ || this.status.type === "CANCELLED" /* CANCELLED */ || this.status.type === "NON_TASK" /* NON_TASK */;
  }
  /**
   * A task is treated as blocked if it depends on any existing task ids on tasks that are TODO or IN_PROGRESS.
   *
   * 'Done' tasks (with status DONE, CANCELLED or NON_TASK) are never blocked.
   * Only direct dependencies are considered.
   * @param allTasks - all the tasks in the vault. In custom queries, this is available via query.allTasks.
   */
  isBlocked(allTasks) {
    if (this.dependsOn.length === 0) {
      return false;
    }
    if (this.isDone) {
      return false;
    }
    for (const depId of this.dependsOn) {
      const depTask = allTasks.find((task) => task.id === depId && !task.isDone);
      if (!depTask) {
        continue;
      }
      return true;
    }
    return false;
  }
  /**
   * A Task is blocking if there is any other not-done task dependsOn value with its id.
   *
   * 'Done' tasks (with status DONE, CANCELLED or NON_TASK) are never blocking.
   * Only direct dependencies are considered.
   * @param allTasks - all the tasks in the vault. In custom queries, this is available via query.allTasks.
   */
  isBlocking(allTasks) {
    if (this.id === "") {
      return false;
    }
    if (this.isDone) {
      return false;
    }
    return allTasks.some((task) => {
      if (task.isDone) {
        return false;
      }
      return task.dependsOn.includes(this.id);
    });
  }
  /**
   * Return the number of the Task's priority.
   *     - Highest = 0
   *     - High = 1
   *     - Medium = 2
   *     - None = 3
   *     - Low = 4
   *     - Lowest = 5
   * @see priorityName
   */
  get priorityNumber() {
    return Number.parseInt(this.priority);
  }
  /**
   * Returns the text to be used to represent the {@link priority} in group headings.
   *
   * Hidden text is used to sort the priorities in decreasing order, from
   * {@link Priority.Highest} to {@link Priority.Lowest}.
   */
  get priorityNameGroupText() {
    const priorityName = PriorityTools.priorityNameUsingNormal(this.priority);
    return `%%${this.priority}%%${priorityName} priority`;
  }
  /**
   * Return a copy of the description, with any tags removed.
   *
   * Note that this removes tags recognised by Tasks (including removing #123, for example),
   * as opposed to tags recognised by Obsidian, which does not treat numbers-only as valid tags.
   */
  get descriptionWithoutTags() {
    return this.description.replace(TaskRegularExpressions.hashTags, "").trim();
  }
  /**
   * Return the name of the Task's priority.
   *
   * Note that the default priority is called 'Normal', not 'None'.
   @see priorityNumber
   */
  get priorityName() {
    return PriorityTools.priorityNameUsingNormal(this.priority);
  }
  get urgency() {
    if (this._urgency === null) {
      this._urgency = Urgency.calculate(this);
    }
    return this._urgency;
  }
  get path() {
    return this.taskLocation.path;
  }
  /**
   * Return {@link cancelledDate} as a {@link TasksDate}, so the field names in scripting docs are consistent with the existing search instruction names, and null values are easy to deal with.
   */
  get cancelled() {
    return new TasksDate(this.cancelledDate);
  }
  /**
   * Return {@link createdDate} as a {@link TasksDate}, so the field names in scripting docs are consistent with the existing search instruction names, and null values are easy to deal with.
   */
  get created() {
    return new TasksDate(this.createdDate);
  }
  /**
   * Return {@link doneDate} as a {@link TasksDate}, so the field names in scripting docs are consistent with the existing search instruction names, and null values are easy to deal with.
   */
  get done() {
    return new TasksDate(this.doneDate);
  }
  /**
   * Return {@link dueDate} as a {@link TasksDate}, so the field names in scripting docs are consistent with the existing search instruction names, and null values are easy to deal with.
   */
  get due() {
    return new TasksDate(this.dueDate);
  }
  /**
   * Return {@link scheduledDate} as a {@link TasksDate}, so the field names in scripting docs are consistent with the existing search instruction names, and null values are easy to deal with.
   */
  get scheduled() {
    return new TasksDate(this.scheduledDate);
  }
  /**
   * Return {@link startDate} as a {@link TasksDate}, so the field names in scripting docs are consistent with the existing search instruction names, and null values are easy to deal with.
   */
  get start() {
    return new TasksDate(this.startDate);
  }
  /**
   * Return the date fields that contribute to 'happens' searches.
   *
   * @see happens
   * @see {@link HappensDateField}
   */
  get happensDates() {
    return Array.of(this.startDate, this.scheduledDate, this.dueDate);
  }
  /**
   * Return the earliest of the dates used by 'happens' in this given task as a {@link TasksDate}.
   *
   * Generally speaking, the earliest date is considered to be the highest priority,
   * as it is the first point at which the user might wish to act on the task.
   *
   * Invalid dates are ignored.
   *
   * @see happensDates
   * @see {@link HappensDateField}
   */
  get happens() {
    const happensDates = this.happensDates;
    const sortedHappensDates = Array.from(happensDates).sort(compareByDate);
    for (const date of sortedHappensDates) {
      if (date?.isValid()) {
        return new TasksDate(date);
      }
    }
    return new TasksDate(null);
  }
  /**
   * Return true if the Task has a valid recurrence rule, and false otherwise,
   * that is, false if it does not have a recurrence rule, or the recurrence rule is invalid.
   */
  get isRecurring() {
    return this.recurrence !== null;
  }
  /**
   * Return the text of the Task's recurrence rule, if it is supplied and is valid,
   * and an empty string otherwise.
   */
  get recurrenceRule() {
    return this.recurrence ? this.recurrence.toText() : "";
  }
  get heading() {
    return this.precedingHeader;
  }
  get hasHeading() {
    return this.precedingHeader !== null;
  }
  get file() {
    return new TasksFile(this.path);
  }
  /**
   * Return the name of the file containing the task, with the .md extension removed.
   */
  get filename() {
    const fileNameMatch = this.path.match(/([^/]+)\.md$/);
    if (fileNameMatch !== null) {
      return fileNameMatch[1];
    } else {
      return null;
    }
  }
  get lineNumber() {
    return this.taskLocation.lineNumber;
  }
  get sectionStart() {
    return this.taskLocation.sectionStart;
  }
  get sectionIndex() {
    return this.taskLocation.sectionIndex;
  }
  get precedingHeader() {
    return this.taskLocation.precedingHeader;
  }
  /**
   * Returns the text that should be displayed to the user when linking to the origin of the task
   *
   * @param isFilenameUnique {boolean|null} Whether the name of the file that contains the task is unique in the vault.
   *                                        If it is undefined, the outcome will be the same as with a unique file name: the file name only.
   *                                        If set to `true`, the full path will be returned.
   */
  getLinkText({ isFilenameUnique }) {
    let linkText;
    if (isFilenameUnique) {
      linkText = this.filename;
    } else {
      linkText = "/" + this.path;
    }
    if (linkText === null) {
      return null;
    }
    if (this.precedingHeader !== null && this.precedingHeader !== linkText) {
      linkText = linkText + " > " + this.precedingHeader;
    }
    return linkText;
  }
  /**
   * Compare two lists of Task objects, and report whether their
   * tasks are identical in the same order.
   *
   * This can be useful for optimising code if it is guaranteed that
   * there are no possible differences in the tasks in a file
   * after an edit, for example.
   *
   * If any field is different in any task, it will return false.
   *
   * @param oldTasks
   * @param newTasks
   */
  static tasksListsIdentical(oldTasks, newTasks) {
    if (oldTasks.length !== newTasks.length) {
      return false;
    }
    return oldTasks.every((oldTask, index) => oldTask.identicalTo(newTasks[index]));
  }
  /**
   * Compare all the fields in another Task, to detect any differences from this one.
   *
   * If any field is different in any way, it will return false.
   *
   * This is used in some optimisations, to avoid work if an edit to file
   * does not change any tasks, so it is vital that its definition
   * of identical is very strict.
   *
   * @param other
   */
  identicalTo(other) {
    let args = [
      "description",
      "path",
      "indentation",
      "listMarker",
      "lineNumber",
      "sectionStart",
      "sectionIndex",
      "precedingHeader",
      "priority",
      "blockLink",
      "scheduledDateIsInferred",
      "id",
      "dependsOn"
    ];
    for (const el of args) {
      if (this[el]?.toString() !== other[el]?.toString())
        return false;
    }
    if (!this.status.identicalTo(other.status)) {
      return false;
    }
    if (this.tags.length !== other.tags.length) {
      return false;
    }
    if (!this.tags.every(function(element, index) {
      return element === other.tags[index];
    })) {
      return false;
    }
    args = Task.allDateFields();
    for (const el of args) {
      const date1 = this[el];
      const date2 = other[el];
      if (compareByDate(date1, date2) !== 0) {
        return false;
      }
    }
    const recurrence1 = this.recurrence;
    const recurrence2 = other.recurrence;
    if (recurrence1 === null && recurrence2 !== null) {
      return false;
    } else if (recurrence1 !== null && recurrence2 === null) {
      return false;
    } else if (recurrence1 && recurrence2 && !recurrence1.identicalTo(recurrence2)) {
      return false;
    }
    return true;
  }
  static allDateFields() {
    return [
      "createdDate",
      "startDate",
      "scheduledDate",
      "dueDate",
      "doneDate",
      "cancelledDate"
    ];
  }
  /**
   * Returns an array of hashtags found in string
   *
   * @param description A task description that may contain hashtags
   *
   * @returns An array of hashTags found in the string
   */
  static extractHashtags(description) {
    return description.match(TaskRegularExpressions.hashTags)?.map((tag) => tag.trim()) ?? [];
  }
};

// node_modules/obsidian-task/src/Task/TaskLocation.ts
var TaskLocation = class {
  _path;
  _lineNumber;
  _sectionStart;
  _sectionIndex;
  _precedingHeader;
  constructor(path, lineNumber, sectionStart, sectionIndex, precedingHeader) {
    this._path = path;
    this._lineNumber = lineNumber;
    this._sectionStart = sectionStart;
    this._sectionIndex = sectionIndex;
    this._precedingHeader = precedingHeader;
  }
  /**
   * Constructor, for use when the Task's exact location in a file is either unknown, or not needed.
   * @param path
   */
  static fromUnknownPosition(path) {
    return new TaskLocation(path, 0, 0, 0, null);
  }
  /**
   * Constructor, for when the file has been renamed, and all other data remains the same.
   * @param newPath
   */
  fromRenamedFile(newPath) {
    return new TaskLocation(newPath, this.lineNumber, this.sectionStart, this.sectionIndex, this.precedingHeader);
  }
  get path() {
    return this._path;
  }
  get lineNumber() {
    return this._lineNumber;
  }
  /** Line number where the section starts that contains this task. */
  get sectionStart() {
    return this._sectionStart;
  }
  /** The index of the nth task in its section. */
  get sectionIndex() {
    return this._sectionIndex;
  }
  get precedingHeader() {
    return this._precedingHeader;
  }
};

// src/taskParser.ts
var prioritySymbols = {
  Highest: "\u{1F53A}",
  High: "\u23EB",
  Medium: "\u{1F53C}",
  Low: "\u{1F53D}",
  Lowest: "\u23EC",
  None: ""
};
var keywords = {
  TickTick_TAG: "#ticktick",
  DUE_DATE: "\u23F3|\u{1F5D3}\uFE0F|\u{1F4C5}|\u{1F4C6}|\u{1F5D3}",
  TIME: "\u231A",
  TASK_DUE_DATE: "\u{1F4C5}",
  TASK_COMPLETE: "\u2705",
  ALL_TASK_EMOJI: "\u2795|\u23F3|\u{1F6EB}|\u{1F4C5}|\u2705|\u274C",
  // priorityIcons: "⏬|🔽|🔼|⏫|🔺",
  // priority: `\s([${priorityEmojis.toString()}])\s`
  priority: `\\s([\u23EC\u{1F53D}\u{1F53C}\u23EB\u{1F53A}])\\s`
};
var priorityMapping = [{ ticktick: 0, obsidian: null }, { ticktick: 0, obsidian: "\u23EC" }, {
  ticktick: 1,
  obsidian: "\u{1F53D}"
}, { ticktick: 3, obsidian: "\u{1F53C}" }, { ticktick: 5, obsidian: "\u23EB" }, { ticktick: 5, obsidian: "\u{1F53A}" }];
var tag_regex = /(?<=\s)#[\w\d\u4e00-\u9fff\u0600-\u06ff\uac00-\ud7af-_/]+/g;
var due_date_regex = `(${keywords.DUE_DATE})\\s(\\d{4}-\\d{2}-\\d{2})\\s*(\\d{1,}:\\d{2})*`;
var due_date_strip_regex = `[${keywords.DUE_DATE}]\\s\\d{4}-\\d{2}-\\d{2}(\\s\\d{1,}:\\d{2}|)`;
var completion_date_regex = `(${keywords.TASK_COMPLETE})\\s(\\d{4}-\\d{2}-\\d{2})\\s*(\\d{1,}:\\d{2})*`;
var completion_date_strip_regex = `${keywords.TASK_COMPLETE}\\s\\d{4}-\\d{2}-\\d{2}(\\s*\\d{1,}:\\d{2}|)`;
var status_regex = "^\\s*(-|\\*)\\s+\\[(x| )\\]\\s";
var REGEX = {
  //hopefully tighter find.
  //TickTick_TAG: new RegExp(`(?<=[ ;])\\s${keywords.TickTick_TAG}+`, 'i'),
  TickTick_TAG: new RegExp(`^[\\s]*[-] \\[[x ]\\] [\\s\\S]*${keywords.TickTick_TAG}[\\s\\S]*$`, "i"),
  TickTick_ID: /\[ticktick_id::\s*[\d\S]+\]/,
  TickTick_ID_NUM: /\[ticktick_id::\s*(.*?)\]/,
  TickTick_ID_DV_NUM: /ticktick_id(.*?)%/,
  TickTick_LINK: /\[link\]\(.*?\)/,
  DUE_DATE_WITH_EMOJ: new RegExp(`(${keywords.DUE_DATE})\\s?\\d{4}-\\d{2}-\\d{2}`),
  // DUE_DATE : new RegExp(`(?:${keywords.DUE_DATE})\\s?(\\d{4}-\\d{2}-\\d{2})`),
  DUE_DATE: new RegExp(due_date_regex, "gmu"),
  COMPLETION_DATE: new RegExp(completion_date_regex, "gmu"),
  PROJECT_NAME: /\[project::\s*(.*?)\]/,
  TASK_CONTENT: {
    REMOVE_PRIORITY: /[🔺⏫🔼🔽⏬]/ug,
    //accommodate UTF-16 languages.
    REMOVE_TAGS: tag_regex,
    REMOVE_SPACE: /^\s+|\s+$/g,
    REMOVE_DATE: new RegExp(due_date_strip_regex, "gmu"),
    REMOVE_COMPLETION_DATE: new RegExp(completion_date_strip_regex, "gmu"),
    REMOVE_INLINE_METADATA: /%%\[\w+::\s*\w+\]%%/,
    REMOVE_CHECKBOX: /^(-|\*)\s+\[(x|X| )\]\s/,
    REMOVE_CHECKBOX_WITH_INDENTATION: /^([ \t]*)?(-|\*)\s+\[(x|X| )\]\s/,
    REMOVE_TickTick_LINK: /\[link\]\(.*?\)/
  },
  //todo: this and remove_tags are redundant. Probably some of the other stuff to. Rationalize this lot.
  ALL_TAGS: tag_regex,
  TASK_CHECKBOX_CHECKED: /- \[(x|X)\] /,
  TASK_INDENTATION: /^(\s{2,}|\t)(-|\*)\s+\[(x|X| )\]/,
  TAB_INDENTATION: /^(\t+)/,
  // TASK_PRIORITY: /\s!!([1-4])\s/,
  TASK_PRIORITY: new RegExp(keywords.priority),
  priorityRegex: /^.*([🔺⏫🔼🔽⏬]).*$/u,
  BLANK_LINE: /^\s*$/,
  TickTick_EVENT_DATE: /(\d{4})-(\d{2})-(\d{2})/,
  ITEM_LINE: /\[(.*?)\]\s*(.*?)\s*%%(.*?)%%/,
  REMOVE_ITEM_ID: /\s%%[^\[](.*?)[^\]]%%/g
};
var TaskParser = class {
  app;
  plugin;
  constructor(app2, plugin) {
    this.app = app2;
    this.plugin = plugin;
  }
  //convert a task object to a task line.
  async convertTaskToLine(task) {
    let resultLine = "";
    task.title = this.stripOBSUrl(task.title);
    resultLine = `- [${task.status > 0 ? "x" : " "}] ${task.title}`;
    if (task.tags) {
      resultLine = this.addTagsToLine(resultLine, task.tags);
    }
    resultLine = this.addTickTickTag(resultLine);
    resultLine = this.addTickTickLink(resultLine, task.id, task.projectId);
    resultLine = this.addTickTickId(resultLine, task.id);
    resultLine = this.addPriorityToLine(resultLine, task);
    if (task.dueDate) {
      resultLine = this.addDueDateToLine(resultLine, task);
    }
    if (task.items && task.items.length > 0) {
      resultLine = this.addItems(resultLine, task.items);
    }
    return resultLine;
  }
  stripOBSUrl(title) {
    let result = title;
    if (result) {
      let eoURL = title.lastIndexOf(".md)");
      let boURL = 0;
      if (eoURL > 0) {
        for (let i = eoURL; i > 0; i--) {
          if (title[i] === "[") {
            boURL = i;
            break;
          }
        }
        if (boURL > 0) {
          result = title.substring(0, boURL);
          result = result + title.substring(eoURL + 4);
        }
      }
    }
    return result.trim();
  }
  getTaskContentFromLineText(lineText) {
    let TaskContent = lineText.replace(REGEX.TASK_CONTENT.REMOVE_INLINE_METADATA, "").replace(REGEX.TASK_CONTENT.REMOVE_TickTick_LINK, "").replace(REGEX.TASK_CONTENT.REMOVE_PRIORITY, "").replace(REGEX.TASK_CONTENT.REMOVE_TAGS, "").replace(REGEX.TASK_CONTENT.REMOVE_DATE, "").replace(REGEX.TASK_CONTENT.REMOVE_COMPLETION_DATE, "").replace(REGEX.TASK_CONTENT.REMOVE_CHECKBOX, "").replace(REGEX.TASK_CONTENT.REMOVE_CHECKBOX_WITH_INDENTATION, "").replace(REGEX.TASK_CONTENT.REMOVE_SPACE, "");
    TaskContent = this.stripOBSUrl(TaskContent);
    return TaskContent;
  }
  stripLineItemId(lineText) {
    let line = lineText.replace(REGEX.REMOVE_ITEM_ID, "");
    return line;
  }
  addTagsToLine(resultLine, tags) {
    const regEx = new RegExp(keywords.TickTick_TAG.substring(1), "i");
    tags.forEach((tag) => {
      if (!tag.match(regEx)) {
        if (tag.includes("-")) {
          tag = tag.replace(/-/g, "/");
        }
        resultLine = resultLine + " #" + tag;
      }
    });
    return resultLine;
  }
  //convert line text to a task object
  async convertLineToTask(lineText, filepath, lineNumber, fileContent) {
    let hasParent = false;
    let parentId = null;
    let parentTaskObject = null;
    let taskItems = [];
    const lines = fileContent.split("\n");
    const lineTextTabIndentation = this.getTabIndentation(lineText);
    let textWithoutIndentation = this.removeTaskIndentation(lineText);
    const TickTick_id = this.getTickTickIdFromLineText(textWithoutIndentation);
    if (lineTextTabIndentation > 0) {
      for (let i = lineNumber - 1; i >= 0; i--) {
        const line = lines[i];
        if (this.isLineBlank(line)) {
          break;
        }
        if (this.getTabIndentation(line) >= lineTextTabIndentation) {
          continue;
        }
        if (this.getTabIndentation(line) < lineTextTabIndentation) {
          if (this.hasTickTickId(line)) {
            parentId = this.getTickTickIdFromLineText(line);
            hasParent = true;
            parentTaskObject = await this.plugin.cacheOperation?.loadTaskFromCacheID(parentId);
            break;
          } else {
            break;
          }
        }
      }
    }
    if (!this.plugin.settings.enableFullVaultSync) {
      for (let i = lineNumber + 1; i <= lines.length; i++) {
        const line = lines[i];
        if (this.isLineBlank(line)) {
          break;
        }
        if (this.getTabIndentation(line) > lineTextTabIndentation) {
          if (this.hasTickTickId(line)) {
            break;
          }
          const item = this.getItemFromLine(line);
          taskItems.push(item);
        } else {
          break;
        }
      }
    }
    let dueDateStruct = this.getDueDateFromLineText(textWithoutIndentation);
    let timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const tags = this.getAllTagsFromLineText(textWithoutIndentation);
    let projectId = await this.plugin.cacheOperation?.getDefaultProjectIdForFilepath(filepath);
    let projectName = await this.plugin.cacheOperation?.getProjectNameByIdFromCache(projectId);
    if (hasParent) {
      if (parentTaskObject) {
        projectId = parentTaskObject.projectId;
        projectName = await this.plugin.cacheOperation?.getProjectNameByIdFromCache(projectId);
      }
    } else {
      if (tags) {
        for (const tag of tags) {
          let labelName = tag.replace(/#/g, "");
          let hasProjectId = await this.plugin.cacheOperation?.getProjectIdByNameFromCache(labelName);
          if (!hasProjectId) {
            continue;
          }
          projectName = labelName;
          projectId = hasProjectId;
          break;
        }
      }
    }
    const title = this.getTaskContentFromLineText(textWithoutIndentation);
    if (this.plugin.settings.debugMode && !projectId) {
      console.error("Converting line to Object, could not find project Id: ", title);
    }
    const isCompleted = this.isTaskCheckboxChecked(textWithoutIndentation);
    let description = "";
    const priority = this.getTaskPriority(textWithoutIndentation);
    if (filepath) {
      let taskURL = this.plugin.taskParser?.getObsidianUrlFromFilepath(filepath);
      if (taskURL) {
        description = taskURL;
      }
    }
    const task = {
      id: TickTick_id || "",
      projectId,
      title: title.trim() + " " + description,
      //content: ??
      // content: description,
      items: taskItems || [],
      parentId: parentId || "",
      //TickTick, will use the start date for due date, and eff up the date displayed.
      //emulate what they do on the web interface and send null for due date.
      dueDate: dueDateStruct.returnDate || "",
      startDate: dueDateStruct.returnDate || "",
      isAllDay: dueDateStruct.isAllDay,
      tags: tags || [],
      priority: Number(priority),
      modifiedTime: this.formatDateToISO(new Date()),
      status: isCompleted ? 2 : 0,
      //Status: 0 is no completed. Anything else is completed.
      timeZone
    };
    return task;
  }
  hasTickTickTag(text) {
    if (this.isMarkdownTask(text)) {
      return REGEX.TickTick_TAG.test(text);
    } else {
      return false;
    }
  }
  hasTickTickId(text) {
    let result = REGEX.TickTick_ID.test(text);
    if (!result) {
      result = REGEX.TickTick_ID_DV_NUM.test(text);
    }
    return result;
  }
  addTickTickId(line, ticktick_id) {
    line = `${line} %%[ticktick_id:: ${ticktick_id}]%%`;
    return line;
  }
  addChildToParent(parentTask, childId) {
    if (!parentTask.childIds) {
      parentTask.childIds = [];
    }
    parentTask.childIds.push(childId);
    return parentTask;
  }
  hasDueDate(text) {
    return REGEX.DUE_DATE_WITH_EMOJ.test(text);
  }
  getDueDateFromLineText(text) {
    let isAllDay = true;
    const regEx = REGEX.DUE_DATE;
    let results = [...text.matchAll(regEx)];
    if (results.length == 0) {
      const nullDate = "";
      const nullVal = "";
      return { isAllDay, nullDate, nullVal };
    }
    let result;
    if (results.length > 1) {
      result = results[results.length - 1];
    } else {
      result = results[0];
    }
    let returnDate = null;
    if (result) {
      if (!result[3]) {
        returnDate = `${result[2]}T00:00:00.000`;
        isAllDay = true;
      } else {
        if (result[3].includes("24:")) {
          result[3] = result[3].replace("24:", "00:");
        }
        returnDate = `${result[2]}T${result[3]}`;
        isAllDay = false;
      }
      returnDate = this.formatDateToISO(new Date(returnDate));
    }
    const emoji = result[1];
    return { isAllDay, returnDate, emoji };
  }
  getProjectNameFromLineText(text) {
    const result = REGEX.PROJECT_NAME.exec(text);
    return result ? result[1] : null;
  }
  getTickTickIdFromLineText(text) {
    let result = REGEX.TickTick_ID_NUM.exec(text);
    if (!result) {
      result = REGEX.TickTick_ID_DV_NUM.exec(text);
    }
    return result ? result[1] : null;
  }
  isTaskOpen(line) {
    let result = new RegExp(status_regex, "gmi").exec(line);
    if (result) {
      return result[2].search(/[xX]/) < 0;
    } else {
      throw new Error(`Status not found in line: ${line}`);
    }
  }
  utcToLocal(utcDateString, bIsAllDay) {
    const date = new Date(utcDateString);
    const locale = "en-US";
    const hostTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const localDate = date.toLocaleString(locale, { timeZone: hostTimeZone });
    const [datePart, timePart] = localDate.split(", ");
    let [month, day, year] = datePart.split("/");
    month = String(month).padStart(2, "0");
    day = String(day).padStart(2, "0");
    let [hours, minutes] = timePart.split(":");
    if (localDate.includes("PM")) {
      hours = (Number(hours) + 12).toString();
    } else if (localDate.includes("AM") && hours === "12") {
      hours = "24";
    }
    hours = String(hours).padStart(2, "0");
    minutes = String(minutes).padStart(2, "0");
    if (!bIsAllDay) {
      return `${year}-${month}-${day} ${hours}:${minutes}`;
    } else {
      return `${year}-${month}-${day}`;
    }
  }
  //get all tags from task text
  getAllTagsFromLineText(lineText) {
    const tags = [...lineText.matchAll(REGEX.ALL_TAGS)];
    let tagArray = tags.map((tag) => tag[0].replace("#", ""));
    tagArray = tagArray.map((tag) => tag.replace(/\//g, "-"));
    tagArray.forEach((tag) => console.log("#### get all tags", tag));
    return tagArray;
  }
  //get checkbox status
  isTaskCheckboxChecked(lineText) {
    return REGEX.TASK_CHECKBOX_CHECKED.test(lineText);
  }
  //task content compare
  isTitleChanged(lineTask, TickTickTask) {
    const lineTaskTitle = this.stripOBSUrl(lineTask.title);
    const TickTickTaskTitle = this.stripOBSUrl(TickTickTask.title);
    const contentModified = lineTaskTitle.trim() === TickTickTaskTitle.trim();
    return !contentModified;
  }
  //tag compare
  isTagsChanged(lineTask, TickTickTask) {
    const lineTaskTags = lineTask.tags ? lineTask.tags : [];
    const TickTickTaskTags = TickTickTask.tags ? TickTickTask.tags : [];
    if (!lineTaskTags && !TickTickTaskTags) {
      return false;
    } else if (lineTaskTags && !TickTickTaskTags || !lineTaskTags && TickTickTaskTags) {
      return true;
    }
    let areTagsSame = lineTaskTags.length === TickTickTaskTags.length && lineTaskTags.sort().every((val, index) => val === TickTickTaskTags.sort()[index]);
    return !areTagsSame;
  }
  //task status compare
  isStatusChanged(lineTask, TickTickTask) {
    const statusModified = lineTask.status === TickTickTask.status;
    return !statusModified;
  }
  isParentIdChanged(lineTask, TickTickTask) {
    let lineParentId = lineTask.parentId ? lineTask.parentId : "";
    let cacheParentId = TickTickTask.parentId ? TickTickTask.parentId : "";
    return lineParentId != cacheParentId;
  }
  //task due date compare
  isDueDateChanged(lineTask, TickTickTask) {
    const lineTaskDue = lineTask.dueDate;
    const TickTickTaskDue = TickTickTask.dueDate ?? "";
    if (lineTaskDue === "" && TickTickTaskDue === "") {
      return false;
    }
    if ((lineTaskDue || TickTickTaskDue) === "") {
      return true;
    }
    if (lineTaskDue === TickTickTaskDue) {
      return false;
    } else if (lineTaskDue.toString() === "Invalid Date" && TickTickTaskDue.toString() === "Invalid Date") {
      return false;
    } else {
      const date1 = this.cleanDate(lineTaskDue);
      const date2 = this.cleanDate(TickTickTaskDue);
      const date1TZ = date1.getTimezoneOffset();
      const date2TZ = date2.getTimezoneOffset();
      const diff = (date1.getTime() - date2.getTime()) / 36e5;
      const utcDate1 = date1;
      const utcDate2 = date2;
      if (utcDate1.getTime() === utcDate2.getTime()) {
        return false;
      } else {
        if (this.plugin.settings.debugMode) {
          const timeDifferenceInMilliseconds = Math.abs(utcDate2.getTime() - utcDate1.getTime());
          const days = Math.floor(timeDifferenceInMilliseconds / (1e3 * 60 * 60 * 24));
          const hours = Math.floor(timeDifferenceInMilliseconds % (1e3 * 60 * 60 * 24) / (1e3 * 60 * 60));
          const minutes = Math.floor(timeDifferenceInMilliseconds % (1e3 * 60 * 60) / (1e3 * 60));
          if (days > 0) {
            console.log(`The timestamps are ${days} days, ${hours} hours, and ${minutes} minutes apart.`);
          } else if (hours > 0) {
            console.log(`The timestamps are ${hours} hours and ${minutes} minutes apart.`);
          } else if (minutes > 0) {
            console.log(`The timestamps are ${minutes} minutes apart.`);
          } else {
            console.log(`The timestamps are different, but not calculatable..`);
          }
        }
        return true;
      }
    }
  }
  //task project id compare
  isProjectIdChanged(lineTask, TickTickTask) {
    return !(lineTask.projectId === TickTickTask.projectId);
  }
  //Determine whether the task is indented
  isIndentedTask(text) {
    return REGEX.TASK_INDENTATION.test(text);
  }
  //console.log(getTabIndentation(" - [x] This is a task without tabs")); // 0
  getTabIndentation(lineText) {
    const match = REGEX.TAB_INDENTATION.exec(lineText);
    return match ? match[1].length : 0;
  }
  getTabs(lineText) {
    const numTabs = this.getTabIndentation(lineText);
    let tabs = "";
    for (let i = 0; i < numTabs; i++) {
      tabs = tabs + "	";
    }
    return tabs;
  }
  // Task priority from 0 (none) to 4 (urgent).
  getTaskPriority(lineText) {
    let priority = "0";
    const priorityMatch = lineText.match(REGEX.priorityRegex);
    if (priorityMatch !== null) {
      priority = this.parsePriority(priorityMatch[1]);
    }
    return priority;
  }
  //Determine the number of tab characters
  //console.log(getTabIndentation("\t\t- [x] This is a task with two tabs")); // 2
  //remove task indentation
  removeTaskIndentation(text) {
    const regex = /^([ \t]*)?- \[(x| )\] /;
    return text.replace(regex, "- [$2] ");
  }
  //Judge whether line is a blank line
  isLineBlank(lineText) {
    return REGEX.BLANK_LINE.test(lineText);
  }
  //Format date to TickTick Accepted date.
  formatDateToISO(dateTime) {
    if (isNaN(dateTime.getTime())) {
      return "Invalid Date";
    }
    const tzoffset = dateTime.getTimezoneOffset();
    const convertedDate = new Date(dateTime.getTime());
    const result = convertedDate.toISOString().replace(/Z$/, "+0000");
    return result;
  }
  //TODO fix this.
  oldMarkdownTask(str) {
    const taskRegex = /^\s*-\s+\[([x ])\]/;
    return taskRegex.test(str);
  }
  isMarkdownTask(str) {
    const forRealRegex = TaskRegularExpressions.taskRegex;
    return forRealRegex.test(str);
  }
  addTickTickTag(str) {
    if (str.charAt(str.length - 1) === " ") {
      str = str + `${keywords.TickTick_TAG}`;
    } else {
      str = str + ` ${keywords.TickTick_TAG} `;
    }
    return str;
  }
  getObsidianUrlFromFilepath(filepath) {
    const url = encodeURI(`obsidian://open?vault=${this.app.vault.getName()}&file=${filepath}`);
    const obsidianUrl = `[${filepath}](${url})`;
    return obsidianUrl;
  }
  addTickTickLink(linetext, taskId, projecId) {
    let url = this.createURL(taskId, projecId);
    const regex = new RegExp(`${keywords.TickTick_TAG}`, "gi");
    const link = ` [link](${url})`;
    return linetext.replace(regex, link + " $&");
  }
  //Check whether TickTick link is included
  hasTickTickLink(lineText) {
    return REGEX.TickTick_LINK.test(lineText);
  }
  //ticktick specific url
  createURL(newTaskId, projectId) {
    let url = "";
    if (projectId) {
      url = `https://${this.plugin.settings.baseURL}/webapp/#p/${projectId}/tasks/${newTaskId}`;
    } else {
      url = `https://${this.plugin.settings.baseURL}/webapp/#q/all/tasks/${newTaskId}`;
    }
    return url;
  }
  translateTickTickToObsidian(ticktickPriority) {
    const mapping = priorityMapping.find((item) => item.ticktick === ticktickPriority);
    return mapping ? mapping.obsidian : null;
  }
  translateObsidianToTickTick(obsidianPriority) {
    const mapping = priorityMapping.find((item) => item.obsidian === obsidianPriority);
    return mapping ? mapping.ticktick : null;
  }
  async taskFromLine(line, path) {
    let taskLocation = TaskLocation.fromUnknownPosition(path);
    let task = Task.fromLine({
      line,
      taskLocation: TaskLocation.fromUnknownPosition(path),
      fallbackDate: null
    });
    return task;
  }
  cleanDate(dateString) {
    if (dateString.includes("+-")) {
      dateString = dateString.replace("+-", "-");
      let regex = /(.*)([+-])(\d*)/;
      const matchTime = dateString.match(regex);
      if (matchTime[3].length < 4) {
        dateString = matchTime[1] + "-0" + matchTime[3];
      }
    }
    const cleanedDate = new Date(dateString);
    return cleanedDate;
  }
  parsePriority(p) {
    switch (p) {
      case prioritySymbols.Lowest:
        return "0" /* Lowest */;
      case prioritySymbols.Low:
        return "1" /* Low */;
      case prioritySymbols.Medium:
        return "3" /* Medium */;
      case prioritySymbols.High:
        return "5" /* High */;
      case prioritySymbols.Highest:
        return "5" /* Highest */;
      default:
        return "0" /* None */;
    }
  }
  addItems(resultLine, items) {
    items.forEach((item) => {
      let completion = item.status > 0 ? "- [x]" : "- [ ]";
      if (!this.plugin.settings.enableFullVaultSync) {
        resultLine = `${resultLine} 
${completion} ${item.title} %%${item.id}%%`;
      } else {
        resultLine = `${resultLine} 
${completion} ${item.title}`;
      }
    });
    return resultLine;
  }
  getItemFromLine(itemLine) {
    const matches = REGEX.ITEM_LINE.exec(itemLine);
    let item = {};
    if (matches) {
      const status = matches[1];
      const text = matches[2];
      const id = matches[3];
      const itemStatus = " " ? 0 : 2;
      item = {
        id,
        title: text,
        status: itemStatus
      };
    }
    return item;
  }
  addPriorityToLine(resultLine, task) {
    let priority = this.translateTickTickToObsidian(task.priority);
    if (priority != null) {
      resultLine = `${resultLine} ${priority}`;
    }
    return resultLine;
  }
  addCompletionDate(line, completedTime) {
    if (completedTime) {
      const completionTime = this.utcToLocal(completedTime, true);
      line = line + ` ${keywords.TASK_COMPLETE} ` + completionTime;
      return line;
    } else {
      return line;
    }
  }
  addDueDateToLine(resultLine, task) {
    const dueDate = this.utcToLocal(task.dueDate, task.isAllDay);
    resultLine = resultLine + ` ${keywords.TASK_DUE_DATE} ` + dueDate;
    return resultLine;
  }
  removeMultipleCompletionDates(text, task) {
    const regEx = REGEX.COMPLETION_DATE;
    let results = [...text.matchAll(regEx)];
    if (results.length == 0) {
      const nullDate = "";
      const nullVal = "";
      return text;
    }
    let keepNum;
    if (task.status == 0) {
      keepNum = 0;
    } else {
      keepNum = 1;
    }
    let result;
    if (results.length > keepNum) {
      for (let i = 0; i < results.length; i++) {
        text = text.replace(`${results[i][1]} ${results[i][2]}`, "");
      }
    }
    return text;
  }
  getAllTags() {
  }
};

// src/cacheOperation.ts
var import_obsidian10 = require("obsidian");

// src/modals/FoundDuplicatesModal.ts
var import_obsidian9 = require("obsidian");
var FoundDuplicatesModal = class extends import_obsidian9.Modal {
  title = "Duplicate Projects/Lists found";
  message;
  cancelLabel = "Cancel";
  confirmLabel = "Abort Sync";
  projects = [];
  result;
  onSubmit;
  resolvePromise;
  plugin;
  constructor(app2, plugin, projects, onSubmit) {
    super(app2);
    this.plugin = plugin;
    this.projects = projects;
    this.message = `The following duplicate Projects/Lists were found. On ${plugin.settings.baseURL},please either choose one of those to contain the tasks from both lists, or rename one of the lists.`;
    this.onSubmit = onSubmit;
  }
  /**
   * Called automatically by the Modal class when modal is opened.
   */
  onOpen() {
    const { titleEl, contentEl } = this;
    titleEl.setText(this.title);
    contentEl.createEl("p", { text: `${this.message}` });
    const projectsTable = contentEl.createEl("table", "projects-table");
    const projectsTableHead = projectsTable.createEl("thead");
    const projectsTableHeadRow = projectsTableHead.createEl("tr");
    const projectsTableHeadRowName = projectsTableHeadRow.createEl("th");
    const projectsTableHeadRowName2 = projectsTableHeadRow.createEl("th");
    projectsTableHeadRowName.setText("Project Name");
    projectsTableHeadRowName2.setText("Project ID");
    const projectsTableBody = projectsTable.createEl("tbody");
    this.projects.forEach((project) => {
      const row = projectsTableBody.createEl("tr");
      const projectId = row.createEl("td", "project-table-border");
      const projectName = row.createEl("td", "project-table-border");
      projectId.setText(project.name);
      projectName.setText(project.id);
    });
    new import_obsidian9.Setting(contentEl).addButton((confirmBtn) => {
      confirmBtn.setClass("ts_button");
      confirmBtn.setWarning();
      confirmBtn.setButtonText(this.confirmLabel);
      confirmBtn.onClick(() => {
        this.result = true;
        this.onSubmit(this.result);
        this.close();
      });
    });
  }
  /**
   * Called automatically by the Modal class when modal is closed.
   */
  onClose() {
    this.titleEl.empty();
    this.contentEl.empty();
    super.onClose();
    this.resolvePromise(this.result);
  }
  showModal() {
    this.open();
    return new Promise(
      (resolve) => this.resolvePromise = resolve
    );
  }
};

// src/cacheOperation.ts
var CacheOperation = class {
  app;
  plugin;
  constructor(app2, plugin) {
    this.app = app2;
    this.plugin = plugin;
  }
  async addTaskToMetadata(filepath, task) {
    let metaData = await this.getFileMetadata(filepath, task.projectId);
    let taskMeta;
    taskMeta = { taskId: task.id, taskItems: [] };
    if (task.items && task.items.length > 0) {
      task.items.forEach((item) => {
        taskMeta.taskItems.push(item.id);
      });
    }
    metaData.TickTickTasks.push(taskMeta);
    metaData.TickTickCount = metaData.TickTickTasks.length;
  }
  async addTaskItemToMetadata(filepath, taskId, itemid, projectId) {
    let metaData = await this.getFileMetadata(filepath, projectId);
    const task = metaData.TickTickTasks.find((task2) => task2.taskId === taskId);
    task?.taskItems.push(itemid);
    metaData.TickTickCount = metaData.TickTickTasks.length;
  }
  //This removes an Item from the metadata, and from the task
  //assumes file metadata has been looked up.
  async removeTaskItem(fileMetaData, taskId, taskItemIds) {
    if (fileMetaData) {
      const taskIndex = fileMetaData.TickTickTasks.findIndex((task) => task.taskId === taskId);
      if (taskIndex !== -1) {
        const updatedMetaDataTask = fileMetaData.TickTickTasks[taskIndex];
        let task = await this.loadTaskFromCacheID(taskId);
        if (!task.items) {
          return;
        }
        let taskItems = task.items;
        taskItemIds.forEach((taskItemId) => {
          taskItems = taskItems.filter((item) => item.id !== taskItemId);
        });
        task.items = taskItems;
        task = await this.updateTaskToCacheByID(task);
        return task;
      } else {
        console.warn(`Task '${taskId}' not found in metadata`);
      }
    }
    ;
    return null;
  }
  async getFileMetadata(filepath, projectId) {
    let metaData = this.plugin.settings.fileMetadata[filepath];
    if (!metaData) {
      metaData = await this.newEmptyFileMetadata(filepath, projectId);
    }
    return metaData;
  }
  async getFileMetadatas() {
    return this.plugin.settings.fileMetadata ?? null;
  }
  async newEmptyFileMetadata(filepath, projectId) {
    if (!filepath) {
      console.error("Attempt to create undefined FileMetaData Entry: ", filepath);
      return null;
    }
    const file = this.app.vault.getAbstractFileByPath(filepath);
    if (file instanceof import_obsidian10.TFolder) {
      console.error("Not adding ", filepath, " to Metadata because it's a folder.");
      return null;
    }
    const metadatas = this.plugin.settings.fileMetadata;
    if (metadatas[filepath]) {
      return metadatas[filepath];
    } else {
      metadatas[filepath] = {};
    }
    metadatas[filepath].TickTickTasks = [];
    metadatas[filepath].TickTickCount = 0;
    if (projectId) {
      metadatas[filepath].defaultProjectId = projectId;
    }
    this.plugin.settings.fileMetadata = metadatas;
    this.plugin.saveSettings();
    return this.plugin.settings.fileMetadata[filepath];
  }
  async updateFileMetadata(filepath, newMetadata) {
    const metadatas = this.plugin.settings.fileMetadata;
    if (!metadatas[filepath]) {
      metadatas[filepath] = {};
    }
    metadatas[filepath].TickTickTasks = newMetadata.TickTickTasks;
    metadatas[filepath].TickTickCount = newMetadata.TickTickCount;
    this.plugin.settings.fileMetadata = metadatas;
    this.plugin.saveSettings();
  }
  async deleteTaskIdFromMetadata(filepath, taskId) {
    const metadata = await this.getFileMetadata(filepath, null);
    const oldTickTickTasks = metadata.TickTickTasks;
    const newTickTickTasks = oldTickTickTasks.filter((obj) => obj.taskId !== taskId);
    const newTickTickCount = newTickTickTasks.length;
    metadata.TickTickTasks = newTickTickTasks;
    metadata.TickTickCount = newTickTickCount;
    await this.updateFileMetadata(filepath, metadata);
  }
  async updateTaskMetadata(task, filePath) {
    await this.deleteTaskIdFromMetadataByTaskId(task.id);
    await this.addTaskToMetadata(filePath, task);
  }
  async deleteTaskIdFromMetadataByTaskId(taskId) {
    const metadatas = await this.getFileMetadatas();
    for (var file in metadatas) {
      var tasks = metadatas[file].TickTickTasks;
      var count = metadatas[file].TickTickCount;
      if (tasks && tasks.find((task) => task.taskId === taskId)) {
        await this.deleteTaskIdFromMetadata(file, taskId);
        break;
      }
    }
  }
  //delete filepath from filemetadata
  async deleteFilepathFromMetadata(filepath) {
    const fileMetaData = this.plugin.settings.fileMetadata;
    const newFileMetadata = {};
    for (const filename in fileMetaData) {
      if (filename !== filepath) {
        newFileMetadata[filename] = fileMetaData[filename];
      }
    }
    this.plugin.settings.fileMetadata = newFileMetadata;
    await this.plugin.saveSettings();
    return this.plugin.settings.fileMetadata;
  }
  //Check for duplicates
  checkForDuplicates(fileMetadata) {
    let taskIds = {};
    let duplicates = {};
    if (!fileMetadata) {
      return;
    }
    for (const file in fileMetadata) {
      fileMetadata[file].TickTickTasks.forEach((task) => {
        if (taskIds[task.taskId]) {
          if (!duplicates[task.taskId]) {
            duplicates[task.taskId] = [taskIds[task.taskId]];
          }
          duplicates[task.taskId].push(file);
        } else {
          taskIds[task.taskId] = file;
        }
      });
    }
    return { taskIds, duplicates };
  }
  //Check errors in filemata where the filepath is incorrect.
  async checkFileMetadata() {
    const metadatas = await this.getFileMetadatas();
    for (const key in metadatas) {
      let filepath = key;
      const value = metadatas[key];
      let file = this.app.vault.getAbstractFileByPath(key);
      if (!file && (value.TickTickTasks?.length === 0 || !value.TickTickTasks)) {
        console.error(`${key} does not exist and metadata is empty.`);
        await this.deleteFilepathFromMetadata(key);
        continue;
      }
      if (value.TickTickTasks?.length === 0 || !value.TickTickTasks) {
        continue;
      }
      if (!file) {
        const TickTickId1 = value.TickTickTasks[0];
        const searchResult = await this.plugin.fileOperation.searchFilepathsByTaskidInVault(TickTickId1);
        await this.updateRenamedFilePath(filepath, searchResult);
        await this.plugin.saveSettings();
      }
    }
    return Object.keys(metadatas).length;
  }
  async getDefaultProjectNameForFilepath(filepath) {
    const metadatas = this.plugin.settings.fileMetadata;
    if (!metadatas[filepath] || metadatas[filepath].defaultProjectId === void 0) {
      return this.plugin.settings.defaultProjectName;
    } else {
      const defaultProjectId = metadatas[filepath].defaultProjectId;
      const defaultProjectName = this.getProjectNameByIdFromCache(defaultProjectId);
      return defaultProjectName;
    }
  }
  async getDefaultProjectIdForFilepath(filepath) {
    const metadatas = this.plugin.settings.fileMetadata;
    if (!metadatas[filepath] || metadatas[filepath].defaultProjectId === void 0) {
      return this.plugin.settings.defaultProjectId;
    } else {
      const defaultProjectId = metadatas[filepath].defaultProjectId;
      return defaultProjectId;
    }
  }
  async getFilepathForProjectId(projectId) {
    const metadatas = this.plugin.settings.fileMetadata;
    for (const key in metadatas) {
      const value = metadatas[key];
      if (metadatas[key].defaultProjectId === projectId) {
        return key;
      }
    }
    let filePath = "";
    if (projectId === this.plugin.settings.inboxID || projectId === this.plugin.settings.defaultProjectId) {
      if (this.plugin.settings.defaultProjectName) {
        filePath = this.plugin.settings.defaultProjectName + ".md";
        return filePath;
      }
    }
    filePath = await this.getProjectNameByIdFromCache(projectId) + ".md";
    if (!filePath) {
      let errmsg2 = `File path not found for ${projectId}, returning ${filePath} instead. `;
      console.warn(errmsg2);
      throw new Error(errmsg2);
    }
    let errmsg = `File path not found for ${projectId}, returning ${filePath} instead. `;
    console.warn(errmsg);
    return filePath;
  }
  async setDefaultProjectIdForFilepath(filepath, defaultProjectId) {
    const metadata = await this.getFileMetadata(filepath, defaultProjectId);
    metadata.defaultProjectId = defaultProjectId;
    if (!metadata.TickTickTasks || !metadata.TickTickCount) {
      metadata.TickTickTasks = [];
      metadata.TickTickCount = 0;
    }
    await this.updateFileMetadata(filepath, metadata);
  }
  //Read all tasks from Cache
  async loadTasksFromCache() {
    try {
      const savedTasks = this.plugin.settings.TickTickTasksData.tasks;
      return savedTasks;
    } catch (error) {
      console.error(`Error loading tasks from Cache: ${error}`);
      return [];
    }
  }
  // Overwrite and save all tasks to cache
  async saveTasksToCache(newTasks) {
    try {
      this.plugin.settings.TickTickTasksData.tasks = newTasks;
    } catch (error) {
      console.error(`Error saving tasks to Cache: ${error}`);
      return false;
    }
  }
  //Append to Cache file
  async appendTaskToCache(task, filePath) {
    try {
      if (task === null) {
        return;
      }
      const savedTasks = this.plugin.settings.TickTickTasksData.tasks;
      if (!savedTasks) {
        this.plugin.settings.TickTickTasksData.tasks = [];
        await this.plugin.saveSettings();
      }
      task.title = this.plugin.taskParser?.stripOBSUrl(task.title);
      this.plugin.settings.TickTickTasksData.tasks.push(task);
      await this.addTaskToMetadata(filePath, task);
      await this.plugin.saveSettings();
    } catch (error) {
      console.error(`Error appending task to Cache: ${error}`);
    }
  }
  //Read the task with the specified id
  async loadTaskFromCacheID(taskId) {
    try {
      const savedTasks = this.plugin.settings.TickTickTasksData.tasks;
      const savedTask = savedTasks.find((task) => task.id === taskId);
      return savedTask;
    } catch (error) {
      console.error(`Error finding task from Cache: ${error}`);
      return [];
    }
  }
  //get Task titles
  async getTaskTitles(taskIds) {
    const savedTasks = this.plugin.settings.TickTickTasksData.tasks;
    let titles = savedTasks.filter((task) => taskIds.includes(task.id)).map((task) => task.title);
    titles = titles.map((task) => {
      return this.plugin.taskParser?.stripOBSUrl(task);
    });
    return titles;
  }
  //Overwrite the task with the specified id in update
  async updateTaskToCacheByID(task, movedPath) {
    try {
      let filePath = "";
      if (!movedPath) {
        filePath = await this.getFilepathForTask(task.id);
        if (!filePath) {
          filePath = await this.getFilepathForProjectId(task.projectId);
        }
        if (!filePath) {
          throw new Error(`File not found for ${task.id} - ${task.title}`);
        }
      } else {
        filePath = movedPath;
      }
      await this.deleteTaskFromCache(task.id);
      await this.appendTaskToCache(task, filePath);
      return task;
    } catch (error) {
      console.error(`Error updating task to Cache: ${error}`);
      return [];
    }
  }
  async getFilepathForTask(taskId) {
    const metaDatas = await this.getFileMetadatas();
    for (const key in metaDatas) {
      let filepath = key;
      const value = metaDatas[key];
      if (value.TickTickTasks.find((task) => task.taskId === taskId)) {
        return key;
      }
    }
    return null;
  }
  async getProjectIdForTask(taskId) {
    const savedTasks = this.plugin.settings.TickTickTasksData.tasks;
    const taskIndex = savedTasks.findIndex((task) => task.id === taskId);
    if (taskIndex !== -1) {
      return savedTasks[taskIndex].projectId;
    }
  }
  //The structure of due {date: "2025-02-25",isRecurring: false,lang: "en",string: "2025-02-25"}
  // modifyTaskToCacheByID(taskId: string, { content, due }: { content?: string, due?: Due }): void {
  // try {
  // const savedTasks = this.plugin.settings.TickTickTasksData.tasks;
  // const taskIndex = savedTasks.findIndex((task) => task.id === taskId);
  // if (taskIndex !== -1) {
  // const updatedTask = { ...savedTasks[taskIndex] };
  // if (content !== undefined) {
  // updatedTask.content = content;
  // }
  // if (due !== undefined) {
  // if (due === null) {
  // updatedTask.due = null;
  // } else {
  // updatedTask.due = due;
  // }
  // }
  // savedTasks[taskIndex] = updatedTask;
  // this.plugin.settings.TickTickTasksData.tasks = savedTasks;
  // } else {
  // throw new Error(`Task with ID ${taskId} not found in cache.`);
  // }
  // } catch (error) {
  // // Handle the error appropriately, eg by logging it or re-throwing it.
  // }
  // }
  //open a task status
  async reopenTaskToCacheByID(taskId) {
    let projectId = null;
    try {
      const savedTasks = this.plugin.settings.TickTickTasksData.tasks;
      const taskIndex = savedTasks.findIndex((task) => task.id === taskId);
      if (taskIndex > -1) {
        savedTasks[taskIndex].status = 0;
        projectId = savedTasks[taskIndex].projectId;
      }
      this.plugin.settings.TickTickTasksData.tasks = savedTasks;
      return projectId;
    } catch (error) {
      console.error(`Error open task to Cache file: ${error}`);
      throw error;
    }
  }
  //close a task status
  async closeTaskToCacheByID(taskId) {
    let projectId = null;
    try {
      const savedTasks = this.plugin.settings.TickTickTasksData.tasks;
      const taskIndex = savedTasks.findIndex((task) => task.id === taskId);
      if (taskIndex > -1) {
        savedTasks[taskIndex].status = 2;
        projectId = savedTasks[taskIndex].projectId;
      }
      this.plugin.settings.TickTickTasksData.tasks = savedTasks;
      return projectId;
    } catch (error) {
      console.error(`Error close task to Cache file: ${error}`);
      throw error;
    }
  }
  //Delete task by ID
  async deleteTaskFromCache(taskId) {
    try {
      const savedTasks = this.plugin.settings.TickTickTasksData.tasks;
      const newSavedTasks = savedTasks.filter((t) => t.id !== taskId);
      this.plugin.settings.TickTickTasksData.tasks = newSavedTasks;
      await this.deleteTaskIdFromMetadataByTaskId(taskId);
    } catch (error) {
      console.error(`Error deleting task from Cache file: ${error}`);
    }
  }
  //Delete task through ID array
  async deleteTaskFromCacheByIDs(deletedTaskIds) {
    try {
      const savedTasks = this.plugin.settings.TickTickTasksData.tasks;
      const newSavedTasks = savedTasks.filter((t) => !deletedTaskIds.includes(t.id));
      this.plugin.settings.TickTickTasksData.tasks = newSavedTasks;
      deletedTaskIds.forEach(async (taskId) => {
        await this.deleteTaskIdFromMetadataByTaskId(taskId);
      });
    } catch (error) {
      console.error(`Error deleting task from Cache : ${error}`);
    }
  }
  //Find project id by name
  async getProjectIdByNameFromCache(projectName) {
    try {
      const savedProjects = this.plugin.settings.TickTickTasksData.projects;
      const targetProject = savedProjects.find((obj) => obj.name.toLowerCase() === projectName.toLowerCase());
      const projectId = targetProject ? targetProject.id : null;
      return projectId;
    } catch (error) {
      console.error(`Error finding project from Cache file: ${error}`);
      return false;
    }
  }
  async getProjectNameByIdFromCache(projectId) {
    try {
      const savedProjects = this.plugin.settings.TickTickTasksData.projects;
      const targetProject = savedProjects.find((obj) => obj.id === projectId);
      const projectName = targetProject ? targetProject.name : null;
      return projectName;
    } catch (error) {
      console.error(`Error finding project from Cache file: ${error}`);
      return false;
    }
  }
  //save projects data to json file
  async saveProjectsToCache() {
    try {
      const projectGroups = await this.plugin.tickTickRestAPI?.GetProjectGroups();
      const projects = await this.plugin.tickTickRestAPI?.GetAllProjects();
      let inboxProject = {
        id: this.plugin.settings.inboxID,
        name: this.plugin.settings.inboxName
      };
      projects.push(inboxProject);
      const duplicates = projects.reduce((acc, obj, index, arr) => {
        const duplicateIndex = arr.findIndex((item) => item.name === obj.name && item.id !== obj.id);
        if (duplicateIndex !== -1 && !acc.includes(obj)) {
          acc.push(obj);
        }
        return acc;
      }, []);
      const sortedDuplicates = duplicates.sort((a, b) => a.name.localeCompare(b.name));
      if (sortedDuplicates.length > 0) {
        if (this.plugin.settings.debugMode) {
          console.log("Found duplicate lists:");
          sortedDuplicates.forEach((thing) => console.log(thing.id, thing.name));
        }
        await this.showFoundDuplicatesModal(this.app, this.plugin, sortedDuplicates);
        return false;
      }
      if (!projects) {
        return false;
      }
      this.plugin.settings.TickTickTasksData.projects = projects;
      await this.plugin.saveSettings();
      return true;
    } catch (error) {
      console.error(`error downloading projects: ${error}`);
      new import_obsidian10.Notice("Error downloading projects: " + error.message);
      await this.plugin.unlockSynclock();
      ;
      return false;
    }
  }
  async updateRenamedFilePath(oldpath, newpath) {
    try {
      const savedTask = await this.loadTasksFromCache();
      const newTasks = savedTask.map((obj) => {
        if (obj.path === oldpath) {
          return { ...obj, path: newpath };
        } else {
          return obj;
        }
      });
      await this.saveTasksToCache(newTasks);
      const fileMetadatas = this.plugin.settings.fileMetadata;
      fileMetadatas[newpath] = fileMetadatas[oldpath];
      delete fileMetadatas[oldpath];
      this.plugin.settings.fileMetadata = fileMetadatas;
    } catch (error) {
      console.error(`Error updating renamed file path to cache: ${error}`);
    }
  }
  // TODO: why did I think I needed this?
  findTaskInMetada(taskId, filePath) {
    const fileMetadata = this.plugin.settings.fileMetadata;
    for (const file in fileMetadata) {
      console.log("in file: :", file);
      if (file == filePath) {
        console.log("breaking");
        continue;
      }
      const tasks = fileMetadata[file].TickTickTasks;
      for (const task of tasks) {
        if (task.taskId === taskId) {
          console.log("found");
          return true;
        }
      }
    }
    console.log("not found");
    return false;
  }
  async isProjectMoved(lineTask, filePath) {
    const currentLocation = await this.getFilepathForTask(lineTask.id);
    if (!currentLocation) {
      return false;
    }
    if (currentLocation != filePath) {
      return currentLocation;
    } else {
      return null;
    }
  }
  isTaskInCache(taskId) {
    try {
      const savedTasks = this.plugin.settings.TickTickTasksData.tasks;
      const savedTask = savedTasks.find((task) => task.id === taskId);
      if (savedTask) {
        return true;
      }
    } catch (error) {
      console.error(`Error finding task from Cache: ${error}`);
      return false;
    }
    return false;
  }
  async findTaskInFiles(taskId) {
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      const listItemsCache = this.app.metadataCache.getFileCache(file)?.listItems ?? [];
      const taskList = await this.findInFile(file, listItemsCache);
      if (taskList.includes(taskId)) {
        return file.path;
      }
    }
    return null;
  }
  async findInFile(file, listItemsCache) {
    const fileCachedContent = await this.app.vault.cachedRead(file);
    const lines = fileCachedContent.split("\n");
    const tasks = listItemsCache.map((listItemCache) => listItemCache.position.start.line).map((idx) => lines[idx]).map((line) => this.plugin.taskParser?.getTickTickIdFromLineText(line)).filter((taskId) => taskId !== null);
    return tasks;
  }
  async showFoundDuplicatesModal(app2, plugin, projects) {
    const myModal = new FoundDuplicatesModal(app2, plugin, projects, (result) => {
      this.ret = result;
    });
    const bConfirmation = await myModal.showModal();
    return bConfirmation;
  }
};

// src/fileOperation.ts
var import_obsidian12 = require("obsidian");

// src/modals/TaskDeletionModal.ts
var import_obsidian11 = require("obsidian");
var TaskDeletionModal = class extends import_obsidian11.Modal {
  title = "Task Deletion Confirmation";
  message = "The following Task(s) will be deleted because: ";
  cancelLabel = "Cancel";
  confirmLabel = "Confirm Deletion";
  taskTitles = [];
  result;
  reason;
  onSubmit;
  resolvePromise;
  constructor(app2, taskTitles, reason, onSubmit) {
    super(app2);
    this.taskTitles = taskTitles;
    this.reason = reason;
    this.onSubmit = onSubmit;
  }
  /**
   * Called automatically by the Modal class when modal is opened.
   */
  onOpen() {
    const { titleEl, contentEl } = this;
    titleEl.setText(this.title);
    contentEl.createEl("p", { text: `${this.message}${this.reason}` });
    const unorderedList = contentEl.createEl("ul");
    this.taskTitles.forEach((task) => {
      unorderedList.createEl("li", { text: task });
    });
    new import_obsidian11.Setting(contentEl).addButton((cancelBtn) => {
      cancelBtn.setClass("ts_button");
      cancelBtn.setButtonText(this.cancelLabel);
      cancelBtn.onClick(() => {
        this.result = false;
        this.onSubmit(this.result);
        this.close();
      });
    }).addButton((confirmBtn) => {
      confirmBtn.setClass("ts_button");
      confirmBtn.setWarning();
      confirmBtn.setButtonText(this.confirmLabel);
      confirmBtn.onClick(() => {
        this.result = true;
        this.onSubmit(this.result);
        this.close();
      });
    });
  }
  /**
   * Called automatically by the Modal class when modal is closed.
   */
  onClose() {
    this.titleEl.empty();
    this.contentEl.empty();
    super.onClose();
    this.resolvePromise(this.result);
  }
  showModal() {
    this.open();
    return new Promise(
      (resolve) => this.resolvePromise = resolve
    );
  }
};

// src/fileOperation.ts
var FileOperation = class {
  app;
  plugin;
  constructor(app2, plugin) {
    this.app = app2;
    this.plugin = plugin;
  }
  //Complete a task and mark it as completed
  async completeTaskInTheFile(taskId) {
    const currentTask = await this.plugin.cacheOperation?.loadTaskFromCacheID(taskId);
    const filepath = await this.plugin.cacheOperation?.getFilepathForTask(taskId);
    const file = this.app.vault.getAbstractFileByPath(filepath);
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    let modified = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.includes(taskId) && this.plugin.taskParser?.hasTickTickTag(line)) {
        lines[i] = line.replace("[ ]", "[x]");
        modified = true;
        break;
      }
    }
    if (modified) {
      const newContent = lines.join("\n");
      await this.app.vault.modify(file, newContent);
    }
  }
  // uncheck completed tasks,
  async uncompleteTaskInTheFile(taskId) {
    const currentTask = await this.plugin.cacheOperation?.loadTaskFromCacheID(taskId);
    const filepath = await this.plugin.cacheOperation?.getFilepathForTask(taskId);
    const file = this.app.vault.getAbstractFileByPath(filepath);
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    let modified = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.includes(taskId) && this.plugin.taskParser?.hasTickTickTag(line)) {
        lines[i] = line.replace(/- \[(x|X)\]/g, "- [ ]");
        modified = true;
        break;
      }
    }
    if (modified) {
      const newContent = lines.join("\n");
      await this.app.vault.modify(file, newContent);
    }
  }
  //add #TickTick at the end of task line, if full vault sync enabled
  async addTickTickTagToFile(filepath) {
    const file = this.app.vault.getAbstractFileByPath(filepath);
    if (file && file instanceof import_obsidian12.TFolder) {
      return;
    }
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    let modified = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (!this.plugin.taskParser?.isMarkdownTask(line)) {
        continue;
      }
      if (this.plugin.taskParser?.getTaskContentFromLineText(line) == "") {
        continue;
      }
      if (!this.plugin.taskParser?.hasTickTickId(line) && !this.plugin.taskParser?.hasTickTickTag(line)) {
        let newLine = this.plugin.taskParser?.addTickTickTag(line);
        newLine = this.plugin.taskParser?.stripLineItemId(newLine);
        lines[i] = newLine;
        modified = true;
      }
    }
    if (modified) {
      const newContent = lines.join("\n");
      await this.app.vault.modify(file, newContent);
      new import_obsidian12.Notice("New Tasks will be added to TickTick on next Sync.");
    }
  }
  //add TickTick at the line
  async addTickTickLinkToFile(filepath) {
    const file = this.app.vault.getAbstractFileByPath(filepath);
    if (file && file instanceof import_obsidian12.TFolder) {
      return;
    }
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    let modified = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (this.plugin.taskParser?.hasTickTickId(line) && this.plugin.taskParser?.hasTickTickTag(line)) {
        if (this.plugin.taskParser?.hasTickTickLink(line)) {
          return;
        }
        const taskID = this.plugin.taskParser?.getTickTickIdFromLineText(line);
        const taskObject = await this.plugin.cacheOperation?.loadTaskFromCacheID(taskID);
        const newLine = this.plugin.taskParser?.addTickTickLink(line, taskObject.id, taskObject.projecId);
        lines[i] = newLine;
        modified = true;
      } else {
        continue;
      }
    }
    if (modified) {
      const newContent = lines.join("\n");
      await this.app.vault.modify(file, newContent);
    }
  }
  // sync updated task content to file
  async addTasksToFile(tasks) {
    tasks.sort((taskA, taskB) => taskA.projectId.localeCompare(taskB.projectId) || taskA.id.localeCompare(taskB.id));
    if (!tasks) {
      console.error("No tasks to add.");
      return false;
    }
    const projectIds = [...new Set(tasks.map((task) => task.projectId))];
    for (const projectId of projectIds) {
      let taskFile = await this.plugin.cacheOperation?.getFilepathForProjectId(projectId);
      let file;
      if (taskFile) {
        file = this.app.vault.getAbstractFileByPath(taskFile);
        if (!(file instanceof import_obsidian12.TFile)) {
          file = await this.getOrCreateDefaultFile(taskFile);
        }
      }
      let projectTasks = tasks.filter((task) => task.projectId === projectId);
      projectTasks.sort((a, b) => this.compareTasks(a, b, 0, projectTasks));
      let result = await this.addProjectTasksToFile(file, projectTasks);
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      if (this.plugin.settings.debugMode) {
        console.log("===", projectTasks, result ? "Completed add task." : "Failed add task");
      }
    }
    return true;
  }
  async getOrCreateDefaultFile(taskFile) {
    let file;
    try {
      const folderPath = this.plugin.settings.TickTickTasksFilePath;
      let folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (!(folder instanceof import_obsidian12.TFolder)) {
        console.warn(`Folder ${folderPath} does not exit. It will be created`);
        folder = await this.app.vault.createFolder(folderPath);
      }
      new import_obsidian12.Notice(`Creating new file: ${folder.path}/${taskFile}`);
      console.warn(`Creating new file: ${folder.path}/${taskFile}`);
      taskFile = `${folder.path}/${taskFile}`;
      let whoAdded = `${this.plugin.manifest.name} -- ${this.plugin.manifest.version}`;
      try {
        file = await this.app.vault.create(taskFile, `== Added by ${whoAdded} == `);
      } catch (error) {
        console.error("File creation failed: ", error);
        if (error.message.includes("File already exists")) {
          console.error("Attempting to find existing file");
          file = this.app.vault.getAbstractFileByPath(taskFile);
        }
      }
      return file;
    } catch (error) {
      console.error("Error on create file: ", error);
      throw new Error(error);
    }
  }
  async addProjectTasksToFile(file, tasks) {
    try {
      const content = await this.app.vault.read(file);
      let lines = content.split("\n");
      let modified = false;
      let lastTaskLine = 0;
      let lastLineInFile = lines.length;
      let lastLineId = "";
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (this.plugin.taskParser?.hasTickTickTag(line)) {
          lastTaskLine = i;
          lastLineId = this.plugin.taskParser?.getTickTickIdFromLineText(line);
        }
      }
      let lineToInsert;
      if (lastTaskLine > 0) {
        lineToInsert = lastTaskLine + 1;
        if (lastLineId) {
          let lastTask = await this.plugin.cacheOperation?.loadTaskFromCacheID(lastLineId);
          if (lastTask) {
            if (lastTask.items) {
              lineToInsert = lineToInsert + lastTask.items.length;
            }
            if (lastTask.childIds) {
              lineToInsert = lineToInsert + lastTask.childIds.length;
            }
          }
        }
      } else {
        lineToInsert = lastLineInFile;
      }
      let oldLineCount = lines.length;
      lines = await this.writeLines(tasks, lineToInsert, lines, file);
      let newLineCount = lines.length;
      if (oldLineCount < newLineCount) {
        const newContent = lines.join("\n");
        await this.app.vault.modify(file, newContent);
        this.plugin.lastLines.set(file.path, lines.length);
      }
      return true;
    } catch (error) {
      console.error(`Could not add Tasks to file ${file.path} 
 Error: ${error}`);
      return false;
    }
  }
  async writeLines(tasks, lineToInsert, lines, file) {
    const addedTask = [];
    for (const task of tasks) {
      let itemCount = 0;
      if (lines.find((line) => line.includes(task.id))) {
        await this.updateTaskInFile(task, lines);
        await this.plugin.cacheOperation?.updateTaskToCacheByID(task, file.path);
        addedTask.push(task.id);
        continue;
      }
      let lineText = await this.plugin.taskParser?.convertTaskToLine(task);
      if (task.status != 0) {
        lineText = this.plugin.taskParser?.addCompletionDate(lineText, task.completedTime);
      }
      if (task.parentId) {
        let parentIndex = lines.indexOf(lines.find((line) => line.includes(task.parentId)));
        if (parentIndex < 0) {
          console.error("Parent ID: ", task.parentId, " not found for: " + task.title);
        }
        let parentLine = lines[parentIndex];
        if (parentLine) {
          const regex = /^[^-.]*/;
          let parentTabs = parentLine.match(regex)[0];
          if (parentTabs) {
            parentTabs = parentTabs + "	";
          } else {
            parentTabs = "	";
          }
          if (addedTask.indexOf(task.parentId) < 0) {
            const parentTask = await this.plugin.cacheOperation?.loadTaskFromCacheID(task.parentId);
            if (parentTask && parentTask.items) {
              parentIndex = parentIndex + parentTask.items.length;
            }
          }
          lineText = parentTabs + lineText;
          if (lineText.includes("\n")) {
            lineText = lineText.replace(/\n/g, "\n" + parentTabs + "	");
            itemCount = (lineText.match(/\n/g) || []).length;
          }
          lines.splice(parentIndex + 1, 0, lineText);
        } else {
          console.error("Parent not found, inserting at: ", lineToInsert);
          lineText = "	" + lineText;
          if (lineText.includes("\n")) {
            lineText = lineText.replace(/\n/g, "\n		");
            itemCount = (lineText.match(/\n/g) || []).length;
          }
          lines.splice(lineToInsert, 0, lineText);
        }
      } else {
        if (lineText.includes("\n")) {
          lineText = lineText.replace(/\n/g, "\n	");
          itemCount = (lineText.match(/\n/g) || []).length;
        }
        lines.splice(lineToInsert, 0, lineText);
      }
      let tags = this.plugin.taskParser?.getAllTagsFromLineText(lineText);
      if (tags) {
        task.tags = tags;
      }
      let taskURL = this.plugin.taskParser?.getObsidianUrlFromFilepath(file.path);
      if (taskURL) {
        task.title = task.title + " " + taskURL;
      }
      let updatedTask = await this.plugin.tickTickRestAPI?.UpdateTask(task);
      await this.plugin.cacheOperation?.appendTaskToCache(updatedTask, file.path);
      addedTask.push(task.id);
      lineToInsert = lineToInsert + 1 + itemCount;
    }
    return lines;
  }
  // update task content to file
  async updateTaskInFile(task, toBeProcessed) {
    const taskId = task.id;
    const currentTask = await this.plugin.cacheOperation?.loadTaskFromCacheID(taskId);
    if (currentTask) {
      const hasChildren = this.hasChildren(currentTask);
      if (this.plugin.taskParser?.isProjectIdChanged(currentTask, task) || this.plugin.taskParser?.isParentIdChanged(currentTask, task)) {
        await this.handleTickTickStructureMove(task, currentTask, toBeProcessed);
        return;
      }
    }
    let filepath = await this.plugin.cacheOperation?.getFilepathForTask(taskId);
    if (!filepath) {
      filepath = await this.plugin.cacheOperation?.getFilepathForProjectId(task.projectId);
      if (!filepath) {
        throw new Error(`File not found for ${task.id}, ${task.title}`);
      }
    }
    const file = this.app.vault.getAbstractFileByPath(filepath);
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    let modified = false;
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];
      if (line.includes(taskId) && this.plugin.taskParser?.hasTickTickTag(line)) {
        let newTaskContent = await this.plugin.taskParser?.convertTaskToLine(task);
        let parentTabs = this.plugin.taskParser?.getTabs(line);
        let itemCount = 0;
        if (newTaskContent.includes("\n")) {
          newTaskContent = newTaskContent.replace(/\n/g, "\n" + parentTabs + "	");
          itemCount = (newTaskContent.match(/\n/g) || []).length;
        }
        if (currentTask && currentTask.items && currentTask.items.length > 0) {
          lines.splice(i + 1, currentTask.items.length);
        }
        lines[i] = parentTabs + line.replace(line, newTaskContent);
        if (task.status != 0) {
          lines[i] = this.plugin.taskParser?.addCompletionDate(lines[i], task.completedTime);
        }
        modified = true;
        break;
      }
    }
    if (modified) {
      const newContent = lines.join("\n");
      await this.app.vault.modify(file, newContent);
    }
  }
  async checkForDuplicates(fileMetadata, taskList) {
    let taskIds = {};
    let duplicates = {};
    if (!fileMetadata) {
      return;
    }
    let fileName;
    try {
      for (const file in fileMetadata) {
        fileName = file;
        const currentFile = this.app.vault.getAbstractFileByPath(file);
        if (!currentFile) {
          console.log("Duplicate check Skipping ", file, " because it's not found.");
          continue;
        }
        if (currentFile && currentFile instanceof import_obsidian12.TFolder) {
          console.log("Duplicate check Skipping ", file, " because it's a folder.");
          continue;
        }
        try {
          const content = await this.app.vault.read(currentFile);
          for (let taskListKey in taskList) {
            if (content.includes(taskListKey)) {
              if (taskIds[taskListKey]) {
                if (!duplicates[taskListKey]) {
                  duplicates[taskListKey] = [taskIds[taskListKey]];
                }
                duplicates[taskListKey].push(file);
              } else {
                taskIds[taskListKey] = file;
              }
            }
          }
        } catch {
          console.log("Duplicate check Skipping ", file, " because it's not readable.");
          continue;
        }
      }
      return duplicates;
    } catch (Fail) {
      const errMsg = `File [${fileName}] not found, or is locked. If file exists, Please try again later.`;
      console.error(Fail, errMsg);
      throw new Error(errMsg);
    }
  }
  //Yes, I know this belongs in taskParser, but I don't feel like messing with it right now.
  hasChildren(currentTask) {
    if (currentTask.childIds) {
      return currentTask.childIds?.length > 0;
    } else {
      return false;
    }
  }
  // delete task from file
  async deleteTaskFromSpecificFile(filePath, taskId, taskTitle, numItems, bConfirmDialog) {
    if (bConfirmDialog) {
      const bConfirm = await this.confirmDeletion(taskTitle + "in File: " + filePath);
      if (!bConfirm) {
        new import_obsidian12.Notice("Tasks will not be deleted. Please rectify the issue before the next sync.", 0);
        return [];
      }
    }
    console.info("Task being deleted from file: ", taskId, filePath);
    const file = this.app.vault.getAbstractFileByPath(filePath);
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    let modified = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.includes(taskId) && this.plugin.taskParser?.hasTickTickTag(line)) {
        lines.splice(i, numItems + 1);
        modified = true;
        break;
      }
    }
    if (modified) {
      const newContent = lines.join("\n");
      await this.app.vault.modify(file, newContent);
    }
  }
  async deleteTaskFromFile(task) {
    const taskId = task.id;
    const currentTask = await this.plugin.cacheOperation?.loadTaskFromCacheID(taskId);
    const filepath = await this.plugin.cacheOperation?.getFilepathForTask(taskId);
    if (filepath) {
      await this.deleteTaskFromSpecificFile(filepath, task.id, task.title, currentTask.items.length, false);
    } else {
      throw new Error(`File not found for ${task.title}. File path found is ${filepath}`);
    }
  }
  //search TickTick_id by content
  async searchTickTickIdFromFilePath(filepath, searchTerm) {
    const file = this.app.vault.getAbstractFileByPath(filepath);
    const fileContent = await this.app.vault.read(file);
    const fileLines = fileContent.split("\n");
    let TickTickId = null;
    for (let i = 0; i < fileLines.length; i++) {
      const line = fileLines[i];
      if (line.includes(searchTerm)) {
        const regexResult = /\[ticktick_id::\s*(\w+)\]/.exec(line);
        if (regexResult) {
          TickTickId = regexResult[1];
        }
        break;
      }
    }
    return TickTickId;
  }
  //get all files in the vault
  async getAllFilesInTheVault() {
    const files = this.app.vault.getFiles();
    return files;
  }
  //TODO: I think there are three versions of this!
  //search filepath by taskid in vault
  async searchFilepathsByTaskidInVault(taskId) {
    const files = await this.getAllFilesInTheVault();
    const tasks = files.map(async (file) => {
      if (!this.isMarkdownFile(file.path)) {
        return;
      }
      const fileContent = await this.app.vault.cachedRead(file);
      if (fileContent.includes(taskId)) {
        return file.path;
      }
    });
    const results = await Promise.all(tasks);
    const filePaths = results.filter((filePath) => filePath !== void 0);
    return filePaths[0] || null;
  }
  isMarkdownFile(filename) {
    let extension = filename.split(".").pop();
    extension = extension.toLowerCase();
    if (extension === "md") {
      return true;
    } else {
      return false;
    }
  }
  async confirmDeletion(taskTitle) {
    const tasksTitles = [];
    tasksTitles.push(taskTitle);
    const reason = "task not found in local cache.";
    const myModal = new TaskDeletionModal(this.app, tasksTitles, reason, (result) => {
      this.ret = result;
    });
    const bConfirmation = await myModal.showModal();
    return bConfirmation;
  }
  /*
  *Task has been moved in TickTick. Or it's parentage has changed.
  * Need to delete it from the old file.
  * Add it to the new project file.
  * This magically handles parentage as well.
  */
  async handleTickTickStructureMove(newTask, oldTask, toBeProcessed) {
    let filepath = await this.plugin.cacheOperation?.getFilepathForTask(oldTask.id);
    if (!filepath) {
      let errmsg = `File not found for moved newTask:  ${newTask.id}, ${newTask.title}`;
      throw new Error(errmsg);
    }
    const oldProjectId = oldTask.projectId;
    const oldtaskItemNum = oldTask.items?.length;
    const oldTaskHasChildren = this.hasChildren(oldTask);
    const oldTaskId = oldTask.id;
    await this.moveTask(filepath, newTask, oldtaskItemNum, oldTaskId, oldProjectId);
    let saveTheChildren = false;
    if (oldTask.parentId && !newTask.parentId) {
      saveTheChildren = true;
    }
    if (oldTaskHasChildren && !saveTheChildren) {
      for (const childId of oldTask.childIds) {
        const child = await this.plugin.cacheOperation?.loadTaskFromCacheID(childId);
        let numChildTaskItems = 0;
        if (child && child.items) {
          numChildTaskItems = child.items.length;
        }
        try {
          await this.deleteTaskFromSpecificFile(filepath, child.id, child.title, numChildTaskItems, false);
        } catch (error) {
          console.log("Child ", childId, " not found for parent: ", newTask.id);
          continue;
        }
      }
    }
    if (newTask.parentId || saveTheChildren) {
      const hasChildren = this.hasChildren(newTask);
      if (hasChildren) {
        await this.moveChildTasks(newTask, toBeProcessed, filepath);
      }
    }
  }
  async moveChildTasks(newTask, toBeProcessed, filepath) {
    for (const childId of newTask.childIds) {
      if (toBeProcessed.includes(childId)) {
        continue;
      }
      const currentChild = await this.plugin.cacheOperation?.loadTaskFromCacheID(childId);
      if (currentChild) {
        currentChild.parentId = newTask.id;
        currentChild.projectId = newTask.projectId;
        const numChildTaskItems = currentChild.items?.length;
        await this.moveTask(filepath, currentChild, numChildTaskItems, currentChild.id, currentChild.projectId);
        const currentChildHasChildren = this.hasChildren(currentChild);
        if (currentChildHasChildren) {
          const currentChild2 = await this.plugin.cacheOperation?.loadTaskFromCacheID(childId);
          await this.moveChildTasks(currentChild2, toBeProcessed, filepath);
        }
      } else {
        console.log("Child not found: ", childId);
      }
    }
  }
  async moveTask(filepath, task, oldtaskItemNum, oldTaskId, oldProjectId) {
    await this.deleteTaskFromSpecificFile(filepath, task.id, task.title, oldtaskItemNum, false);
    await this.plugin.cacheOperation?.deleteTaskFromCache(oldTaskId);
    await this.addTasksToFile([task]);
    const cleanTitle = this.plugin.taskParser?.stripOBSUrl(task.title);
    let message = "";
    if (task.projectId != oldProjectId) {
      const newProjectName = await this.plugin.cacheOperation?.getProjectNameByIdFromCache(task.projectId);
      const oldProjectName = await this.plugin.cacheOperation?.getProjectNameByIdFromCache(oldProjectId);
      message = "Task Moved.\nTask: " + cleanTitle + "\nwas moved from\n " + oldProjectName + "\nto\n" + newProjectName;
    } else {
      if (task.parentId) {
        const parentTask = await this.plugin.cacheOperation?.loadTaskFromCacheID(task.parentId);
        const cleanParentTaskTitle = this.plugin.taskParser?.stripOBSUrl(parentTask.title);
        message = "Task has new Parent.\nTask: " + cleanTitle + "\nis now a child of\n " + cleanParentTaskTitle;
      } else {
        message = "Task is now a top level task.\nTask: " + cleanTitle;
      }
    }
    new import_obsidian12.Notice(message, 0);
  }
  compareTasks(a, b, depth = 0, tasks) {
    if (!a.parentId && b.parentId) {
      return -1;
    } else if (a.parentId && !b.parentId) {
      return 1;
    } else if (!a.parentId && !b.parentId) {
      return a.sortOrder - b.sortOrder;
    } else {
      const visited = /* @__PURE__ */ new Set();
      let currentA = a;
      while (currentA.parentId && depth < 100) {
        if (visited.has(currentA.id)) {
          return a.id.localeCompare(b.id);
        }
        visited.add(currentA.id);
        currentA = this.getParent(currentA.id, tasks);
      }
      let currentB = b;
      visited.clear();
      while (currentB.parentId && depth < 100) {
        if (visited.has(currentB.id)) {
          return a.id.localeCompare(b.id);
        }
        visited.add(currentB.id);
        currentB = this.getParent(currentB.id, tasks);
      }
      return currentA ? -1 : 1;
    }
  }
  getParent(taskId, tasks) {
    return tasks.find((task) => task.id === taskId);
  }
};

// src/syncModule.ts
var import_obsidian13 = require("obsidian");
var import_bson_objectid2 = __toESM(require_objectid());
var SyncMan = class {
  app;
  plugin;
  constructor(app2, plugin) {
    this.app = app2;
    this.plugin = plugin;
  }
  async deletedTaskCheck(file_path) {
    let file;
    let currentFileValue;
    let view;
    let filepath;
    if (file_path) {
      file = this.app.vault.getAbstractFileByPath(file_path);
      if (file && file instanceof import_obsidian13.TFolder) {
        return;
      }
      filepath = file_path;
      if (file instanceof import_obsidian13.TFile) {
        currentFileValue = await this.app.vault.read(file);
      }
    } else {
      view = this.app.workspace.getActiveViewOfType(import_obsidian13.MarkdownView);
      file = this.app.workspace.getActiveFile();
      filepath = file?.path;
      currentFileValue = view?.data;
    }
    let fileMetadata = await this.plugin.cacheOperation?.getFileMetadata(filepath, null);
    if (!fileMetadata || !fileMetadata.TickTickTasks) {
      return;
    }
    let fileMetadata_TickTickTasks = fileMetadata.TickTickTasks;
    if (currentFileValue) {
      const currentFileValueWithOutFileMetadata = currentFileValue.replace(/^---[\s\S]*?---\n/, "");
      const deletedTaskIds = await this.findMissingTaskIds(currentFileValueWithOutFileMetadata, fileMetadata_TickTickTasks, filepath);
      const numDeletedTasks = deletedTaskIds.length;
      if (numDeletedTasks > 0) {
        await this.deleteTasksByIds(deletedTaskIds);
        fileMetadata = await this.plugin.cacheOperation?.getFileMetadata(filepath, null);
        if (!fileMetadata || !fileMetadata.TickTickTasks) {
          return;
        }
        fileMetadata_TickTickTasks = fileMetadata.TickTickTasks;
      }
      const deletedItems = [];
      for (const task of fileMetadata_TickTickTasks) {
        if (!task.taskItems) {
          continue;
        }
        for (const taskItem of task.taskItems) {
          if (!currentFileValueWithOutFileMetadata.includes(taskItem)) {
            deletedItems.push(taskItem);
          }
        }
        if (deletedItems.length > 0) {
          try {
            let updatedTask = await this.plugin.cacheOperation?.removeTaskItem(fileMetadata, task.taskId, deletedItems);
            if (updatedTask) {
              let taskURL = this.plugin.taskParser?.getObsidianUrlFromFilepath(filepath);
              if (taskURL) {
                updatedTask.title = updatedTask.title + " " + taskURL;
              }
              let updateResult = await this.plugin.tickTickRestAPI?.UpdateTask(updatedTask);
            }
          } catch (error) {
            console.error("Task Item removal failed: ", error);
          }
        }
      }
    } else {
      const deletedTaskIDs = fileMetadata_TickTickTasks.map((taskDetail) => taskDetail.taskId);
      if (deletedTaskIDs.length > 0) {
        console.error("Content not readable.", currentFileValue, filepath, " file is possibly open elsewhere?");
      }
    }
  }
  async findMissingTaskIds(currentContent, taskDetails, filePath) {
    const regex = /%%\[ticktick_id:: ([a-f0-9]{24})\]%%/g;
    const matches = currentContent.matchAll(regex);
    const existingTaskIds = new Set([...matches].map((match) => match[1]));
    let missingTaskIds = taskDetails.filter((taskDetail) => !existingTaskIds.has(taskDetail.taskId)).map((taskDetail) => taskDetail.taskId);
    if (missingTaskIds && missingTaskIds.length > 0) {
      let saveTheseTasks = [];
      for (const taskId of missingTaskIds) {
        const location = await this.plugin.cacheOperation?.findTaskInFiles(taskId);
        if (location) {
          saveTheseTasks.push(taskId);
        }
      }
      missingTaskIds = missingTaskIds.filter(
        (taskId) => {
          return !saveTheseTasks.includes(taskId);
        }
      );
    }
    return missingTaskIds;
  }
  async lineContentNewTaskCheck(editor, view) {
    const filepath = view.file?.path;
    const fileContent = view?.data;
    const cursor = editor.getCursor();
    const line = cursor.line;
    const linetxt = editor.getLine(line);
    let before = fileContent?.length;
    await this.addTask(linetxt, filepath, line, fileContent, editor, cursor);
    let after = fileContent?.length;
    return before != after;
  }
  async addTask(lineTxt, filePath, line, fileContent, editor, cursor) {
    if (!this.plugin.taskParser?.hasTickTickId(lineTxt) && this.plugin.taskParser?.hasTickTickTag(lineTxt)) {
      try {
        const currentTask = await this.plugin.taskParser?.convertLineToTask(lineTxt, filePath, line, fileContent);
        const newTask = await this.plugin.tickTickRestAPI?.AddTask(currentTask);
        if (currentTask.parentId) {
          let parentTask = await this.plugin.cacheOperation?.loadTaskFromCacheID(currentTask.parentId);
          parentTask = this.plugin.taskParser?.addChildToParent(parentTask, currentTask.parentId);
          parentTask = await this.plugin.tickTickRestAPI?.UpdateTask(parentTask);
          await this.plugin.cacheOperation?.updateTaskToCacheByID(parentTask);
        }
        const { id: ticktick_id, projectId: ticktick_projectId, url: ticktick_url } = newTask;
        new import_obsidian13.Notice(`new task ${newTask.title} id is ${newTask.id}`);
        await this.plugin.cacheOperation?.appendTaskToCache(newTask, filePath);
        if (currentTask.status != 0) {
          await this.plugin.tickTickRestAPI?.CloseTask(newTask.id);
          await this.plugin.cacheOperation?.closeTaskToCacheByID(ticktick_id);
        }
        await this.plugin.saveSettings();
        return await this.updateTaskLine(newTask, lineTxt, editor, cursor, fileContent, line, filePath);
      } catch (error) {
        console.error("Error adding task:", error);
        console.error(`The error occurred in file: ${filePath}`);
        return fileContent;
      }
    }
    return fileContent;
  }
  //This method was added at some point to handle the date moving logic that happens in converTaskToLine.
  // an unfortunate side effect: it farckles up the items. For now only update the task and not the items.
  // The assumption being that when this is called Items will be handled elsewhere.
  async updateTaskLine(newTask, lineTxt, editor, cursor, fileContent, line, filePath) {
    let newTaskCopy = { ...newTask };
    newTaskCopy.items = [];
    let text = await this.plugin.taskParser?.convertTaskToLine(newTaskCopy);
    const tabs = this.plugin.taskParser?.getTabs(lineTxt);
    text = tabs + text;
    if (editor && cursor) {
      const from = { line: cursor.line, ch: 0 };
      const to = { line: cursor.line, ch: lineTxt.length };
      editor?.replaceRange(text, from, to);
      return text;
    } else {
      try {
        const lines = fileContent.split("\n");
        lines[line] = text;
        const file = this.app.vault.getAbstractFileByPath(filePath);
        const newContent = lines.join("\n");
        await this.app.vault.modify(file, newContent);
        return newContent;
      } catch (error) {
        console.error(error);
        return text;
      }
    }
  }
  async fullTextNewTaskCheck(file_path) {
    let file;
    let currentFileValue;
    let view;
    let filepath = null;
    let editor = null;
    let cursor = null;
    if (file_path) {
      file = this.app.vault.getAbstractFileByPath(file_path);
      if (file && file instanceof import_obsidian13.TFolder) {
        return false;
      }
      if (file) {
        filepath = file_path;
        currentFileValue = await this.app.vault.read(file);
      } else {
        console.error(`File: ${file_path} not found. Removing from Meta Data`);
        await this.plugin.cacheOperation?.deleteFilepathFromMetadata(file_path);
        return false;
      }
    } else {
      const workspace = this.app.workspace;
      view = workspace.getActiveViewOfType(import_obsidian13.MarkdownView);
      editor = workspace.activeEditor?.editor;
      file = workspace.getActiveFile();
      filepath = file?.path;
      currentFileValue = view?.data;
    }
    if (this.plugin.settings.enableFullVaultSync) {
      await this.plugin.fileOperation?.addTickTickTagToFile(filepath);
    }
    const content = currentFileValue;
    const lines = content.split("\n");
    for (let line = 0; line < lines.length; line++) {
      const linetxt = lines[line];
      currentFileValue = await this.addTask(linetxt, filepath, line, currentFileValue, editor, cursor);
    }
    return true;
  }
  async lineModifiedTaskCheck(filepath, lineText, lineNumber, fileContent) {
    let modified = false;
    if (this.plugin.settings.enableFullVaultSync) {
      let metadata = await this.plugin.cacheOperation?.getFileMetadata(filepath);
      if (!metadata) {
        return false;
      }
      await this.plugin.saveSettings();
    }
    if (this.plugin.taskParser?.hasTickTickId(lineText) && this.plugin.taskParser?.hasTickTickTag(lineText)) {
      const lineTask = await this.plugin.taskParser?.convertLineToTask(lineText, filepath, lineNumber, fileContent);
      const lineTask_ticktick_id = lineTask.id;
      const savedTask = await this.plugin.cacheOperation?.loadTaskFromCacheID(lineTask_ticktick_id);
      if (!savedTask) {
        console.error(`There is no task ${lineTask.id}, ${lineTask.title} in the local cache. It will be deleted`);
        new import_obsidian13.Notice(`There is no task ${lineTask.id}, ${lineTask.title} in the local cache. It will be deleted`);
        await this.plugin.fileOperation?.deleteTaskFromSpecificFile(filepath, lineTask.id, lineTask.title, lineTask.items?.length, true);
        return false;
      }
      const lineTaskTitle = lineTask.title;
      const titleModified = this.plugin.taskParser?.isTitleChanged(lineTask, savedTask);
      const tagsModified = this.plugin.taskParser?.isTagsChanged(lineTask, savedTask);
      const projectModified = this.plugin.taskParser?.isProjectIdChanged(lineTask, savedTask);
      const oldFilePath = await this.plugin.cacheOperation?.isProjectMoved(lineTask, filepath);
      let projectMoved = false;
      if (oldFilePath) {
        projectMoved = true;
      }
      const statusModified = this.plugin.taskParser?.isStatusChanged(lineTask, savedTask);
      const dueDateModified = this.plugin.taskParser?.isDueDateChanged(lineTask, savedTask);
      const parentIdModified = this.plugin.taskParser?.isParentIdChanged(lineTask, savedTask);
      const priorityModified = !(lineTask.priority == savedTask.priority);
      const taskItemsModified = lineTask.items?.length != savedTask.items?.length;
      try {
        let contentChanged = false;
        let tagsChanged = false;
        let projectChanged = false;
        let statusChanged = false;
        let dueDateChanged = false;
        let parentIdChanged = false;
        let priorityChanged = false;
        let taskItemsChanged = false;
        if (titleModified) {
          if (this.plugin.settings.debugMode) {
            console.log(`Title modified for task ${lineTask_ticktick_id}
"New:" ${lineTask.title}
"Cached:" ${savedTask.title}`);
          }
          contentChanged = true;
        }
        if (tagsModified) {
          if (this.plugin.settings.debugMode) {
            console.log(`Tags modified for task ${lineTask_ticktick_id}, , ${lineTask.tags}, ${savedTask.tags}`);
          }
          tagsChanged = true;
        }
        if (dueDateModified) {
          if (this.plugin.settings.debugMode) {
            console.log(`Due date modified for task ${lineTask_ticktick_id}`);
            console.log("new: ", lineTask.dueDate, "old: ", savedTask.dueDate);
          }
          dueDateChanged = true;
        }
        lineTask.timeZone = savedTask.timeZone;
        if (projectModified || projectMoved) {
          await this.plugin.tickTickRestAPI?.moveTaskProject(lineTask, savedTask.projectId, lineTask.projectId);
          let noticeMessage = "";
          if (projectModified) {
            if (this.plugin.settings.debugMode) {
              console.log("Project Modified");
            }
            noticeMessage = `Task ${lineTask_ticktick_id}: ${lineTaskTitle} has moved from ${await this.plugin.cacheOperation?.getProjectNameByIdFromCache(savedTask.projectId)} to ${await this.plugin.cacheOperation?.getProjectNameByIdFromCache(lineTask.projectId)} 
If any children were moved, they will be updated to ${this.plugin.settings.baseURL} on the next Sync event`;
          } else if (projectMoved) {
            if (this.plugin.settings.debugMode) {
              console.log("Project Moved");
            }
            noticeMessage = `Task ${lineTask_ticktick_id}: ${lineTaskTitle} has moved from ${oldFilePath} to ${filepath} 
If any children were moved, they will be updated to ${this.plugin.settings.baseURL} on the next Sync event`;
          }
          new import_obsidian13.Notice(noticeMessage, 0);
          if (this.plugin.settings.debugMode) {
            console.log(noticeMessage);
          }
          projectChanged = true;
        }
        if (parentIdModified) {
          let oldParent = await this.plugin.cacheOperation?.loadTaskFromCacheID(savedTask.parentId);
          let newParent = await this.plugin.cacheOperation?.loadTaskFromCacheID(lineTask.parentId);
          let noticeMessage = `Task ${lineTask_ticktick_id}:
${this.plugin.taskParser?.stripOBSUrl(lineTaskTitle).trim()}
used to be a child of:
${oldParent ? oldParent.title.trim() : "No old parent found"}
but is now a child of:
${newParent ? newParent.title.trim() : "No new parent found."}
If any children were moved, they will be updated to ${this.plugin.settings.baseURL} on the next Sync event`;
          await this.plugin.tickTickRestAPI?.moveTaskParent(lineTask_ticktick_id, lineTask.parentId, lineTask.projectId);
          new import_obsidian13.Notice(noticeMessage, 0);
          if (this.plugin.settings.debugMode) {
            console.log(noticeMessage);
          }
          parentIdChanged = true;
        }
        if (priorityModified) {
          priorityChanged = true;
        }
        if (taskItemsModified) {
          if (this.plugin.settings.debugMode) {
            console.log("Number of items changed: ", lineTask.items?.length, savedTask.items?.length);
          }
          taskItemsChanged = true;
        }
        if (contentChanged || tagsChanged || dueDateChanged || projectChanged || parentIdChanged || priorityChanged || parentIdChanged || taskItemsChanged) {
          savedTask.modifiedTime = this.plugin.taskParser?.formatDateToISO(new Date());
          const updatedTask = await this.plugin.tickTickRestAPI?.UpdateTask(lineTask);
          if (!projectChanged) {
            await this.plugin.cacheOperation?.updateTaskToCacheByID(updatedTask, null);
          } else {
            await this.plugin.cacheOperation?.updateTaskToCacheByID(updatedTask, filepath);
          }
          await this.updateTaskLine(updatedTask, lineText, null, null, fileContent, lineNumber, filepath);
          modified = true;
        }
        if (statusModified) {
          if (this.plugin.settings.debugMode) {
            console.log(`Status modified for task ${lineTask_ticktick_id}`);
          }
          if (lineTask.status != 0) {
            if (this.plugin.settings.debugMode) {
              console.log(`task completed`);
            }
            this.plugin.tickTickRestAPI?.CloseTask(lineTask.id, lineTask.projectId);
            await this.plugin.cacheOperation?.closeTaskToCacheByID(lineTask.id);
          } else {
            if (this.plugin.settings.debugMode) {
              console.log(`task not completed`);
            }
            this.plugin.tickTickRestAPI?.OpenTask(lineTask.id, lineTask.projectId);
            await this.plugin.cacheOperation?.reopenTaskToCacheByID(lineTask.id);
          }
          statusChanged = true;
          new import_obsidian13.Notice(`Task Status for ${lineTask_ticktick_id} updated `);
        }
        if (contentChanged || tagsChanged || dueDateChanged || projectChanged || parentIdChanged || priorityChanged || parentIdChanged || taskItemsChanged) {
          await this.plugin.saveSettings();
          let message = `Task ${lineTask_ticktick_id} is updated.`;
          new import_obsidian13.Notice(message);
          if (contentChanged) {
            message += "\nContent was changed.";
          }
          if (statusChanged) {
            message += "\nStatus was changed.";
          }
          if (dueDateChanged) {
            message += "\nDue date was changed.";
          }
          if (tagsChanged) {
            message += "\nTags were changed.";
          }
          if (projectChanged) {
            message += "\nProject was changed.";
          }
          if (priorityChanged) {
            message += "\nPriority was changed.";
          }
          if (parentIdModified) {
            message += "\nParent was changed.";
          }
          if (taskItemsChanged) {
            message += "\nTask Items changed";
          }
          if (this.plugin.settings.debugMode) {
            console.log("Task Changed: ", lineTask.id, "\n", message);
          }
        } else {
        }
      } catch (error) {
        console.error("Error updating task:", error);
      }
    } else {
      if (!this.plugin.settings.enableFullVaultSync) {
        modified = await this.handleTaskItem(lineText, filepath, fileContent, lineNumber);
      }
    }
    return modified;
  }
  async handleTaskItem(lineText, filepath, fileContent, lineNumber) {
    let modified = false;
    let added = false;
    if (!this.plugin.taskParser?.isMarkdownTask(lineText)) {
      return;
    }
    let parsedItem = await this.plugin.taskParser?.taskFromLine(lineText, filepath);
    if (this.plugin.settings.debugMode) {
      if (!parsedItem) {
        console.error(`Task construction failed in line: ${lineText}`);
      }
    }
    if (!parsedItem.description || !parsedItem.status) {
      return;
    }
    let tabs = parsedItem?.indentation;
    let content = parsedItem?.description;
    if (content?.trim().length == 0) {
      modified = false;
      return modified;
    }
    const thisLineStatus = parsedItem.status.isCompleted();
    let parentTask = null;
    if (tabs.length > 0) {
      const lines = fileContent.split("\n");
      let itemId = "";
      let regex = /%%(.*)%%/;
      let match = regex.exec(content);
      if (match) {
        itemId = match[1];
      }
      for (let i = lineNumber - 1; i >= 0; i--) {
        const line = lines[i];
        if (this.plugin.taskParser?.hasTickTickId(line) && this.plugin.taskParser?.hasTickTickTag(line)) {
          const ticktickid = this.plugin.taskParser.getTickTickIdFromLineText(line);
          parentTask = await this.plugin.cacheOperation?.loadTaskFromCacheID(ticktickid);
          if (parentTask && parentTask.items) {
            if (itemId) {
              const oldItem = parentTask.items.find((item) => item.id === itemId);
              if (oldItem) {
                content = content.replace(regex, "");
                const oldItemStatus = oldItem.status == 0 ? false : true;
                if (content.trim() != oldItem.title.trim()) {
                  oldItem.title = content;
                  modified = true;
                }
                if (thisLineStatus != oldItemStatus) {
                  oldItem.status = thisLineStatus ? 2 : 0;
                  modified = true;
                }
                break;
              } else {
                console.error("item ID", itemId, " ", content.trim(), " not found in", parentTask.title);
                break;
              }
            } else {
              const Oid = (0, import_bson_objectid2.default)();
              const OidHexString = Oid.toHexString();
              parentTask.items.push({
                id: OidHexString,
                title: content,
                status: thisLineStatus ? 2 : 0
              });
              const updatedItemContent = `${lineText} %%${OidHexString}%%`;
              try {
                const markDownView = this.app.workspace.getActiveViewOfType(import_obsidian13.MarkdownView);
                const editor = markDownView?.app.workspace.activeEditor?.editor;
                const from = { line: lineNumber, ch: 0 };
                const to = { line: lineNumber, ch: updatedItemContent.length };
                editor?.setLine(lineNumber, updatedItemContent);
              } catch (error) {
                console.error(`Error updating item: ${error}`);
              }
              added = true;
              break;
            }
          } else {
            if (this.plugin.settings.debugMode) {
              console.log(`parent didn't have items.`);
            }
            break;
          }
          break;
        }
      }
      if (modified || added) {
        if (parentTask) {
          parentTask.modifiedTime = this.plugin.taskParser?.formatDateToISO(new Date());
          await this.plugin.cacheOperation?.updateTaskToCacheByID(parentTask);
          let taskURL = this.plugin.taskParser?.getObsidianUrlFromFilepath(filepath);
          if (taskURL) {
            parentTask.title = parentTask.title + " " + taskURL;
          }
          const result = await this.plugin.tickTickRestAPI?.UpdateTask(parentTask);
          const action = added ? "added" : "modified";
          new import_obsidian13.Notice(`new Item ${content} ${action}`);
          modified = true;
        }
      }
    }
    return modified;
  }
  async deleteTaskItemCheck(filepath, lineText, lineNumber, fileContent) {
    if (!this.plugin.taskParser?.hasTickTickId(lineText) && !this.plugin.taskParser?.hasTickTickTag(lineText) && this.plugin.taskParser?.isMarkdownTask(lineText)) {
      let modified = false;
      if (!this.plugin.taskParser?.isMarkdownTask(lineText)) {
        return;
      }
      let parsedItem = await this.plugin.taskParser?.taskFromLine(lineText, filepath);
      let tabs = parsedItem?.indentation;
      let content = parsedItem.description;
      const thisLineStatus = parsedItem.status.isCompleted();
      let parentTask;
      if (tabs.length > 0) {
        const lines = fileContent.split("\n");
        for (let i = lineNumber - 1; i >= 0; i--) {
          const line = lines[i];
          if (this.plugin.taskParser?.hasTickTickId(line) && this.plugin.taskParser?.hasTickTickTag(line)) {
            const ticktickid = this.plugin.taskParser.getTickTickIdFromLineText(line);
            parentTask = await this.plugin.cacheOperation?.loadTaskFromCacheID(ticktickid);
            if (parentTask && parentTask.items) {
              let itemId = "";
              let regex = /%%(.*)%%/;
              let match = regex.exec(content);
              if (match) {
                itemId = match[1];
                const oldItem = parentTask.items.find((item) => item.id === itemId);
                if (oldItem) {
                  parentTask.items = parentTask.items.filter((item) => item.id !== itemId);
                  modified = true;
                }
                break;
              } else {
                console.log(`${itemId} Not found.`);
                break;
              }
            } else {
              console.log(`parent didn't have items.`);
              break;
            }
          }
        }
        if (modified) {
          parentTask.modifiedTime = this.plugin.taskParser?.formatDateToISO(new Date());
          const result = await this.plugin.tickTickRestAPI?.UpdateTask(parentTask);
          await this.plugin.cacheOperation?.updateTaskToCacheByID(parentTask);
        }
      }
    }
  }
  async fullTextModifiedTaskCheck(file_path) {
    let file;
    let currentFileValue;
    let view;
    let filepath;
    try {
      if (file_path) {
        file = this.app.vault.getAbstractFileByPath(file_path);
        if (file && file instanceof import_obsidian13.TFolder) {
          return;
        }
        filepath = file_path;
        currentFileValue = await this.app.vault.read(file);
      } else {
        view = this.app.workspace.getActiveViewOfType(import_obsidian13.MarkdownView);
        file = this.app.workspace.getActiveFile();
        filepath = file?.path;
        currentFileValue = view?.data;
      }
      const content = currentFileValue;
      let hasModifiedTask = false;
      const lines = content.split("\n");
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (this.plugin.taskParser?.isMarkdownTask(line)) {
          try {
            await this.lineModifiedTaskCheck(filepath, line, i, content);
            hasModifiedTask = true;
          } catch (error) {
            console.error("Error modifying task:", error);
            continue;
          }
        }
      }
      if (hasModifiedTask) {
        try {
        } catch (error) {
          console.error("Error processing modified content:", error);
        }
      }
    } catch (error) {
      console.error("Error:", error);
    }
  }
  // Close a task by calling API and updating JSON file
  async closeTask(taskId) {
    try {
      let projectId = await this.plugin.cacheOperation?.closeTaskToCacheByID(taskId);
      await this.plugin.tickTickRestAPI?.CloseTask(taskId, projectId);
      await this.plugin.fileOperation?.completeTaskInTheFile(taskId);
      this.plugin.saveSettings();
      new import_obsidian13.Notice(`Task ${taskId} is closed.`);
    } catch (error) {
      console.error("Error closing task:", error);
      throw error;
    }
  }
  //open task
  async reopenTask(taskId) {
    try {
      let projectId = await this.plugin.cacheOperation?.reopenTaskToCacheByID(taskId);
      await this.plugin.tickTickRestAPI?.OpenTask(taskId, projectId);
      await this.plugin.fileOperation.uncompleteTaskInTheFile(taskId);
      this.plugin.saveSettings();
      new import_obsidian13.Notice(`Task ${taskId} is reopened.`);
    } catch (error) {
      console.error("Error opening task:", error);
      throw error;
    }
  }
  /**
   * Delete the task with the specified ID from the task list and update the JSON file
   * @param taskIds array of task IDs to be deleted
   * @returns Returns the successfully deleted task ID array
   */
  async deleteTasksByIds(taskIds) {
    const deletedTaskIds = [];
    const bConfirm = await this.confirmDeletion(taskIds, "The tasks were removed from the file");
    if (!bConfirm) {
      new import_obsidian13.Notice("Tasks will not be deleted. Please rectify the issue before the next sync.", 0);
      return [];
    }
    const api = await this.plugin.tickTickRestAPI?.initializeAPI();
    for (const taskId of taskIds) {
      try {
        let response;
        let projectId = await this.plugin.cacheOperation?.getProjectIdForTask(taskId);
        if (projectId) {
          response = await this.plugin.tickTickRestAPI?.deleteTask(taskId, projectId);
        }
        if (response) {
          new import_obsidian13.Notice(`Task ${taskId} is deleted.`);
        }
        deletedTaskIds.push(taskId);
      } catch (error) {
        console.error(`Failed to delete task ${taskId}: ${error}`);
      }
    }
    if (!deletedTaskIds.length) {
      if (this.plugin.settings.debugMode) {
        console.log("Task not deleted");
      }
      return [];
    }
    await this.plugin.cacheOperation?.deleteTaskFromCacheByIDs(deletedTaskIds);
    this.plugin.saveSettings();
    return deletedTaskIds;
  }
  //TODO: Determine deletion candidate
  // Synchronize completed task status to Obsidian file
  async syncCompletedTaskStatusToObsidian(unSynchronizedEvents) {
    try {
      const processedEvents = [];
      for (const e of unSynchronizedEvents) {
        await this.plugin.fileOperation.completeTaskInTheFile(e.object_id);
        await this.plugin.cacheOperation?.closeTaskToCacheByID(e.object_id);
        new import_obsidian13.Notice(`Task ${e.object_id} is closed.`);
        processedEvents.push(e);
      }
      await this.plugin.cacheOperation?.appendTaskToCache(processedEvents);
      this.plugin.saveSettings();
    } catch (error) {
      console.error("Error synchronizing task status:", error);
    }
  }
  // Synchronize completed task status to Obsidian file
  //TODO: Determine deletion candidate
  async syncUncompletedTaskStatusToObsidian(unSynchronizedEvents) {
    try {
      const processedEvents = [];
      for (const e of unSynchronizedEvents) {
        await this.plugin.fileOperation.uncompleteTaskInTheFile(e.object_id);
        await this.plugin.cacheOperation?.reopenTaskToCacheByID(e.object_id);
        new import_obsidian13.Notice(`Task ${e.object_id} is reopened.`);
        processedEvents.push(e);
      }
      await this.plugin.cacheOperation?.appendTaskToCache(processedEvents);
      this.plugin.saveSettings();
    } catch (error) {
      console.error("Error synchronizing task status:", error);
    }
  }
  async syncTickTickToObsidian() {
    try {
      const res = await this.plugin.cacheOperation?.saveProjectsToCache();
      if (!res) {
        console.error("probable network connection error.");
        return;
      }
      let bModifiedFileSystem = false;
      let allTaskDetails = await this.plugin.tickTickRestAPI?.getAllTasks();
      let tasksFromTickTic = allTaskDetails.update;
      let deletedTasks = allTaskDetails.delete;
      if (this.plugin.settings.SyncTag && this.plugin.settings.SyncProject) {
        let hasTag;
        hasTag = tasksFromTickTic.filter((task) => {
          hasTag = task.tags?.includes(this.plugin.settings.SyncTag.toLowerCase());
          return hasTag;
        });
        if (hasTag) {
          tasksFromTickTic = hasTag.filter((task) => {
            return task.projectId === this.plugin.settings.SyncProject;
          });
        } else {
          return;
        }
      } else if (this.plugin.settings.SyncTag || this.plugin.settings.SyncProject) {
        tasksFromTickTic = tasksFromTickTic.filter((task) => {
          const hasTag = task.tags?.includes(this.plugin.settings.SyncTag.toLowerCase());
          const hasProjectId = task.projectId === this.plugin.settings.SyncProject;
          return hasTag || hasProjectId;
        });
        if (!tasksFromTickTic || !(tasksFromTickTic.length > 0)) {
          return;
        }
      }
      let tasksInCache = await this.plugin.cacheOperation?.loadTasksFromCache();
      if (this.plugin.settings.debugMode) {
        if (tasksFromTickTic) {
          console.log("We have: ", tasksFromTickTic.length, " tasks on " + this.plugin.tickTickRestAPI?.api?.apiUrl);
          const closedTasks = tasksFromTickTic.filter((task) => task.status != 0);
          const openTasks = tasksFromTickTic.filter((task) => task.status === 0);
          console.log("openTasks", openTasks.length, "closedTasks", closedTasks.length);
        } else {
          console.log("No tasks found.");
        }
        if (tasksInCache) {
          console.log("There are: ", tasksInCache.length, " tasks in Cache.");
        } else {
          console.log("There are no tasks in cache.");
        }
      }
      tasksFromTickTic = tasksFromTickTic.sort((a, b) => a.id > b.id ? 1 : b.id > a.id ? -1 : 0);
      if (tasksInCache) {
        tasksInCache = tasksInCache.sort((a, b) => a.id > b.id ? 1 : b.id > a.id ? -1 : 0);
      } else {
        tasksInCache = [];
      }
      if (tasksFromTickTic) {
        tasksFromTickTic = tasksFromTickTic.sort((a, b) => a.id > b.id ? 1 : b.id > a.id ? -1 : 0);
      } else {
        tasksFromTickTic = [];
      }
      const newTickTickTasks = tasksFromTickTic.filter((task) => !tasksInCache.some((t) => t.id === task.id));
      if (newTickTickTasks.length > 0) {
        let result = await this.plugin.fileOperation?.addTasksToFile(newTickTickTasks);
        if (result) {
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
        bModifiedFileSystem = true;
      }
      const deletedTickTickTasks = tasksInCache.filter((task) => !tasksFromTickTic.some((t) => t.id === task.id));
      const reallyDeletedTickTickTasks = deletedTickTickTasks.filter((task) => deletedTasks.some((t) => t.taskId === task.id));
      if (reallyDeletedTickTickTasks.length > 0) {
        const taskTitlesForConfirmation = reallyDeletedTickTickTasks.map((task) => task.id);
        const bConfirm = await this.confirmDeletion(taskTitlesForConfirmation, "tasks deleted from TickTick");
        if (bConfirm) {
          for (const task of reallyDeletedTickTickTasks) {
            try {
              await this.plugin.fileOperation?.deleteTaskFromFile(task);
            } catch (error) {
              console.log("Tasks with no associated file found.");
            }
            await this.plugin.cacheOperation?.deleteTaskFromCache(task.id);
            bModifiedFileSystem = true;
          }
        }
      }
      const newObsidianTasks = tasksInCache.filter((task) => !tasksFromTickTic.some((t) => t.id === task.id));
      const reallyNewObsidianTasks = newObsidianTasks.filter((task) => reallyDeletedTickTickTasks.some((t) => t.taskId === task.id));
      for (const task of reallyNewObsidianTasks) {
        await this.plugin.tickTickRestAPI?.AddTask(task);
        bModifiedFileSystem = true;
      }
      const tasksUpdatedInTickTick = tasksFromTickTic.filter((task) => {
        const modifiedTask = tasksInCache.find((t) => t.id === task.id);
        return modifiedTask && new Date(modifiedTask.modifiedTime) < new Date(task.modifiedTime);
      });
      const tasksUpdatedInObsidian = tasksInCache.filter((task) => {
        const modifiedTask = tasksFromTickTic.find((t) => t.id === task.id);
        return modifiedTask && new Date(modifiedTask.modifiedTime) > new Date(task.modifiedTime);
      });
      const recentUpdates = tasksUpdatedInTickTick.filter((tickTask) => {
        const obsTask = tasksUpdatedInObsidian.find((obsTask2) => obsTask2.id === tickTask.id);
        if (obsTask && obsTask.modifiedTime === void 0) {
          return true;
        } else {
          return obsTask && new Date(tickTask.modifiedTime) > new Date(obsTask.modifiedTime);
        }
      });
      recentUpdates.sort((left2, right2) => {
        if (!left2.parentId && right2.parentId) {
          return -1;
        } else if (left2.parentId && !right2.parentId) {
          return 1;
        } else {
          return 0;
        }
      });
      const toBeProcessed = recentUpdates.map((task) => task.id);
      for (const task of recentUpdates) {
        await this.plugin.fileOperation?.updateTaskInFile(task, toBeProcessed);
        await this.plugin.cacheOperation?.updateTaskToCacheByID(task);
        bModifiedFileSystem = true;
      }
      if (bModifiedFileSystem) {
        await new Promise((resolve) => setTimeout(resolve, 5e3));
      }
      await this.plugin.saveSettings();
      if (this.plugin.settings.debugMode) {
        console.log(bModifiedFileSystem ? "File System Modified." : "No synchronization changes.");
      }
      return bModifiedFileSystem;
    } catch (err) {
      console.error("An error occurred while synchronizing:", err);
    }
  }
  dumpArray(which, arrayIn) {
    console.log(which);
    arrayIn.forEach(
      (item) => {
        console.log(
          " ",
          item
        );
      }
    );
  }
  ///End of Test
  async backupTickTickAllResources() {
    try {
      const bkupData = await this.plugin.tickTickRestAPI?.exportData();
      if (bkupData) {
        const now = new Date();
        const timeString = `${now.getFullYear()}${now.getMonth() + 1}${now.getDate()}${now.getHours()}${now.getMinutes()}${now.getSeconds()}`;
        const name = "ticktick-backup-" + timeString + ".csv";
        await this.app.vault.create(name, bkupData);
        new import_obsidian13.Notice(`TickTick backup data is saved in the path ${name}`);
      }
    } catch (error) {
      console.error("An error occurred while creating TickTick backup", error);
      new import_obsidian13.Notice("An error occurred while creating TickTick backup" + error, 0);
    }
  }
  //After renaming the file, check all tasks in the file and update all links.
  async updateTaskContent(filepath) {
    const metadata = await this.plugin.cacheOperation?.getFileMetadata(filepath);
    if (!metadata || !metadata.TickTickTasks) {
      return;
    }
    const taskURL = this.plugin.taskParser?.getObsidianUrlFromFilepath(filepath);
    try {
      for (const taskDetail of metadata.TickTickTasks) {
        const task = await this.plugin.cacheOperation?.loadTaskFromCacheID(taskDetail.taskId);
        if (task) {
          task.title = task.title + " " + taskURL;
          const updatedTask = await this.plugin.tickTickRestAPI?.UpdateTask(task);
          updatedTask.title = await this.plugin.taskParser?.stripOBSUrl(updatedTask.title);
          await this.plugin.cacheOperation?.updateTaskToCacheByID(updatedTask);
        } else {
          const error = "Task: " + taskDetail + "from file: " + filepath + "not found.";
          throw new Error(error);
        }
      }
    } catch (error) {
      console.error("An error occurred in updateTaskDescription:", error);
    }
  }
  async confirmDeletion(taskIds, reason) {
    const tasksTitles = await this.plugin.cacheOperation?.getTaskTitles(taskIds);
    const myModal = new TaskDeletionModal(this.app, tasksTitles, reason, (result) => {
      this.ret = result;
    });
    const bConfirmation = await myModal.showModal();
    return bConfirmation;
  }
};

// src/modals/DefaultProjectModal.ts
var import_obsidian14 = require("obsidian");
var SetDefaultProjectForFileModal = class extends import_obsidian14.Modal {
  defaultProjectId;
  defaultProjectName;
  filepath;
  plugin;
  constructor(app2, plugin, filepath) {
    super(app2);
    this.filepath = filepath;
    this.plugin = plugin;
    this.open();
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h5", { text: "Set default project for TickTick tasks in the current file" });
    this.defaultProjectId = await this.plugin.cacheOperation?.getDefaultProjectIdForFilepath(this.filepath);
    this.defaultProjectName = await this.plugin.cacheOperation?.getProjectNameByIdFromCache(this.defaultProjectId);
    const fileMetadata = this.plugin.settings.fileMetadata;
    const defaultProjectIds = Object.values(fileMetadata).map((meta) => meta.defaultProjectId);
    const allowableProjects = this.plugin.settings.TickTickTasksData?.projects?.filter((project) => !defaultProjectIds.includes(project.id));
    const myProjectsOptions = allowableProjects.reduce(
      (obj, item) => {
        obj[item.id] = item.name;
        return obj;
      },
      {}
    );
    new import_obsidian14.Setting(contentEl).setName("Default project").addDropdown(
      (component) => component.addOption(this.defaultProjectId, this.defaultProjectName).addOption("", "").addOptions(myProjectsOptions).onChange(async (value) => {
        await this.plugin.cacheOperation?.setDefaultProjectIdForFilepath(this.filepath, value);
        await this.plugin.setStatusBarText();
        this.close();
      })
    );
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var TickTickSync = class extends import_obsidian15.Plugin {
  settings;
  tickTickRestAPI;
  tickTickSyncAPI;
  taskParser;
  cacheOperation;
  fileOperation;
  tickTickSync;
  lastLines;
  statusBar;
  syncLock;
  async onload() {
    const isSettingsLoaded = await this.loadSettings();
    if (!isSettingsLoaded) {
      new import_obsidian15.Notice("Settings failed to load. Please reload the TickTickSync plugin.");
      return;
    }
    if (!this.settings.version) {
      const fileMetataDataStructure = this.settings.fileMetadata;
      for (let file in fileMetataDataStructure) {
        let oldTasksHolder = fileMetataDataStructure[file];
        let newTasksHolder = {};
        newTasksHolder = {
          TickTickTasks: oldTasksHolder.TickTickTasks.map((taskIDString) => ({
            taskId: taskIDString,
            taskItems: []
            //TODO: Validate that the assumption that the next sync will fill these correctly.
          })),
          TickTickCount: oldTasksHolder.TickTickCount,
          defaultProjectId: oldTasksHolder.defaultProjectId
        };
        fileMetataDataStructure[file] = newTasksHolder;
      }
      if (this.settings && this.settings.apiInitialized) {
        await this.scheduledSynchronization();
      }
    }
    if (!this.settings.version || this.isOlder(this.settings.version, "1.0.10")) {
      delete this.settings.username;
      delete this.settings.password;
    }
    if (!this.settings.version || this.isOlder(this.settings.version, this.manifest.version)) {
      this.settings.version = this.manifest.version;
      await this.saveSettings();
    }
    this.addSettingTab(new TickTickSyncSettingTab(this.app, this));
    this.settings.apiInitialized = false;
    try {
      await this.initializePlugin();
    } catch (Error2) {
      console.error("API Initialization Failed.");
    }
    this.lastLines = /* @__PURE__ */ new Map();
    if (this.settings.debugMode) {
      const ribbonIconEl = this.addRibbonIcon("sync", "TickTickSync", async (evt) => {
        await this.scheduledSynchronization();
        await this.unlockSynclock();
        new import_obsidian15.Notice(`Sync completed..`);
      });
    }
    this.registerDomEvent(document, "keyup", async (evt) => {
      if (!this.settings.apiInitialized) {
        return;
      }
      const markDownView = this.app.workspace.getActiveViewOfType(import_obsidian15.MarkdownView);
      const editor = markDownView?.app.workspace.activeEditor?.editor;
      if (!markDownView || !editor || editor && !editor.hasFocus()) {
        return;
      }
      if (evt.key === "ArrowUp" || evt.key === "ArrowDown" || evt.key === "ArrowLeft" || evt.key === "ArrowRight" || evt.key === "PageUp" || evt.key === "PageDown") {
        if (!this.checkModuleClass()) {
          return;
        }
        await this.lineNumberCheck();
      }
      if (evt.key === "Delete" || evt.key === "Backspace") {
        try {
          if (!this.checkModuleClass()) {
            return;
          }
          if (!await this.checkAndHandleSyncLock())
            return;
          await this.tickTickSync?.deletedTaskCheck(null);
          await this.unlockSynclock();
          await this.saveSettings();
        } catch (error) {
          console.error(`An error occurred while deleting tasks: ${error}`);
          await this.unlockSynclock();
        }
      }
    });
    function traverseDOMBackwards(element, callback) {
      while (element) {
        callback(element);
        element = element.previousElementSibling;
      }
    }
    this.registerDomEvent(document, "click", async (evt) => {
      const { target } = evt;
      const markDownView = this.app.workspace.getActiveViewOfType(import_obsidian15.MarkdownView);
      const file = markDownView?.app.workspace.activeEditor?.file;
      const fileName = file?.name;
      const filepath = file?.path;
      if (!this.settings.apiInitialized) {
        return;
      }
      if (!this.checkModuleClass()) {
        return;
      }
      if (this.app.workspace.activeEditor?.editor?.hasFocus()) {
        await this.lineNumberCheck();
      } else {
        return;
      }
      if (target && target.type === "checkbox") {
        await this.checkboxEventhandle(evt);
      }
    });
    this.registerEvent(this.app.workspace.on("editor-change", async (editor, view) => {
      try {
        if (!this.settings.apiInitialized) {
          return;
        }
        await this.lineNumberCheck();
        if (!this.checkModuleClass()) {
          return;
        }
        if (this.settings.enableFullVaultSync) {
          return;
        }
        if (!await this.checkAndHandleSyncLock())
          return;
        await this.tickTickSync?.lineContentNewTaskCheck(editor, view);
        await this.saveSettings();
        await this.unlockSynclock();
      } catch (error) {
        console.error(`An error occurred while check new task in line: ${error.message}`);
        await this.unlockSynclock();
      }
    }));
    this.registerEvent(this.app.vault.on("delete", async (file) => {
      if (file instanceof import_obsidian15.TFolder) {
        return;
      }
      if (!this.settings.apiInitialized) {
        console.error("API Not intialized!");
        return;
      }
      const fileMetadata = await this.cacheOperation?.getFileMetadata(file.path, null);
      if (!fileMetadata || !fileMetadata.TickTickTasks) {
        return;
      }
      if (!this.checkModuleClass()) {
        return;
      }
      await this.tickTickSync.deletedTaskCheck(file.path);
      await this.cacheOperation?.deleteFilepathFromMetadata(file.path);
      await this.saveSettings();
      await this.unlockSynclock();
    }));
    this.registerEvent(this.app.vault.on("rename", async (file, oldpath) => {
      if (!this.settings.apiInitialized) {
        console.error("API Not intialized!");
        return;
      }
      const fileMetadata = await this.cacheOperation?.getFileMetadata(oldpath, null);
      if (!fileMetadata || !fileMetadata.TickTickTasks) {
        return;
      }
      if (!this.checkModuleClass()) {
        return;
      }
      await this.cacheOperation?.updateRenamedFilePath(oldpath, file.path);
      await this.saveSettings();
      if (!await this.checkAndHandleSyncLock())
        return;
      try {
        await this.tickTickSync?.updateTaskContent(file.path);
      } catch (error) {
        console.error("An error occurred in updateTaskDescription:", error);
      }
      await this.unlockSynclock();
    }));
    this.registerEvent(this.app.vault.on("modify", async (file) => {
      try {
        if (!this.settings.apiInitialized) {
          return;
        }
        const filepath = file.path;
        const activateFile = this.app.workspace.getActiveFile();
        if (activateFile?.path == filepath) {
          return;
        }
        if (!await this.checkAndHandleSyncLock())
          return;
        await this.tickTickSync?.fullTextNewTaskCheck(filepath);
        await this.unlockSynclock();
      } catch (error) {
        console.error(`An error occurred while modifying the file: ${error.message}`);
        await this.unlockSynclock();
      }
    }));
    this.registerInterval(window.setInterval(async () => await this.scheduledSynchronization(), this.settings.automaticSynchronizationInterval * 1e3));
    this.registerEvent(this.app.workspace.on("active-leaf-change", async (leaf) => {
      await this.setStatusBarText();
    }));
    this.addCommand({
      id: "set-default-project-for-TickTick-task-in-the-current-file",
      name: "Set default TickTick project for Tasks in the current file",
      editorCallback: (editor, view) => {
        if (!view) {
          return;
        }
        const filepath = view.file.path;
        new SetDefaultProjectForFileModal(this.app, this, filepath);
      }
    });
    this.statusBar = this.addStatusBarItem();
    console.log(`${this.manifest.name} ${this.manifest.version} loaded!`);
  }
  async onunload() {
    console.log(`TickTickSync unloaded!`);
  }
  async loadSettings() {
    try {
      const data = await this.loadData();
      this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
      return true;
    } catch (error) {
      console.error("Failed to load data:", error);
      return false;
    }
  }
  async saveSettings() {
    try {
      if (this.settings && Object.keys(this.settings).length > 0) {
        await this.saveData(this.settings);
      } else {
        console.error("Settings are empty or invalid, not saving to avoid data loss.");
      }
    } catch (error) {
      console.error("Error saving settings:", error);
    }
  }
  // return true of false
  async initializePlugin() {
    this.tickTickRestAPI = new TickTickRestAPI(this.app, this, null);
    await this.tickTickRestAPI.initializeAPI();
    this.cacheOperation = new CacheOperation(this.app, this);
    let isProjectsSaved = false;
    if (this.settings.apiInitialized) {
      isProjectsSaved = await this.cacheOperation?.saveProjectsToCache();
    }
    if (!isProjectsSaved) {
      this.tickTickRestAPI = void 0;
      this.tickTickSyncAPI = void 0;
      this.taskParser = void 0;
      this.taskParser = void 0;
      this.cacheOperation = void 0;
      this.fileOperation = void 0;
      this.tickTickSync = void 0;
      new import_obsidian15.Notice(`TickTickSync plugin initialization failed, please check userID and password in settings.`);
      return;
    }
    if (!this.settings.initialized) {
      try {
        if (!this.settings.SyncTag) {
          this.settings.SyncTag = "";
          await this.saveSettings();
        }
        if (!this.settings.SyncProject) {
          this.settings.SyncProject = "";
          await this.saveSettings();
        }
        this.taskParser = new TaskParser(this.app, this);
        this.fileOperation = new FileOperation(this.app, this);
        this.tickTickSyncAPI = new TickTickSyncAPI(this.app, this);
        this.tickTickSync = new SyncMan(this.app, this);
        this.tickTickSync?.backupTickTickAllResources();
      } catch (error) {
        console.error(`error creating user data folder: ${error}`);
        new import_obsidian15.Notice(`error creating user data folder`);
        return;
      }
      this.settings.initialized = true;
      await this.saveSettings();
      new import_obsidian15.Notice(`TickTickSync initialization successful. TickTick data has been backed up.`);
    }
    await this.initializeModuleClass();
    await this.unlockSynclock();
    new import_obsidian15.Notice(`TickTickSync loaded successfully.`);
    return true;
  }
  async initializeModuleClass() {
    if (!this.tickTickRestAPI) {
      this.tickTickRestAPI = new TickTickRestAPI(this.app, this, null);
    }
    this.cacheOperation = new CacheOperation(this.app, this);
    this.taskParser = new TaskParser(this.app, this);
    this.fileOperation = new FileOperation(this.app, this);
    this.tickTickSyncAPI = new TickTickSyncAPI(this.app, this);
    this.tickTickSync = new SyncMan(this.app, this);
  }
  async lineNumberCheck() {
    if (!await this.checkAndHandleSyncLock()) {
      console.log("We're locked. Returning.");
      return;
    }
    let modified = false;
    const markDownView = this.app.workspace.getActiveViewOfType(import_obsidian15.MarkdownView);
    if (markDownView) {
      const cursor = markDownView?.editor.getCursor();
      const line = cursor?.line;
      const fileContent = markDownView.data;
      const file = markDownView?.app.workspace.activeEditor?.file;
      const fileName = file?.name;
      const filepath = file?.path;
      if (typeof this.lastLines === "undefined" || typeof this.lastLines.get(fileName) === "undefined") {
        this.lastLines.set(fileName, line);
        await this.unlockSynclock();
        return false;
      }
      if (this.lastLines.has(fileName) && line !== this.lastLines.get(fileName)) {
        const lastLine = this.lastLines.get(fileName);
        const lastLineText = markDownView.editor.getLine(lastLine);
        if (!this.checkModuleClass()) {
          await this.unlockSynclock();
          return false;
        }
        this.lastLines.set(fileName, line);
        modified = await this.tickTickSync?.lineModifiedTaskCheck(filepath, lastLineText, lastLine, fileContent);
      } else {
      }
    }
    await this.unlockSynclock();
    return modified;
  }
  async checkboxEventhandle(evt) {
    const target = evt.target;
    const bOpenTask = target.checked;
    new import_obsidian15.Notice(`Task will be updated as ${bOpenTask ? "closed" : "opened"} on next Sync`);
  }
  // async oldCheckboxEventhandle(evt: MouseEvent) {
  // 	if (!(this.checkModuleClass())) {
  // 		return;
  // 	}
  //
  //
  // 	const target = evt.target as HTMLInputElement;
  // 	const bOpenTask = target.checked;
  // 	console.log('Second: Checked: ', bOpenTask);
  //
  // 	//This breaks for subtasks if Tasks is installed. See: https://github.com/obsidian-tasks-group/obsidian-tasks/discussions/2685
  // 	//hence the else.
  // 	const taskElement = target.closest('div');
  // 	if (taskElement) {
  // 		const taskLine = taskElement.textContent;
  // 		const taskId = this.taskParser?.getTickTickIdFromLineText(taskLine);
  // 		if (taskId) {
  // 			// let task = this.taskParser?.convertTextToTickTickTaskObject(tas)
  // 			if (bOpenTask) {
  // 				console.log('it\'s open, close it.');
  // 				this.tickTickSync?.closeTask(taskId);
  // 			} else {
  // 				console.log('it\'s closed, open it.');
  // 				this.tickTickSync?.reopenTask(taskId);
  // 			}
  // 		}
  // 	} else {
  // 		console.log('#### TickTick_id not found -- do it the hard way.');
  // 		//Start full-text search and check status updates
  // 		try {
  // 			console.log('#### Full text modified??');
  // 			let file = this.app.workspace.getActiveFile();
  // 			let filePath = null;
  // 			if (file instanceof TFile) {
  // 				filePath = file.path;
  // 			}
  //
  // 			if (!await this.checkAndHandleSyncLock()) return;
  // 			await this.tickTickSync?.fullTextModifiedTaskCheck(filePath);
  // 			await this.unlockSynclock();
  // 		} catch (error) {
  // 			console.error(`An error occurred while check modified tasks in the file: ${error}`);
  // 			await this.unlockSynclock();
  //
  // 		}
  // 	}
  // }
  //return true
  checkModuleClass() {
    if (this.settings.apiInitialized === true) {
      if (this.tickTickRestAPI === void 0 || this.tickTickSyncAPI === void 0 || this.cacheOperation === void 0 || this.fileOperation === void 0 || this.tickTickSync === void 0 || this.taskParser === void 0) {
        this.initializeModuleClass();
      }
      return true;
    } else {
      new import_obsidian15.Notice(`Please login from settings.`);
      return false;
    }
  }
  async setStatusBarText() {
    if (!this.checkModuleClass()) {
      return;
    }
    const markDownView = this.app.workspace.getActiveViewOfType(import_obsidian15.MarkdownView);
    if (!markDownView) {
      this.statusBar.setText("");
    } else {
      const filepath = markDownView?.file?.path;
      if (filepath === void 0) {
        return;
      }
      const defaultProjectName = await this.cacheOperation?.getDefaultProjectNameForFilepath(filepath);
      if (defaultProjectName === void 0) {
        return;
      }
      this.statusBar.setText(defaultProjectName);
    }
  }
  async scheduledSynchronization() {
    if (!this.checkModuleClass()) {
      return;
    }
    console.log("TickTick scheduled synchronization task started at", new Date().toLocaleString());
    try {
      if (!await this.checkAndHandleSyncLock()) {
        console.error("TickTick scheduled synchronization task terminated for sync loc at", new Date().toLocaleString());
        return;
      }
      try {
        let bChanged = await this.tickTickSync?.syncTickTickToObsidian();
        if (bChanged) {
          await this.unlockSynclock();
          console.log("TickTick scheduled synchronization task completed at", new Date().toLocaleString());
          return;
        }
      } catch (error) {
        console.error("An error occurred in syncTickTickToObsidian:", error);
        console.error("TickTick terminated synchronization task at", new Date().toLocaleString());
        await this.unlockSynclock();
        return;
      }
      await this.unlockSynclock();
      try {
        await this.saveSettings();
      } catch (error) {
        console.error("An error occurred in saveSettings:", error);
      }
      const filesToSync = this.settings.fileMetadata;
      let newFilesToSync = filesToSync;
      if (this.settings.SyncProject) {
        newFilesToSync = Object.fromEntries(Object.entries(filesToSync).filter(([key, value]) => value.defaultProjectId == this.settings.SyncProject));
      }
      try {
        const result = this.cacheOperation?.checkForDuplicates(newFilesToSync);
        if (result?.duplicates && JSON.stringify(result.duplicates) != "{}") {
          let dupText = "";
          for (let duplicatesKey in result.duplicates) {
            dupText += "Task: " + duplicatesKey + "\nin files: \n";
            result.duplicates[duplicatesKey].forEach((file) => {
              dupText += file + "\n";
            });
          }
          const msg = `Found duplicates in MetaData.

${dupText}
Please fix manually. This causes unpredictable results
Please open an issue in the TickTickSync repository if you continue to see this issue.

To prevent data corruption. Sync is aborted.`;
          console.log("Metadata Duplicates: ", result.duplicates);
          new import_obsidian15.Notice(msg, 0);
          return;
        }
        const duplicateTasksInFiles = await this.fileOperation?.checkForDuplicates(filesToSync, result?.taskIds);
        if (duplicateTasksInFiles && JSON.stringify(duplicateTasksInFiles) != "{}") {
          let dupText = "";
          for (let duplicateTasksInFilesKey in duplicateTasksInFiles) {
            dupText += "Task: " + duplicateTasksInFilesKey + "\nFound in Files: \n";
            duplicateTasksInFiles[duplicateTasksInFilesKey].forEach((file) => {
              dupText += file + "\n";
            });
          }
          const msg = `Found duplicates in Files.

${dupText}
Please fix manually. This causes unpredictable results
Please open an issue in the TickTickSync repository if you continue to see this issue.

To prevent data corruption. Sync is aborted.`;
          new import_obsidian15.Notice(msg, 0);
          return;
        }
      } catch (Error2) {
        console.error(Error2);
        new import_obsidian15.Notice(`Duplicate check failed:  ${Error2}`, 0);
        return;
      }
      for (const fileKey in newFilesToSync) {
        const file = this.app.vault.getAbstractFileByPath(fileKey);
        if (!file) {
          console.log("File ", fileKey, " was deleted before last sync.");
          await this.cacheOperation?.deleteFilepathFromMetadata(fileKey);
          const toDelete = newFilesToSync.findIndex(fileKey);
          newFilesToSync.splice(toDelete, 1);
        }
      }
      for (const fileKey in newFilesToSync) {
        if (this.settings.debugMode) {
          console.log(fileKey);
        }
        if (!await this.checkAndHandleSyncLock())
          return;
        try {
          await this.tickTickSync?.fullTextNewTaskCheck(fileKey);
        } catch (error) {
          console.error("An error occurred in fullTextNewTaskCheck:", error);
        }
        await this.unlockSynclock();
        if (!await this.checkAndHandleSyncLock())
          return;
        try {
          await this.tickTickSync?.fullTextModifiedTaskCheck(fileKey);
        } catch (error) {
          console.error("An error occurred in fullTextModifiedTaskCheck:", error);
        }
        await this.unlockSynclock();
        if (!await this.checkAndHandleSyncLock())
          return;
        try {
          await this.tickTickSync?.deletedTaskCheck(fileKey);
        } catch (error) {
          console.error("An error occurred in deletedTaskCheck:", error);
        }
        await this.unlockSynclock();
      }
    } catch (error) {
      console.error("An error occurred:", error);
      new import_obsidian15.Notice("An error occurred:", error);
      await this.unlockSynclock();
    }
    console.log("TickTick scheduled synchronization task completed at", new Date().toLocaleString());
  }
  async checkSyncLock() {
    let checkCount = 0;
    while (this.settings.syncLock && checkCount < 10) {
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      checkCount++;
    }
    return !this.settings.syncLock;
  }
  async unlockSynclock() {
    this.settings.syncLock = false;
    await this.saveSettings();
  }
  async checkAndHandleSyncLock() {
    if (this.settings.syncLock) {
      const isSyncLockChecked = await this.checkSyncLock();
      if (!isSyncLockChecked) {
        return false;
      }
    }
    this.settings.syncLock = true;
    await this.saveSettings();
    return true;
  }
  isOlder(version1, version2) {
    const v1 = version1.split(".");
    const v2 = version2.split(".");
    for (let i = 0; i < Math.max(v1.length, v2.length); i++) {
      const num1 = parseInt(v1[i] || 0);
      const num2 = parseInt(v2[i] || 0);
      if (num1 < num2) {
        return true;
      } else if (num1 > num2) {
        return false;
      }
    }
    return false;
  }
};
/*! Bundled license information:

eventemitter2/lib/eventemitter2.js:
  (*!
   * EventEmitter2
   * https://github.com/hij1nx/EventEmitter2
   *
   * Copyright (c) 2013 hij1nx
   * Licensed under the MIT license.
   *)
*/
